
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Article
 * 
 */
export type Article = $Result.DefaultSelection<Prisma.$ArticlePayload>
/**
 * Model MouvementStock
 * 
 */
export type MouvementStock = $Result.DefaultSelection<Prisma.$MouvementStockPayload>
/**
 * Model Inventaire
 * 
 */
export type Inventaire = $Result.DefaultSelection<Prisma.$InventairePayload>
/**
 * Model LigneInventaire
 * 
 */
export type LigneInventaire = $Result.DefaultSelection<Prisma.$LigneInventairePayload>
/**
 * Model Equipement
 * 
 */
export type Equipement = $Result.DefaultSelection<Prisma.$EquipementPayload>
/**
 * Model MaintenanceEquipement
 * 
 */
export type MaintenanceEquipement = $Result.DefaultSelection<Prisma.$MaintenanceEquipementPayload>
/**
 * Model Reception
 * 
 */
export type Reception = $Result.DefaultSelection<Prisma.$ReceptionPayload>
/**
 * Model LigneReception
 * 
 */
export type LigneReception = $Result.DefaultSelection<Prisma.$LigneReceptionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Unite: {
  PIECE: 'PIECE',
  KG: 'KG',
  M: 'M',
  L: 'L'
};

export type Unite = (typeof Unite)[keyof typeof Unite]


export const StatusArticle: {
  ACTIF: 'ACTIF',
  INACTIF: 'INACTIF',
  OBSOLETE: 'OBSOLETE'
};

export type StatusArticle = (typeof StatusArticle)[keyof typeof StatusArticle]


export const TypeMouvement: {
  ENTREE: 'ENTREE',
  SORTIE: 'SORTIE',
  AJUSTEMENT: 'AJUSTEMENT',
  TRANSFERT: 'TRANSFERT'
};

export type TypeMouvement = (typeof TypeMouvement)[keyof typeof TypeMouvement]


export const StatusInventaire: {
  PLANIFIE: 'PLANIFIE',
  EN_COURS: 'EN_COURS',
  TERMINE: 'TERMINE',
  VALIDE: 'VALIDE'
};

export type StatusInventaire = (typeof StatusInventaire)[keyof typeof StatusInventaire]


export const StatusEquipement: {
  DISPONIBLE: 'DISPONIBLE',
  EN_SERVICE: 'EN_SERVICE',
  EN_PANNE: 'EN_PANNE',
  EN_MAINTENANCE: 'EN_MAINTENANCE',
  REFORME: 'REFORME'
};

export type StatusEquipement = (typeof StatusEquipement)[keyof typeof StatusEquipement]


export const TypeMaintenance: {
  PREVENTIVE: 'PREVENTIVE',
  CORRECTIVE: 'CORRECTIVE'
};

export type TypeMaintenance = (typeof TypeMaintenance)[keyof typeof TypeMaintenance]


export const StatusMaintenance: {
  PLANIFIEE: 'PLANIFIEE',
  EN_COURS: 'EN_COURS',
  TERMINEE: 'TERMINEE',
  ANNULEE: 'ANNULEE'
};

export type StatusMaintenance = (typeof StatusMaintenance)[keyof typeof StatusMaintenance]


export const StatusReception: {
  EN_ATTENTE: 'EN_ATTENTE',
  PARTIELLE: 'PARTIELLE',
  COMPLETE: 'COMPLETE',
  VERIFIEE: 'VERIFIEE'
};

export type StatusReception = (typeof StatusReception)[keyof typeof StatusReception]

}

export type Unite = $Enums.Unite

export const Unite: typeof $Enums.Unite

export type StatusArticle = $Enums.StatusArticle

export const StatusArticle: typeof $Enums.StatusArticle

export type TypeMouvement = $Enums.TypeMouvement

export const TypeMouvement: typeof $Enums.TypeMouvement

export type StatusInventaire = $Enums.StatusInventaire

export const StatusInventaire: typeof $Enums.StatusInventaire

export type StatusEquipement = $Enums.StatusEquipement

export const StatusEquipement: typeof $Enums.StatusEquipement

export type TypeMaintenance = $Enums.TypeMaintenance

export const TypeMaintenance: typeof $Enums.TypeMaintenance

export type StatusMaintenance = $Enums.StatusMaintenance

export const StatusMaintenance: typeof $Enums.StatusMaintenance

export type StatusReception = $Enums.StatusReception

export const StatusReception: typeof $Enums.StatusReception

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Articles
 * const articles = await prisma.article.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Articles
   * const articles = await prisma.article.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.article`: Exposes CRUD operations for the **Article** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Articles
    * const articles = await prisma.article.findMany()
    * ```
    */
  get article(): Prisma.ArticleDelegate<ExtArgs>;

  /**
   * `prisma.mouvementStock`: Exposes CRUD operations for the **MouvementStock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MouvementStocks
    * const mouvementStocks = await prisma.mouvementStock.findMany()
    * ```
    */
  get mouvementStock(): Prisma.MouvementStockDelegate<ExtArgs>;

  /**
   * `prisma.inventaire`: Exposes CRUD operations for the **Inventaire** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventaires
    * const inventaires = await prisma.inventaire.findMany()
    * ```
    */
  get inventaire(): Prisma.InventaireDelegate<ExtArgs>;

  /**
   * `prisma.ligneInventaire`: Exposes CRUD operations for the **LigneInventaire** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LigneInventaires
    * const ligneInventaires = await prisma.ligneInventaire.findMany()
    * ```
    */
  get ligneInventaire(): Prisma.LigneInventaireDelegate<ExtArgs>;

  /**
   * `prisma.equipement`: Exposes CRUD operations for the **Equipement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Equipements
    * const equipements = await prisma.equipement.findMany()
    * ```
    */
  get equipement(): Prisma.EquipementDelegate<ExtArgs>;

  /**
   * `prisma.maintenanceEquipement`: Exposes CRUD operations for the **MaintenanceEquipement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaintenanceEquipements
    * const maintenanceEquipements = await prisma.maintenanceEquipement.findMany()
    * ```
    */
  get maintenanceEquipement(): Prisma.MaintenanceEquipementDelegate<ExtArgs>;

  /**
   * `prisma.reception`: Exposes CRUD operations for the **Reception** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Receptions
    * const receptions = await prisma.reception.findMany()
    * ```
    */
  get reception(): Prisma.ReceptionDelegate<ExtArgs>;

  /**
   * `prisma.ligneReception`: Exposes CRUD operations for the **LigneReception** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LigneReceptions
    * const ligneReceptions = await prisma.ligneReception.findMany()
    * ```
    */
  get ligneReception(): Prisma.LigneReceptionDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Article: 'Article',
    MouvementStock: 'MouvementStock',
    Inventaire: 'Inventaire',
    LigneInventaire: 'LigneInventaire',
    Equipement: 'Equipement',
    MaintenanceEquipement: 'MaintenanceEquipement',
    Reception: 'Reception',
    LigneReception: 'LigneReception'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "article" | "mouvementStock" | "inventaire" | "ligneInventaire" | "equipement" | "maintenanceEquipement" | "reception" | "ligneReception"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Article: {
        payload: Prisma.$ArticlePayload<ExtArgs>
        fields: Prisma.ArticleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArticleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArticleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          findFirst: {
            args: Prisma.ArticleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArticleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          findMany: {
            args: Prisma.ArticleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>[]
          }
          create: {
            args: Prisma.ArticleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          createMany: {
            args: Prisma.ArticleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArticleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>[]
          }
          delete: {
            args: Prisma.ArticleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          update: {
            args: Prisma.ArticleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          deleteMany: {
            args: Prisma.ArticleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArticleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ArticleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          aggregate: {
            args: Prisma.ArticleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArticle>
          }
          groupBy: {
            args: Prisma.ArticleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArticleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArticleCountArgs<ExtArgs>
            result: $Utils.Optional<ArticleCountAggregateOutputType> | number
          }
        }
      }
      MouvementStock: {
        payload: Prisma.$MouvementStockPayload<ExtArgs>
        fields: Prisma.MouvementStockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MouvementStockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementStockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MouvementStockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementStockPayload>
          }
          findFirst: {
            args: Prisma.MouvementStockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementStockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MouvementStockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementStockPayload>
          }
          findMany: {
            args: Prisma.MouvementStockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementStockPayload>[]
          }
          create: {
            args: Prisma.MouvementStockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementStockPayload>
          }
          createMany: {
            args: Prisma.MouvementStockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MouvementStockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementStockPayload>[]
          }
          delete: {
            args: Prisma.MouvementStockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementStockPayload>
          }
          update: {
            args: Prisma.MouvementStockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementStockPayload>
          }
          deleteMany: {
            args: Prisma.MouvementStockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MouvementStockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MouvementStockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementStockPayload>
          }
          aggregate: {
            args: Prisma.MouvementStockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMouvementStock>
          }
          groupBy: {
            args: Prisma.MouvementStockGroupByArgs<ExtArgs>
            result: $Utils.Optional<MouvementStockGroupByOutputType>[]
          }
          count: {
            args: Prisma.MouvementStockCountArgs<ExtArgs>
            result: $Utils.Optional<MouvementStockCountAggregateOutputType> | number
          }
        }
      }
      Inventaire: {
        payload: Prisma.$InventairePayload<ExtArgs>
        fields: Prisma.InventaireFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventaireFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventairePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventaireFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventairePayload>
          }
          findFirst: {
            args: Prisma.InventaireFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventairePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventaireFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventairePayload>
          }
          findMany: {
            args: Prisma.InventaireFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventairePayload>[]
          }
          create: {
            args: Prisma.InventaireCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventairePayload>
          }
          createMany: {
            args: Prisma.InventaireCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventaireCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventairePayload>[]
          }
          delete: {
            args: Prisma.InventaireDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventairePayload>
          }
          update: {
            args: Prisma.InventaireUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventairePayload>
          }
          deleteMany: {
            args: Prisma.InventaireDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventaireUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventaireUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventairePayload>
          }
          aggregate: {
            args: Prisma.InventaireAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventaire>
          }
          groupBy: {
            args: Prisma.InventaireGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventaireGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventaireCountArgs<ExtArgs>
            result: $Utils.Optional<InventaireCountAggregateOutputType> | number
          }
        }
      }
      LigneInventaire: {
        payload: Prisma.$LigneInventairePayload<ExtArgs>
        fields: Prisma.LigneInventaireFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LigneInventaireFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneInventairePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LigneInventaireFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneInventairePayload>
          }
          findFirst: {
            args: Prisma.LigneInventaireFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneInventairePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LigneInventaireFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneInventairePayload>
          }
          findMany: {
            args: Prisma.LigneInventaireFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneInventairePayload>[]
          }
          create: {
            args: Prisma.LigneInventaireCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneInventairePayload>
          }
          createMany: {
            args: Prisma.LigneInventaireCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LigneInventaireCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneInventairePayload>[]
          }
          delete: {
            args: Prisma.LigneInventaireDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneInventairePayload>
          }
          update: {
            args: Prisma.LigneInventaireUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneInventairePayload>
          }
          deleteMany: {
            args: Prisma.LigneInventaireDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LigneInventaireUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LigneInventaireUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneInventairePayload>
          }
          aggregate: {
            args: Prisma.LigneInventaireAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLigneInventaire>
          }
          groupBy: {
            args: Prisma.LigneInventaireGroupByArgs<ExtArgs>
            result: $Utils.Optional<LigneInventaireGroupByOutputType>[]
          }
          count: {
            args: Prisma.LigneInventaireCountArgs<ExtArgs>
            result: $Utils.Optional<LigneInventaireCountAggregateOutputType> | number
          }
        }
      }
      Equipement: {
        payload: Prisma.$EquipementPayload<ExtArgs>
        fields: Prisma.EquipementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipementPayload>
          }
          findFirst: {
            args: Prisma.EquipementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipementPayload>
          }
          findMany: {
            args: Prisma.EquipementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipementPayload>[]
          }
          create: {
            args: Prisma.EquipementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipementPayload>
          }
          createMany: {
            args: Prisma.EquipementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EquipementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipementPayload>[]
          }
          delete: {
            args: Prisma.EquipementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipementPayload>
          }
          update: {
            args: Prisma.EquipementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipementPayload>
          }
          deleteMany: {
            args: Prisma.EquipementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EquipementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipementPayload>
          }
          aggregate: {
            args: Prisma.EquipementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipement>
          }
          groupBy: {
            args: Prisma.EquipementGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipementGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipementCountArgs<ExtArgs>
            result: $Utils.Optional<EquipementCountAggregateOutputType> | number
          }
        }
      }
      MaintenanceEquipement: {
        payload: Prisma.$MaintenanceEquipementPayload<ExtArgs>
        fields: Prisma.MaintenanceEquipementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaintenanceEquipementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceEquipementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaintenanceEquipementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceEquipementPayload>
          }
          findFirst: {
            args: Prisma.MaintenanceEquipementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceEquipementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaintenanceEquipementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceEquipementPayload>
          }
          findMany: {
            args: Prisma.MaintenanceEquipementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceEquipementPayload>[]
          }
          create: {
            args: Prisma.MaintenanceEquipementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceEquipementPayload>
          }
          createMany: {
            args: Prisma.MaintenanceEquipementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaintenanceEquipementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceEquipementPayload>[]
          }
          delete: {
            args: Prisma.MaintenanceEquipementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceEquipementPayload>
          }
          update: {
            args: Prisma.MaintenanceEquipementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceEquipementPayload>
          }
          deleteMany: {
            args: Prisma.MaintenanceEquipementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaintenanceEquipementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaintenanceEquipementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceEquipementPayload>
          }
          aggregate: {
            args: Prisma.MaintenanceEquipementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintenanceEquipement>
          }
          groupBy: {
            args: Prisma.MaintenanceEquipementGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceEquipementGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaintenanceEquipementCountArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceEquipementCountAggregateOutputType> | number
          }
        }
      }
      Reception: {
        payload: Prisma.$ReceptionPayload<ExtArgs>
        fields: Prisma.ReceptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReceptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReceptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionPayload>
          }
          findFirst: {
            args: Prisma.ReceptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReceptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionPayload>
          }
          findMany: {
            args: Prisma.ReceptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionPayload>[]
          }
          create: {
            args: Prisma.ReceptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionPayload>
          }
          createMany: {
            args: Prisma.ReceptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReceptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionPayload>[]
          }
          delete: {
            args: Prisma.ReceptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionPayload>
          }
          update: {
            args: Prisma.ReceptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionPayload>
          }
          deleteMany: {
            args: Prisma.ReceptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReceptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReceptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionPayload>
          }
          aggregate: {
            args: Prisma.ReceptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReception>
          }
          groupBy: {
            args: Prisma.ReceptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReceptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReceptionCountArgs<ExtArgs>
            result: $Utils.Optional<ReceptionCountAggregateOutputType> | number
          }
        }
      }
      LigneReception: {
        payload: Prisma.$LigneReceptionPayload<ExtArgs>
        fields: Prisma.LigneReceptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LigneReceptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneReceptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LigneReceptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneReceptionPayload>
          }
          findFirst: {
            args: Prisma.LigneReceptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneReceptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LigneReceptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneReceptionPayload>
          }
          findMany: {
            args: Prisma.LigneReceptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneReceptionPayload>[]
          }
          create: {
            args: Prisma.LigneReceptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneReceptionPayload>
          }
          createMany: {
            args: Prisma.LigneReceptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LigneReceptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneReceptionPayload>[]
          }
          delete: {
            args: Prisma.LigneReceptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneReceptionPayload>
          }
          update: {
            args: Prisma.LigneReceptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneReceptionPayload>
          }
          deleteMany: {
            args: Prisma.LigneReceptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LigneReceptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LigneReceptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneReceptionPayload>
          }
          aggregate: {
            args: Prisma.LigneReceptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLigneReception>
          }
          groupBy: {
            args: Prisma.LigneReceptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<LigneReceptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.LigneReceptionCountArgs<ExtArgs>
            result: $Utils.Optional<LigneReceptionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ArticleCountOutputType
   */

  export type ArticleCountOutputType = {
    mouvements: number
    lignesInventaire: number
    lignesReception: number
  }

  export type ArticleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mouvements?: boolean | ArticleCountOutputTypeCountMouvementsArgs
    lignesInventaire?: boolean | ArticleCountOutputTypeCountLignesInventaireArgs
    lignesReception?: boolean | ArticleCountOutputTypeCountLignesReceptionArgs
  }

  // Custom InputTypes
  /**
   * ArticleCountOutputType without action
   */
  export type ArticleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCountOutputType
     */
    select?: ArticleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ArticleCountOutputType without action
   */
  export type ArticleCountOutputTypeCountMouvementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MouvementStockWhereInput
  }

  /**
   * ArticleCountOutputType without action
   */
  export type ArticleCountOutputTypeCountLignesInventaireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LigneInventaireWhereInput
  }

  /**
   * ArticleCountOutputType without action
   */
  export type ArticleCountOutputTypeCountLignesReceptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LigneReceptionWhereInput
  }


  /**
   * Count Type InventaireCountOutputType
   */

  export type InventaireCountOutputType = {
    lignes: number
  }

  export type InventaireCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lignes?: boolean | InventaireCountOutputTypeCountLignesArgs
  }

  // Custom InputTypes
  /**
   * InventaireCountOutputType without action
   */
  export type InventaireCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventaireCountOutputType
     */
    select?: InventaireCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InventaireCountOutputType without action
   */
  export type InventaireCountOutputTypeCountLignesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LigneInventaireWhereInput
  }


  /**
   * Count Type EquipementCountOutputType
   */

  export type EquipementCountOutputType = {
    maintenances: number
  }

  export type EquipementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maintenances?: boolean | EquipementCountOutputTypeCountMaintenancesArgs
  }

  // Custom InputTypes
  /**
   * EquipementCountOutputType without action
   */
  export type EquipementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipementCountOutputType
     */
    select?: EquipementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EquipementCountOutputType without action
   */
  export type EquipementCountOutputTypeCountMaintenancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceEquipementWhereInput
  }


  /**
   * Count Type ReceptionCountOutputType
   */

  export type ReceptionCountOutputType = {
    lignes: number
  }

  export type ReceptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lignes?: boolean | ReceptionCountOutputTypeCountLignesArgs
  }

  // Custom InputTypes
  /**
   * ReceptionCountOutputType without action
   */
  export type ReceptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionCountOutputType
     */
    select?: ReceptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReceptionCountOutputType without action
   */
  export type ReceptionCountOutputTypeCountLignesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LigneReceptionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Article
   */

  export type AggregateArticle = {
    _count: ArticleCountAggregateOutputType | null
    _avg: ArticleAvgAggregateOutputType | null
    _sum: ArticleSumAggregateOutputType | null
    _min: ArticleMinAggregateOutputType | null
    _max: ArticleMaxAggregateOutputType | null
  }

  export type ArticleAvgAggregateOutputType = {
    prixAchat: number | null
    prixVente: number | null
    quantiteStock: number | null
    seuilAlerte: number | null
    seuilRupture: number | null
  }

  export type ArticleSumAggregateOutputType = {
    prixAchat: number | null
    prixVente: number | null
    quantiteStock: number | null
    seuilAlerte: number | null
    seuilRupture: number | null
  }

  export type ArticleMinAggregateOutputType = {
    id: string | null
    reference: string | null
    nom: string | null
    description: string | null
    categorie: string | null
    unite: $Enums.Unite | null
    prixAchat: number | null
    prixVente: number | null
    quantiteStock: number | null
    seuilAlerte: number | null
    seuilRupture: number | null
    emplacement: string | null
    fournisseurId: string | null
    status: $Enums.StatusArticle | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArticleMaxAggregateOutputType = {
    id: string | null
    reference: string | null
    nom: string | null
    description: string | null
    categorie: string | null
    unite: $Enums.Unite | null
    prixAchat: number | null
    prixVente: number | null
    quantiteStock: number | null
    seuilAlerte: number | null
    seuilRupture: number | null
    emplacement: string | null
    fournisseurId: string | null
    status: $Enums.StatusArticle | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArticleCountAggregateOutputType = {
    id: number
    reference: number
    nom: number
    description: number
    categorie: number
    unite: number
    prixAchat: number
    prixVente: number
    quantiteStock: number
    seuilAlerte: number
    seuilRupture: number
    emplacement: number
    fournisseurId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ArticleAvgAggregateInputType = {
    prixAchat?: true
    prixVente?: true
    quantiteStock?: true
    seuilAlerte?: true
    seuilRupture?: true
  }

  export type ArticleSumAggregateInputType = {
    prixAchat?: true
    prixVente?: true
    quantiteStock?: true
    seuilAlerte?: true
    seuilRupture?: true
  }

  export type ArticleMinAggregateInputType = {
    id?: true
    reference?: true
    nom?: true
    description?: true
    categorie?: true
    unite?: true
    prixAchat?: true
    prixVente?: true
    quantiteStock?: true
    seuilAlerte?: true
    seuilRupture?: true
    emplacement?: true
    fournisseurId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArticleMaxAggregateInputType = {
    id?: true
    reference?: true
    nom?: true
    description?: true
    categorie?: true
    unite?: true
    prixAchat?: true
    prixVente?: true
    quantiteStock?: true
    seuilAlerte?: true
    seuilRupture?: true
    emplacement?: true
    fournisseurId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArticleCountAggregateInputType = {
    id?: true
    reference?: true
    nom?: true
    description?: true
    categorie?: true
    unite?: true
    prixAchat?: true
    prixVente?: true
    quantiteStock?: true
    seuilAlerte?: true
    seuilRupture?: true
    emplacement?: true
    fournisseurId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ArticleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Article to aggregate.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Articles
    **/
    _count?: true | ArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArticleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArticleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArticleMaxAggregateInputType
  }

  export type GetArticleAggregateType<T extends ArticleAggregateArgs> = {
        [P in keyof T & keyof AggregateArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticle[P]>
      : GetScalarType<T[P], AggregateArticle[P]>
  }




  export type ArticleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArticleWhereInput
    orderBy?: ArticleOrderByWithAggregationInput | ArticleOrderByWithAggregationInput[]
    by: ArticleScalarFieldEnum[] | ArticleScalarFieldEnum
    having?: ArticleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticleCountAggregateInputType | true
    _avg?: ArticleAvgAggregateInputType
    _sum?: ArticleSumAggregateInputType
    _min?: ArticleMinAggregateInputType
    _max?: ArticleMaxAggregateInputType
  }

  export type ArticleGroupByOutputType = {
    id: string
    reference: string
    nom: string
    description: string | null
    categorie: string
    unite: $Enums.Unite
    prixAchat: number
    prixVente: number
    quantiteStock: number
    seuilAlerte: number
    seuilRupture: number
    emplacement: string | null
    fournisseurId: string | null
    status: $Enums.StatusArticle
    createdAt: Date
    updatedAt: Date
    _count: ArticleCountAggregateOutputType | null
    _avg: ArticleAvgAggregateOutputType | null
    _sum: ArticleSumAggregateOutputType | null
    _min: ArticleMinAggregateOutputType | null
    _max: ArticleMaxAggregateOutputType | null
  }

  type GetArticleGroupByPayload<T extends ArticleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArticleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArticleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArticleGroupByOutputType[P]>
            : GetScalarType<T[P], ArticleGroupByOutputType[P]>
        }
      >
    >


  export type ArticleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reference?: boolean
    nom?: boolean
    description?: boolean
    categorie?: boolean
    unite?: boolean
    prixAchat?: boolean
    prixVente?: boolean
    quantiteStock?: boolean
    seuilAlerte?: boolean
    seuilRupture?: boolean
    emplacement?: boolean
    fournisseurId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mouvements?: boolean | Article$mouvementsArgs<ExtArgs>
    lignesInventaire?: boolean | Article$lignesInventaireArgs<ExtArgs>
    lignesReception?: boolean | Article$lignesReceptionArgs<ExtArgs>
    _count?: boolean | ArticleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["article"]>

  export type ArticleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reference?: boolean
    nom?: boolean
    description?: boolean
    categorie?: boolean
    unite?: boolean
    prixAchat?: boolean
    prixVente?: boolean
    quantiteStock?: boolean
    seuilAlerte?: boolean
    seuilRupture?: boolean
    emplacement?: boolean
    fournisseurId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["article"]>

  export type ArticleSelectScalar = {
    id?: boolean
    reference?: boolean
    nom?: boolean
    description?: boolean
    categorie?: boolean
    unite?: boolean
    prixAchat?: boolean
    prixVente?: boolean
    quantiteStock?: boolean
    seuilAlerte?: boolean
    seuilRupture?: boolean
    emplacement?: boolean
    fournisseurId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ArticleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mouvements?: boolean | Article$mouvementsArgs<ExtArgs>
    lignesInventaire?: boolean | Article$lignesInventaireArgs<ExtArgs>
    lignesReception?: boolean | Article$lignesReceptionArgs<ExtArgs>
    _count?: boolean | ArticleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ArticleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ArticlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Article"
    objects: {
      mouvements: Prisma.$MouvementStockPayload<ExtArgs>[]
      lignesInventaire: Prisma.$LigneInventairePayload<ExtArgs>[]
      lignesReception: Prisma.$LigneReceptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reference: string
      nom: string
      description: string | null
      categorie: string
      unite: $Enums.Unite
      prixAchat: number
      prixVente: number
      quantiteStock: number
      seuilAlerte: number
      seuilRupture: number
      emplacement: string | null
      fournisseurId: string | null
      status: $Enums.StatusArticle
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["article"]>
    composites: {}
  }

  type ArticleGetPayload<S extends boolean | null | undefined | ArticleDefaultArgs> = $Result.GetResult<Prisma.$ArticlePayload, S>

  type ArticleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ArticleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ArticleCountAggregateInputType | true
    }

  export interface ArticleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Article'], meta: { name: 'Article' } }
    /**
     * Find zero or one Article that matches the filter.
     * @param {ArticleFindUniqueArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArticleFindUniqueArgs>(args: SelectSubset<T, ArticleFindUniqueArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Article that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ArticleFindUniqueOrThrowArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArticleFindUniqueOrThrowArgs>(args: SelectSubset<T, ArticleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Article that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindFirstArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArticleFindFirstArgs>(args?: SelectSubset<T, ArticleFindFirstArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Article that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindFirstOrThrowArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArticleFindFirstOrThrowArgs>(args?: SelectSubset<T, ArticleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Articles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Articles
     * const articles = await prisma.article.findMany()
     * 
     * // Get first 10 Articles
     * const articles = await prisma.article.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const articleWithIdOnly = await prisma.article.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ArticleFindManyArgs>(args?: SelectSubset<T, ArticleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Article.
     * @param {ArticleCreateArgs} args - Arguments to create a Article.
     * @example
     * // Create one Article
     * const Article = await prisma.article.create({
     *   data: {
     *     // ... data to create a Article
     *   }
     * })
     * 
     */
    create<T extends ArticleCreateArgs>(args: SelectSubset<T, ArticleCreateArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Articles.
     * @param {ArticleCreateManyArgs} args - Arguments to create many Articles.
     * @example
     * // Create many Articles
     * const article = await prisma.article.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArticleCreateManyArgs>(args?: SelectSubset<T, ArticleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Articles and returns the data saved in the database.
     * @param {ArticleCreateManyAndReturnArgs} args - Arguments to create many Articles.
     * @example
     * // Create many Articles
     * const article = await prisma.article.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Articles and only return the `id`
     * const articleWithIdOnly = await prisma.article.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArticleCreateManyAndReturnArgs>(args?: SelectSubset<T, ArticleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Article.
     * @param {ArticleDeleteArgs} args - Arguments to delete one Article.
     * @example
     * // Delete one Article
     * const Article = await prisma.article.delete({
     *   where: {
     *     // ... filter to delete one Article
     *   }
     * })
     * 
     */
    delete<T extends ArticleDeleteArgs>(args: SelectSubset<T, ArticleDeleteArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Article.
     * @param {ArticleUpdateArgs} args - Arguments to update one Article.
     * @example
     * // Update one Article
     * const article = await prisma.article.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArticleUpdateArgs>(args: SelectSubset<T, ArticleUpdateArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Articles.
     * @param {ArticleDeleteManyArgs} args - Arguments to filter Articles to delete.
     * @example
     * // Delete a few Articles
     * const { count } = await prisma.article.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArticleDeleteManyArgs>(args?: SelectSubset<T, ArticleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Articles
     * const article = await prisma.article.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArticleUpdateManyArgs>(args: SelectSubset<T, ArticleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Article.
     * @param {ArticleUpsertArgs} args - Arguments to update or create a Article.
     * @example
     * // Update or create a Article
     * const article = await prisma.article.upsert({
     *   create: {
     *     // ... data to create a Article
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Article we want to update
     *   }
     * })
     */
    upsert<T extends ArticleUpsertArgs>(args: SelectSubset<T, ArticleUpsertArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCountArgs} args - Arguments to filter Articles to count.
     * @example
     * // Count the number of Articles
     * const count = await prisma.article.count({
     *   where: {
     *     // ... the filter for the Articles we want to count
     *   }
     * })
    **/
    count<T extends ArticleCountArgs>(
      args?: Subset<T, ArticleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Article.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArticleAggregateArgs>(args: Subset<T, ArticleAggregateArgs>): Prisma.PrismaPromise<GetArticleAggregateType<T>>

    /**
     * Group by Article.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArticleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArticleGroupByArgs['orderBy'] }
        : { orderBy?: ArticleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArticleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Article model
   */
  readonly fields: ArticleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Article.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArticleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mouvements<T extends Article$mouvementsArgs<ExtArgs> = {}>(args?: Subset<T, Article$mouvementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MouvementStockPayload<ExtArgs>, T, "findMany"> | Null>
    lignesInventaire<T extends Article$lignesInventaireArgs<ExtArgs> = {}>(args?: Subset<T, Article$lignesInventaireArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneInventairePayload<ExtArgs>, T, "findMany"> | Null>
    lignesReception<T extends Article$lignesReceptionArgs<ExtArgs> = {}>(args?: Subset<T, Article$lignesReceptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneReceptionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Article model
   */ 
  interface ArticleFieldRefs {
    readonly id: FieldRef<"Article", 'String'>
    readonly reference: FieldRef<"Article", 'String'>
    readonly nom: FieldRef<"Article", 'String'>
    readonly description: FieldRef<"Article", 'String'>
    readonly categorie: FieldRef<"Article", 'String'>
    readonly unite: FieldRef<"Article", 'Unite'>
    readonly prixAchat: FieldRef<"Article", 'Float'>
    readonly prixVente: FieldRef<"Article", 'Float'>
    readonly quantiteStock: FieldRef<"Article", 'Float'>
    readonly seuilAlerte: FieldRef<"Article", 'Float'>
    readonly seuilRupture: FieldRef<"Article", 'Float'>
    readonly emplacement: FieldRef<"Article", 'String'>
    readonly fournisseurId: FieldRef<"Article", 'String'>
    readonly status: FieldRef<"Article", 'StatusArticle'>
    readonly createdAt: FieldRef<"Article", 'DateTime'>
    readonly updatedAt: FieldRef<"Article", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Article findUnique
   */
  export type ArticleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where: ArticleWhereUniqueInput
  }

  /**
   * Article findUniqueOrThrow
   */
  export type ArticleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where: ArticleWhereUniqueInput
  }

  /**
   * Article findFirst
   */
  export type ArticleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Articles.
     */
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }

  /**
   * Article findFirstOrThrow
   */
  export type ArticleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Articles.
     */
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }

  /**
   * Article findMany
   */
  export type ArticleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Articles to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }

  /**
   * Article create
   */
  export type ArticleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * The data needed to create a Article.
     */
    data: XOR<ArticleCreateInput, ArticleUncheckedCreateInput>
  }

  /**
   * Article createMany
   */
  export type ArticleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Articles.
     */
    data: ArticleCreateManyInput | ArticleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Article createManyAndReturn
   */
  export type ArticleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Articles.
     */
    data: ArticleCreateManyInput | ArticleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Article update
   */
  export type ArticleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * The data needed to update a Article.
     */
    data: XOR<ArticleUpdateInput, ArticleUncheckedUpdateInput>
    /**
     * Choose, which Article to update.
     */
    where: ArticleWhereUniqueInput
  }

  /**
   * Article updateMany
   */
  export type ArticleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Articles.
     */
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyInput>
    /**
     * Filter which Articles to update
     */
    where?: ArticleWhereInput
  }

  /**
   * Article upsert
   */
  export type ArticleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * The filter to search for the Article to update in case it exists.
     */
    where: ArticleWhereUniqueInput
    /**
     * In case the Article found by the `where` argument doesn't exist, create a new Article with this data.
     */
    create: XOR<ArticleCreateInput, ArticleUncheckedCreateInput>
    /**
     * In case the Article was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArticleUpdateInput, ArticleUncheckedUpdateInput>
  }

  /**
   * Article delete
   */
  export type ArticleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter which Article to delete.
     */
    where: ArticleWhereUniqueInput
  }

  /**
   * Article deleteMany
   */
  export type ArticleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Articles to delete
     */
    where?: ArticleWhereInput
  }

  /**
   * Article.mouvements
   */
  export type Article$mouvementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementStock
     */
    select?: MouvementStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementStockInclude<ExtArgs> | null
    where?: MouvementStockWhereInput
    orderBy?: MouvementStockOrderByWithRelationInput | MouvementStockOrderByWithRelationInput[]
    cursor?: MouvementStockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MouvementStockScalarFieldEnum | MouvementStockScalarFieldEnum[]
  }

  /**
   * Article.lignesInventaire
   */
  export type Article$lignesInventaireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneInventaire
     */
    select?: LigneInventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneInventaireInclude<ExtArgs> | null
    where?: LigneInventaireWhereInput
    orderBy?: LigneInventaireOrderByWithRelationInput | LigneInventaireOrderByWithRelationInput[]
    cursor?: LigneInventaireWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LigneInventaireScalarFieldEnum | LigneInventaireScalarFieldEnum[]
  }

  /**
   * Article.lignesReception
   */
  export type Article$lignesReceptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneReception
     */
    select?: LigneReceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneReceptionInclude<ExtArgs> | null
    where?: LigneReceptionWhereInput
    orderBy?: LigneReceptionOrderByWithRelationInput | LigneReceptionOrderByWithRelationInput[]
    cursor?: LigneReceptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LigneReceptionScalarFieldEnum | LigneReceptionScalarFieldEnum[]
  }

  /**
   * Article without action
   */
  export type ArticleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
  }


  /**
   * Model MouvementStock
   */

  export type AggregateMouvementStock = {
    _count: MouvementStockCountAggregateOutputType | null
    _avg: MouvementStockAvgAggregateOutputType | null
    _sum: MouvementStockSumAggregateOutputType | null
    _min: MouvementStockMinAggregateOutputType | null
    _max: MouvementStockMaxAggregateOutputType | null
  }

  export type MouvementStockAvgAggregateOutputType = {
    quantite: number | null
  }

  export type MouvementStockSumAggregateOutputType = {
    quantite: number | null
  }

  export type MouvementStockMinAggregateOutputType = {
    id: string | null
    articleId: string | null
    type: $Enums.TypeMouvement | null
    quantite: number | null
    dateOperation: Date | null
    utilisateurId: string | null
    numeroDocument: string | null
    emplacement: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type MouvementStockMaxAggregateOutputType = {
    id: string | null
    articleId: string | null
    type: $Enums.TypeMouvement | null
    quantite: number | null
    dateOperation: Date | null
    utilisateurId: string | null
    numeroDocument: string | null
    emplacement: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type MouvementStockCountAggregateOutputType = {
    id: number
    articleId: number
    type: number
    quantite: number
    dateOperation: number
    utilisateurId: number
    numeroDocument: number
    emplacement: number
    notes: number
    createdAt: number
    _all: number
  }


  export type MouvementStockAvgAggregateInputType = {
    quantite?: true
  }

  export type MouvementStockSumAggregateInputType = {
    quantite?: true
  }

  export type MouvementStockMinAggregateInputType = {
    id?: true
    articleId?: true
    type?: true
    quantite?: true
    dateOperation?: true
    utilisateurId?: true
    numeroDocument?: true
    emplacement?: true
    notes?: true
    createdAt?: true
  }

  export type MouvementStockMaxAggregateInputType = {
    id?: true
    articleId?: true
    type?: true
    quantite?: true
    dateOperation?: true
    utilisateurId?: true
    numeroDocument?: true
    emplacement?: true
    notes?: true
    createdAt?: true
  }

  export type MouvementStockCountAggregateInputType = {
    id?: true
    articleId?: true
    type?: true
    quantite?: true
    dateOperation?: true
    utilisateurId?: true
    numeroDocument?: true
    emplacement?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type MouvementStockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MouvementStock to aggregate.
     */
    where?: MouvementStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MouvementStocks to fetch.
     */
    orderBy?: MouvementStockOrderByWithRelationInput | MouvementStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MouvementStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MouvementStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MouvementStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MouvementStocks
    **/
    _count?: true | MouvementStockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MouvementStockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MouvementStockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MouvementStockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MouvementStockMaxAggregateInputType
  }

  export type GetMouvementStockAggregateType<T extends MouvementStockAggregateArgs> = {
        [P in keyof T & keyof AggregateMouvementStock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMouvementStock[P]>
      : GetScalarType<T[P], AggregateMouvementStock[P]>
  }




  export type MouvementStockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MouvementStockWhereInput
    orderBy?: MouvementStockOrderByWithAggregationInput | MouvementStockOrderByWithAggregationInput[]
    by: MouvementStockScalarFieldEnum[] | MouvementStockScalarFieldEnum
    having?: MouvementStockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MouvementStockCountAggregateInputType | true
    _avg?: MouvementStockAvgAggregateInputType
    _sum?: MouvementStockSumAggregateInputType
    _min?: MouvementStockMinAggregateInputType
    _max?: MouvementStockMaxAggregateInputType
  }

  export type MouvementStockGroupByOutputType = {
    id: string
    articleId: string
    type: $Enums.TypeMouvement
    quantite: number
    dateOperation: Date
    utilisateurId: string
    numeroDocument: string | null
    emplacement: string | null
    notes: string | null
    createdAt: Date
    _count: MouvementStockCountAggregateOutputType | null
    _avg: MouvementStockAvgAggregateOutputType | null
    _sum: MouvementStockSumAggregateOutputType | null
    _min: MouvementStockMinAggregateOutputType | null
    _max: MouvementStockMaxAggregateOutputType | null
  }

  type GetMouvementStockGroupByPayload<T extends MouvementStockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MouvementStockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MouvementStockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MouvementStockGroupByOutputType[P]>
            : GetScalarType<T[P], MouvementStockGroupByOutputType[P]>
        }
      >
    >


  export type MouvementStockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    articleId?: boolean
    type?: boolean
    quantite?: boolean
    dateOperation?: boolean
    utilisateurId?: boolean
    numeroDocument?: boolean
    emplacement?: boolean
    notes?: boolean
    createdAt?: boolean
    article?: boolean | ArticleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mouvementStock"]>

  export type MouvementStockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    articleId?: boolean
    type?: boolean
    quantite?: boolean
    dateOperation?: boolean
    utilisateurId?: boolean
    numeroDocument?: boolean
    emplacement?: boolean
    notes?: boolean
    createdAt?: boolean
    article?: boolean | ArticleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mouvementStock"]>

  export type MouvementStockSelectScalar = {
    id?: boolean
    articleId?: boolean
    type?: boolean
    quantite?: boolean
    dateOperation?: boolean
    utilisateurId?: boolean
    numeroDocument?: boolean
    emplacement?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type MouvementStockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | ArticleDefaultArgs<ExtArgs>
  }
  export type MouvementStockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | ArticleDefaultArgs<ExtArgs>
  }

  export type $MouvementStockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MouvementStock"
    objects: {
      article: Prisma.$ArticlePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      articleId: string
      type: $Enums.TypeMouvement
      quantite: number
      dateOperation: Date
      utilisateurId: string
      numeroDocument: string | null
      emplacement: string | null
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["mouvementStock"]>
    composites: {}
  }

  type MouvementStockGetPayload<S extends boolean | null | undefined | MouvementStockDefaultArgs> = $Result.GetResult<Prisma.$MouvementStockPayload, S>

  type MouvementStockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MouvementStockFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MouvementStockCountAggregateInputType | true
    }

  export interface MouvementStockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MouvementStock'], meta: { name: 'MouvementStock' } }
    /**
     * Find zero or one MouvementStock that matches the filter.
     * @param {MouvementStockFindUniqueArgs} args - Arguments to find a MouvementStock
     * @example
     * // Get one MouvementStock
     * const mouvementStock = await prisma.mouvementStock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MouvementStockFindUniqueArgs>(args: SelectSubset<T, MouvementStockFindUniqueArgs<ExtArgs>>): Prisma__MouvementStockClient<$Result.GetResult<Prisma.$MouvementStockPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MouvementStock that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MouvementStockFindUniqueOrThrowArgs} args - Arguments to find a MouvementStock
     * @example
     * // Get one MouvementStock
     * const mouvementStock = await prisma.mouvementStock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MouvementStockFindUniqueOrThrowArgs>(args: SelectSubset<T, MouvementStockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MouvementStockClient<$Result.GetResult<Prisma.$MouvementStockPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MouvementStock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementStockFindFirstArgs} args - Arguments to find a MouvementStock
     * @example
     * // Get one MouvementStock
     * const mouvementStock = await prisma.mouvementStock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MouvementStockFindFirstArgs>(args?: SelectSubset<T, MouvementStockFindFirstArgs<ExtArgs>>): Prisma__MouvementStockClient<$Result.GetResult<Prisma.$MouvementStockPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MouvementStock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementStockFindFirstOrThrowArgs} args - Arguments to find a MouvementStock
     * @example
     * // Get one MouvementStock
     * const mouvementStock = await prisma.mouvementStock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MouvementStockFindFirstOrThrowArgs>(args?: SelectSubset<T, MouvementStockFindFirstOrThrowArgs<ExtArgs>>): Prisma__MouvementStockClient<$Result.GetResult<Prisma.$MouvementStockPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MouvementStocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementStockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MouvementStocks
     * const mouvementStocks = await prisma.mouvementStock.findMany()
     * 
     * // Get first 10 MouvementStocks
     * const mouvementStocks = await prisma.mouvementStock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mouvementStockWithIdOnly = await prisma.mouvementStock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MouvementStockFindManyArgs>(args?: SelectSubset<T, MouvementStockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MouvementStockPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MouvementStock.
     * @param {MouvementStockCreateArgs} args - Arguments to create a MouvementStock.
     * @example
     * // Create one MouvementStock
     * const MouvementStock = await prisma.mouvementStock.create({
     *   data: {
     *     // ... data to create a MouvementStock
     *   }
     * })
     * 
     */
    create<T extends MouvementStockCreateArgs>(args: SelectSubset<T, MouvementStockCreateArgs<ExtArgs>>): Prisma__MouvementStockClient<$Result.GetResult<Prisma.$MouvementStockPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MouvementStocks.
     * @param {MouvementStockCreateManyArgs} args - Arguments to create many MouvementStocks.
     * @example
     * // Create many MouvementStocks
     * const mouvementStock = await prisma.mouvementStock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MouvementStockCreateManyArgs>(args?: SelectSubset<T, MouvementStockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MouvementStocks and returns the data saved in the database.
     * @param {MouvementStockCreateManyAndReturnArgs} args - Arguments to create many MouvementStocks.
     * @example
     * // Create many MouvementStocks
     * const mouvementStock = await prisma.mouvementStock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MouvementStocks and only return the `id`
     * const mouvementStockWithIdOnly = await prisma.mouvementStock.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MouvementStockCreateManyAndReturnArgs>(args?: SelectSubset<T, MouvementStockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MouvementStockPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MouvementStock.
     * @param {MouvementStockDeleteArgs} args - Arguments to delete one MouvementStock.
     * @example
     * // Delete one MouvementStock
     * const MouvementStock = await prisma.mouvementStock.delete({
     *   where: {
     *     // ... filter to delete one MouvementStock
     *   }
     * })
     * 
     */
    delete<T extends MouvementStockDeleteArgs>(args: SelectSubset<T, MouvementStockDeleteArgs<ExtArgs>>): Prisma__MouvementStockClient<$Result.GetResult<Prisma.$MouvementStockPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MouvementStock.
     * @param {MouvementStockUpdateArgs} args - Arguments to update one MouvementStock.
     * @example
     * // Update one MouvementStock
     * const mouvementStock = await prisma.mouvementStock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MouvementStockUpdateArgs>(args: SelectSubset<T, MouvementStockUpdateArgs<ExtArgs>>): Prisma__MouvementStockClient<$Result.GetResult<Prisma.$MouvementStockPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MouvementStocks.
     * @param {MouvementStockDeleteManyArgs} args - Arguments to filter MouvementStocks to delete.
     * @example
     * // Delete a few MouvementStocks
     * const { count } = await prisma.mouvementStock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MouvementStockDeleteManyArgs>(args?: SelectSubset<T, MouvementStockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MouvementStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementStockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MouvementStocks
     * const mouvementStock = await prisma.mouvementStock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MouvementStockUpdateManyArgs>(args: SelectSubset<T, MouvementStockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MouvementStock.
     * @param {MouvementStockUpsertArgs} args - Arguments to update or create a MouvementStock.
     * @example
     * // Update or create a MouvementStock
     * const mouvementStock = await prisma.mouvementStock.upsert({
     *   create: {
     *     // ... data to create a MouvementStock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MouvementStock we want to update
     *   }
     * })
     */
    upsert<T extends MouvementStockUpsertArgs>(args: SelectSubset<T, MouvementStockUpsertArgs<ExtArgs>>): Prisma__MouvementStockClient<$Result.GetResult<Prisma.$MouvementStockPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MouvementStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementStockCountArgs} args - Arguments to filter MouvementStocks to count.
     * @example
     * // Count the number of MouvementStocks
     * const count = await prisma.mouvementStock.count({
     *   where: {
     *     // ... the filter for the MouvementStocks we want to count
     *   }
     * })
    **/
    count<T extends MouvementStockCountArgs>(
      args?: Subset<T, MouvementStockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MouvementStockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MouvementStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementStockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MouvementStockAggregateArgs>(args: Subset<T, MouvementStockAggregateArgs>): Prisma.PrismaPromise<GetMouvementStockAggregateType<T>>

    /**
     * Group by MouvementStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementStockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MouvementStockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MouvementStockGroupByArgs['orderBy'] }
        : { orderBy?: MouvementStockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MouvementStockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMouvementStockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MouvementStock model
   */
  readonly fields: MouvementStockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MouvementStock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MouvementStockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    article<T extends ArticleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArticleDefaultArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MouvementStock model
   */ 
  interface MouvementStockFieldRefs {
    readonly id: FieldRef<"MouvementStock", 'String'>
    readonly articleId: FieldRef<"MouvementStock", 'String'>
    readonly type: FieldRef<"MouvementStock", 'TypeMouvement'>
    readonly quantite: FieldRef<"MouvementStock", 'Float'>
    readonly dateOperation: FieldRef<"MouvementStock", 'DateTime'>
    readonly utilisateurId: FieldRef<"MouvementStock", 'String'>
    readonly numeroDocument: FieldRef<"MouvementStock", 'String'>
    readonly emplacement: FieldRef<"MouvementStock", 'String'>
    readonly notes: FieldRef<"MouvementStock", 'String'>
    readonly createdAt: FieldRef<"MouvementStock", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MouvementStock findUnique
   */
  export type MouvementStockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementStock
     */
    select?: MouvementStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementStockInclude<ExtArgs> | null
    /**
     * Filter, which MouvementStock to fetch.
     */
    where: MouvementStockWhereUniqueInput
  }

  /**
   * MouvementStock findUniqueOrThrow
   */
  export type MouvementStockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementStock
     */
    select?: MouvementStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementStockInclude<ExtArgs> | null
    /**
     * Filter, which MouvementStock to fetch.
     */
    where: MouvementStockWhereUniqueInput
  }

  /**
   * MouvementStock findFirst
   */
  export type MouvementStockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementStock
     */
    select?: MouvementStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementStockInclude<ExtArgs> | null
    /**
     * Filter, which MouvementStock to fetch.
     */
    where?: MouvementStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MouvementStocks to fetch.
     */
    orderBy?: MouvementStockOrderByWithRelationInput | MouvementStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MouvementStocks.
     */
    cursor?: MouvementStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MouvementStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MouvementStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MouvementStocks.
     */
    distinct?: MouvementStockScalarFieldEnum | MouvementStockScalarFieldEnum[]
  }

  /**
   * MouvementStock findFirstOrThrow
   */
  export type MouvementStockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementStock
     */
    select?: MouvementStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementStockInclude<ExtArgs> | null
    /**
     * Filter, which MouvementStock to fetch.
     */
    where?: MouvementStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MouvementStocks to fetch.
     */
    orderBy?: MouvementStockOrderByWithRelationInput | MouvementStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MouvementStocks.
     */
    cursor?: MouvementStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MouvementStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MouvementStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MouvementStocks.
     */
    distinct?: MouvementStockScalarFieldEnum | MouvementStockScalarFieldEnum[]
  }

  /**
   * MouvementStock findMany
   */
  export type MouvementStockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementStock
     */
    select?: MouvementStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementStockInclude<ExtArgs> | null
    /**
     * Filter, which MouvementStocks to fetch.
     */
    where?: MouvementStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MouvementStocks to fetch.
     */
    orderBy?: MouvementStockOrderByWithRelationInput | MouvementStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MouvementStocks.
     */
    cursor?: MouvementStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MouvementStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MouvementStocks.
     */
    skip?: number
    distinct?: MouvementStockScalarFieldEnum | MouvementStockScalarFieldEnum[]
  }

  /**
   * MouvementStock create
   */
  export type MouvementStockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementStock
     */
    select?: MouvementStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementStockInclude<ExtArgs> | null
    /**
     * The data needed to create a MouvementStock.
     */
    data: XOR<MouvementStockCreateInput, MouvementStockUncheckedCreateInput>
  }

  /**
   * MouvementStock createMany
   */
  export type MouvementStockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MouvementStocks.
     */
    data: MouvementStockCreateManyInput | MouvementStockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MouvementStock createManyAndReturn
   */
  export type MouvementStockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementStock
     */
    select?: MouvementStockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MouvementStocks.
     */
    data: MouvementStockCreateManyInput | MouvementStockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementStockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MouvementStock update
   */
  export type MouvementStockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementStock
     */
    select?: MouvementStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementStockInclude<ExtArgs> | null
    /**
     * The data needed to update a MouvementStock.
     */
    data: XOR<MouvementStockUpdateInput, MouvementStockUncheckedUpdateInput>
    /**
     * Choose, which MouvementStock to update.
     */
    where: MouvementStockWhereUniqueInput
  }

  /**
   * MouvementStock updateMany
   */
  export type MouvementStockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MouvementStocks.
     */
    data: XOR<MouvementStockUpdateManyMutationInput, MouvementStockUncheckedUpdateManyInput>
    /**
     * Filter which MouvementStocks to update
     */
    where?: MouvementStockWhereInput
  }

  /**
   * MouvementStock upsert
   */
  export type MouvementStockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementStock
     */
    select?: MouvementStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementStockInclude<ExtArgs> | null
    /**
     * The filter to search for the MouvementStock to update in case it exists.
     */
    where: MouvementStockWhereUniqueInput
    /**
     * In case the MouvementStock found by the `where` argument doesn't exist, create a new MouvementStock with this data.
     */
    create: XOR<MouvementStockCreateInput, MouvementStockUncheckedCreateInput>
    /**
     * In case the MouvementStock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MouvementStockUpdateInput, MouvementStockUncheckedUpdateInput>
  }

  /**
   * MouvementStock delete
   */
  export type MouvementStockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementStock
     */
    select?: MouvementStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementStockInclude<ExtArgs> | null
    /**
     * Filter which MouvementStock to delete.
     */
    where: MouvementStockWhereUniqueInput
  }

  /**
   * MouvementStock deleteMany
   */
  export type MouvementStockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MouvementStocks to delete
     */
    where?: MouvementStockWhereInput
  }

  /**
   * MouvementStock without action
   */
  export type MouvementStockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementStock
     */
    select?: MouvementStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementStockInclude<ExtArgs> | null
  }


  /**
   * Model Inventaire
   */

  export type AggregateInventaire = {
    _count: InventaireCountAggregateOutputType | null
    _avg: InventaireAvgAggregateOutputType | null
    _sum: InventaireSumAggregateOutputType | null
    _min: InventaireMinAggregateOutputType | null
    _max: InventaireMaxAggregateOutputType | null
  }

  export type InventaireAvgAggregateOutputType = {
    nbArticles: number | null
    nbEcarts: number | null
    montantEcart: number | null
  }

  export type InventaireSumAggregateOutputType = {
    nbArticles: number | null
    nbEcarts: number | null
    montantEcart: number | null
  }

  export type InventaireMinAggregateOutputType = {
    id: string | null
    numeroInventaire: string | null
    dateDebut: Date | null
    dateFin: Date | null
    status: $Enums.StatusInventaire | null
    nbArticles: number | null
    nbEcarts: number | null
    montantEcart: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventaireMaxAggregateOutputType = {
    id: string | null
    numeroInventaire: string | null
    dateDebut: Date | null
    dateFin: Date | null
    status: $Enums.StatusInventaire | null
    nbArticles: number | null
    nbEcarts: number | null
    montantEcart: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventaireCountAggregateOutputType = {
    id: number
    numeroInventaire: number
    dateDebut: number
    dateFin: number
    status: number
    nbArticles: number
    nbEcarts: number
    montantEcart: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InventaireAvgAggregateInputType = {
    nbArticles?: true
    nbEcarts?: true
    montantEcart?: true
  }

  export type InventaireSumAggregateInputType = {
    nbArticles?: true
    nbEcarts?: true
    montantEcart?: true
  }

  export type InventaireMinAggregateInputType = {
    id?: true
    numeroInventaire?: true
    dateDebut?: true
    dateFin?: true
    status?: true
    nbArticles?: true
    nbEcarts?: true
    montantEcart?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventaireMaxAggregateInputType = {
    id?: true
    numeroInventaire?: true
    dateDebut?: true
    dateFin?: true
    status?: true
    nbArticles?: true
    nbEcarts?: true
    montantEcart?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventaireCountAggregateInputType = {
    id?: true
    numeroInventaire?: true
    dateDebut?: true
    dateFin?: true
    status?: true
    nbArticles?: true
    nbEcarts?: true
    montantEcart?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InventaireAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventaire to aggregate.
     */
    where?: InventaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventaires to fetch.
     */
    orderBy?: InventaireOrderByWithRelationInput | InventaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inventaires
    **/
    _count?: true | InventaireCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventaireAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventaireSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventaireMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventaireMaxAggregateInputType
  }

  export type GetInventaireAggregateType<T extends InventaireAggregateArgs> = {
        [P in keyof T & keyof AggregateInventaire]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventaire[P]>
      : GetScalarType<T[P], AggregateInventaire[P]>
  }




  export type InventaireGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventaireWhereInput
    orderBy?: InventaireOrderByWithAggregationInput | InventaireOrderByWithAggregationInput[]
    by: InventaireScalarFieldEnum[] | InventaireScalarFieldEnum
    having?: InventaireScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventaireCountAggregateInputType | true
    _avg?: InventaireAvgAggregateInputType
    _sum?: InventaireSumAggregateInputType
    _min?: InventaireMinAggregateInputType
    _max?: InventaireMaxAggregateInputType
  }

  export type InventaireGroupByOutputType = {
    id: string
    numeroInventaire: string
    dateDebut: Date
    dateFin: Date | null
    status: $Enums.StatusInventaire
    nbArticles: number
    nbEcarts: number
    montantEcart: number
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: InventaireCountAggregateOutputType | null
    _avg: InventaireAvgAggregateOutputType | null
    _sum: InventaireSumAggregateOutputType | null
    _min: InventaireMinAggregateOutputType | null
    _max: InventaireMaxAggregateOutputType | null
  }

  type GetInventaireGroupByPayload<T extends InventaireGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventaireGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventaireGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventaireGroupByOutputType[P]>
            : GetScalarType<T[P], InventaireGroupByOutputType[P]>
        }
      >
    >


  export type InventaireSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numeroInventaire?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    status?: boolean
    nbArticles?: boolean
    nbEcarts?: boolean
    montantEcart?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lignes?: boolean | Inventaire$lignesArgs<ExtArgs>
    _count?: boolean | InventaireCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventaire"]>

  export type InventaireSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numeroInventaire?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    status?: boolean
    nbArticles?: boolean
    nbEcarts?: boolean
    montantEcart?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["inventaire"]>

  export type InventaireSelectScalar = {
    id?: boolean
    numeroInventaire?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    status?: boolean
    nbArticles?: boolean
    nbEcarts?: boolean
    montantEcart?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InventaireInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lignes?: boolean | Inventaire$lignesArgs<ExtArgs>
    _count?: boolean | InventaireCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InventaireIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InventairePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inventaire"
    objects: {
      lignes: Prisma.$LigneInventairePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      numeroInventaire: string
      dateDebut: Date
      dateFin: Date | null
      status: $Enums.StatusInventaire
      nbArticles: number
      nbEcarts: number
      montantEcart: number
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inventaire"]>
    composites: {}
  }

  type InventaireGetPayload<S extends boolean | null | undefined | InventaireDefaultArgs> = $Result.GetResult<Prisma.$InventairePayload, S>

  type InventaireCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InventaireFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InventaireCountAggregateInputType | true
    }

  export interface InventaireDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inventaire'], meta: { name: 'Inventaire' } }
    /**
     * Find zero or one Inventaire that matches the filter.
     * @param {InventaireFindUniqueArgs} args - Arguments to find a Inventaire
     * @example
     * // Get one Inventaire
     * const inventaire = await prisma.inventaire.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventaireFindUniqueArgs>(args: SelectSubset<T, InventaireFindUniqueArgs<ExtArgs>>): Prisma__InventaireClient<$Result.GetResult<Prisma.$InventairePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Inventaire that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InventaireFindUniqueOrThrowArgs} args - Arguments to find a Inventaire
     * @example
     * // Get one Inventaire
     * const inventaire = await prisma.inventaire.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventaireFindUniqueOrThrowArgs>(args: SelectSubset<T, InventaireFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventaireClient<$Result.GetResult<Prisma.$InventairePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Inventaire that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventaireFindFirstArgs} args - Arguments to find a Inventaire
     * @example
     * // Get one Inventaire
     * const inventaire = await prisma.inventaire.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventaireFindFirstArgs>(args?: SelectSubset<T, InventaireFindFirstArgs<ExtArgs>>): Prisma__InventaireClient<$Result.GetResult<Prisma.$InventairePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Inventaire that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventaireFindFirstOrThrowArgs} args - Arguments to find a Inventaire
     * @example
     * // Get one Inventaire
     * const inventaire = await prisma.inventaire.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventaireFindFirstOrThrowArgs>(args?: SelectSubset<T, InventaireFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventaireClient<$Result.GetResult<Prisma.$InventairePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Inventaires that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventaireFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventaires
     * const inventaires = await prisma.inventaire.findMany()
     * 
     * // Get first 10 Inventaires
     * const inventaires = await prisma.inventaire.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventaireWithIdOnly = await prisma.inventaire.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventaireFindManyArgs>(args?: SelectSubset<T, InventaireFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventairePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Inventaire.
     * @param {InventaireCreateArgs} args - Arguments to create a Inventaire.
     * @example
     * // Create one Inventaire
     * const Inventaire = await prisma.inventaire.create({
     *   data: {
     *     // ... data to create a Inventaire
     *   }
     * })
     * 
     */
    create<T extends InventaireCreateArgs>(args: SelectSubset<T, InventaireCreateArgs<ExtArgs>>): Prisma__InventaireClient<$Result.GetResult<Prisma.$InventairePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Inventaires.
     * @param {InventaireCreateManyArgs} args - Arguments to create many Inventaires.
     * @example
     * // Create many Inventaires
     * const inventaire = await prisma.inventaire.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventaireCreateManyArgs>(args?: SelectSubset<T, InventaireCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inventaires and returns the data saved in the database.
     * @param {InventaireCreateManyAndReturnArgs} args - Arguments to create many Inventaires.
     * @example
     * // Create many Inventaires
     * const inventaire = await prisma.inventaire.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inventaires and only return the `id`
     * const inventaireWithIdOnly = await prisma.inventaire.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventaireCreateManyAndReturnArgs>(args?: SelectSubset<T, InventaireCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventairePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Inventaire.
     * @param {InventaireDeleteArgs} args - Arguments to delete one Inventaire.
     * @example
     * // Delete one Inventaire
     * const Inventaire = await prisma.inventaire.delete({
     *   where: {
     *     // ... filter to delete one Inventaire
     *   }
     * })
     * 
     */
    delete<T extends InventaireDeleteArgs>(args: SelectSubset<T, InventaireDeleteArgs<ExtArgs>>): Prisma__InventaireClient<$Result.GetResult<Prisma.$InventairePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Inventaire.
     * @param {InventaireUpdateArgs} args - Arguments to update one Inventaire.
     * @example
     * // Update one Inventaire
     * const inventaire = await prisma.inventaire.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventaireUpdateArgs>(args: SelectSubset<T, InventaireUpdateArgs<ExtArgs>>): Prisma__InventaireClient<$Result.GetResult<Prisma.$InventairePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Inventaires.
     * @param {InventaireDeleteManyArgs} args - Arguments to filter Inventaires to delete.
     * @example
     * // Delete a few Inventaires
     * const { count } = await prisma.inventaire.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventaireDeleteManyArgs>(args?: SelectSubset<T, InventaireDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventaireUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventaires
     * const inventaire = await prisma.inventaire.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventaireUpdateManyArgs>(args: SelectSubset<T, InventaireUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inventaire.
     * @param {InventaireUpsertArgs} args - Arguments to update or create a Inventaire.
     * @example
     * // Update or create a Inventaire
     * const inventaire = await prisma.inventaire.upsert({
     *   create: {
     *     // ... data to create a Inventaire
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventaire we want to update
     *   }
     * })
     */
    upsert<T extends InventaireUpsertArgs>(args: SelectSubset<T, InventaireUpsertArgs<ExtArgs>>): Prisma__InventaireClient<$Result.GetResult<Prisma.$InventairePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Inventaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventaireCountArgs} args - Arguments to filter Inventaires to count.
     * @example
     * // Count the number of Inventaires
     * const count = await prisma.inventaire.count({
     *   where: {
     *     // ... the filter for the Inventaires we want to count
     *   }
     * })
    **/
    count<T extends InventaireCountArgs>(
      args?: Subset<T, InventaireCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventaireCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventaire.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventaireAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventaireAggregateArgs>(args: Subset<T, InventaireAggregateArgs>): Prisma.PrismaPromise<GetInventaireAggregateType<T>>

    /**
     * Group by Inventaire.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventaireGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventaireGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventaireGroupByArgs['orderBy'] }
        : { orderBy?: InventaireGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventaireGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventaireGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inventaire model
   */
  readonly fields: InventaireFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inventaire.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventaireClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lignes<T extends Inventaire$lignesArgs<ExtArgs> = {}>(args?: Subset<T, Inventaire$lignesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneInventairePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inventaire model
   */ 
  interface InventaireFieldRefs {
    readonly id: FieldRef<"Inventaire", 'String'>
    readonly numeroInventaire: FieldRef<"Inventaire", 'String'>
    readonly dateDebut: FieldRef<"Inventaire", 'DateTime'>
    readonly dateFin: FieldRef<"Inventaire", 'DateTime'>
    readonly status: FieldRef<"Inventaire", 'StatusInventaire'>
    readonly nbArticles: FieldRef<"Inventaire", 'Int'>
    readonly nbEcarts: FieldRef<"Inventaire", 'Int'>
    readonly montantEcart: FieldRef<"Inventaire", 'Float'>
    readonly notes: FieldRef<"Inventaire", 'String'>
    readonly createdAt: FieldRef<"Inventaire", 'DateTime'>
    readonly updatedAt: FieldRef<"Inventaire", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Inventaire findUnique
   */
  export type InventaireFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaire
     */
    select?: InventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventaireInclude<ExtArgs> | null
    /**
     * Filter, which Inventaire to fetch.
     */
    where: InventaireWhereUniqueInput
  }

  /**
   * Inventaire findUniqueOrThrow
   */
  export type InventaireFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaire
     */
    select?: InventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventaireInclude<ExtArgs> | null
    /**
     * Filter, which Inventaire to fetch.
     */
    where: InventaireWhereUniqueInput
  }

  /**
   * Inventaire findFirst
   */
  export type InventaireFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaire
     */
    select?: InventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventaireInclude<ExtArgs> | null
    /**
     * Filter, which Inventaire to fetch.
     */
    where?: InventaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventaires to fetch.
     */
    orderBy?: InventaireOrderByWithRelationInput | InventaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventaires.
     */
    cursor?: InventaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventaires.
     */
    distinct?: InventaireScalarFieldEnum | InventaireScalarFieldEnum[]
  }

  /**
   * Inventaire findFirstOrThrow
   */
  export type InventaireFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaire
     */
    select?: InventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventaireInclude<ExtArgs> | null
    /**
     * Filter, which Inventaire to fetch.
     */
    where?: InventaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventaires to fetch.
     */
    orderBy?: InventaireOrderByWithRelationInput | InventaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventaires.
     */
    cursor?: InventaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventaires.
     */
    distinct?: InventaireScalarFieldEnum | InventaireScalarFieldEnum[]
  }

  /**
   * Inventaire findMany
   */
  export type InventaireFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaire
     */
    select?: InventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventaireInclude<ExtArgs> | null
    /**
     * Filter, which Inventaires to fetch.
     */
    where?: InventaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventaires to fetch.
     */
    orderBy?: InventaireOrderByWithRelationInput | InventaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inventaires.
     */
    cursor?: InventaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventaires.
     */
    skip?: number
    distinct?: InventaireScalarFieldEnum | InventaireScalarFieldEnum[]
  }

  /**
   * Inventaire create
   */
  export type InventaireCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaire
     */
    select?: InventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventaireInclude<ExtArgs> | null
    /**
     * The data needed to create a Inventaire.
     */
    data: XOR<InventaireCreateInput, InventaireUncheckedCreateInput>
  }

  /**
   * Inventaire createMany
   */
  export type InventaireCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inventaires.
     */
    data: InventaireCreateManyInput | InventaireCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inventaire createManyAndReturn
   */
  export type InventaireCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaire
     */
    select?: InventaireSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Inventaires.
     */
    data: InventaireCreateManyInput | InventaireCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inventaire update
   */
  export type InventaireUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaire
     */
    select?: InventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventaireInclude<ExtArgs> | null
    /**
     * The data needed to update a Inventaire.
     */
    data: XOR<InventaireUpdateInput, InventaireUncheckedUpdateInput>
    /**
     * Choose, which Inventaire to update.
     */
    where: InventaireWhereUniqueInput
  }

  /**
   * Inventaire updateMany
   */
  export type InventaireUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inventaires.
     */
    data: XOR<InventaireUpdateManyMutationInput, InventaireUncheckedUpdateManyInput>
    /**
     * Filter which Inventaires to update
     */
    where?: InventaireWhereInput
  }

  /**
   * Inventaire upsert
   */
  export type InventaireUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaire
     */
    select?: InventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventaireInclude<ExtArgs> | null
    /**
     * The filter to search for the Inventaire to update in case it exists.
     */
    where: InventaireWhereUniqueInput
    /**
     * In case the Inventaire found by the `where` argument doesn't exist, create a new Inventaire with this data.
     */
    create: XOR<InventaireCreateInput, InventaireUncheckedCreateInput>
    /**
     * In case the Inventaire was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventaireUpdateInput, InventaireUncheckedUpdateInput>
  }

  /**
   * Inventaire delete
   */
  export type InventaireDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaire
     */
    select?: InventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventaireInclude<ExtArgs> | null
    /**
     * Filter which Inventaire to delete.
     */
    where: InventaireWhereUniqueInput
  }

  /**
   * Inventaire deleteMany
   */
  export type InventaireDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventaires to delete
     */
    where?: InventaireWhereInput
  }

  /**
   * Inventaire.lignes
   */
  export type Inventaire$lignesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneInventaire
     */
    select?: LigneInventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneInventaireInclude<ExtArgs> | null
    where?: LigneInventaireWhereInput
    orderBy?: LigneInventaireOrderByWithRelationInput | LigneInventaireOrderByWithRelationInput[]
    cursor?: LigneInventaireWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LigneInventaireScalarFieldEnum | LigneInventaireScalarFieldEnum[]
  }

  /**
   * Inventaire without action
   */
  export type InventaireDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventaire
     */
    select?: InventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventaireInclude<ExtArgs> | null
  }


  /**
   * Model LigneInventaire
   */

  export type AggregateLigneInventaire = {
    _count: LigneInventaireCountAggregateOutputType | null
    _avg: LigneInventaireAvgAggregateOutputType | null
    _sum: LigneInventaireSumAggregateOutputType | null
    _min: LigneInventaireMinAggregateOutputType | null
    _max: LigneInventaireMaxAggregateOutputType | null
  }

  export type LigneInventaireAvgAggregateOutputType = {
    quantiteTheorique: number | null
    quantiteReelle: number | null
    ecart: number | null
    valeurEcart: number | null
  }

  export type LigneInventaireSumAggregateOutputType = {
    quantiteTheorique: number | null
    quantiteReelle: number | null
    ecart: number | null
    valeurEcart: number | null
  }

  export type LigneInventaireMinAggregateOutputType = {
    id: string | null
    inventaireId: string | null
    articleId: string | null
    quantiteTheorique: number | null
    quantiteReelle: number | null
    ecart: number | null
    valeurEcart: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LigneInventaireMaxAggregateOutputType = {
    id: string | null
    inventaireId: string | null
    articleId: string | null
    quantiteTheorique: number | null
    quantiteReelle: number | null
    ecart: number | null
    valeurEcart: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LigneInventaireCountAggregateOutputType = {
    id: number
    inventaireId: number
    articleId: number
    quantiteTheorique: number
    quantiteReelle: number
    ecart: number
    valeurEcart: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LigneInventaireAvgAggregateInputType = {
    quantiteTheorique?: true
    quantiteReelle?: true
    ecart?: true
    valeurEcart?: true
  }

  export type LigneInventaireSumAggregateInputType = {
    quantiteTheorique?: true
    quantiteReelle?: true
    ecart?: true
    valeurEcart?: true
  }

  export type LigneInventaireMinAggregateInputType = {
    id?: true
    inventaireId?: true
    articleId?: true
    quantiteTheorique?: true
    quantiteReelle?: true
    ecart?: true
    valeurEcart?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LigneInventaireMaxAggregateInputType = {
    id?: true
    inventaireId?: true
    articleId?: true
    quantiteTheorique?: true
    quantiteReelle?: true
    ecart?: true
    valeurEcart?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LigneInventaireCountAggregateInputType = {
    id?: true
    inventaireId?: true
    articleId?: true
    quantiteTheorique?: true
    quantiteReelle?: true
    ecart?: true
    valeurEcart?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LigneInventaireAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LigneInventaire to aggregate.
     */
    where?: LigneInventaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneInventaires to fetch.
     */
    orderBy?: LigneInventaireOrderByWithRelationInput | LigneInventaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LigneInventaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneInventaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneInventaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LigneInventaires
    **/
    _count?: true | LigneInventaireCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LigneInventaireAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LigneInventaireSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LigneInventaireMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LigneInventaireMaxAggregateInputType
  }

  export type GetLigneInventaireAggregateType<T extends LigneInventaireAggregateArgs> = {
        [P in keyof T & keyof AggregateLigneInventaire]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLigneInventaire[P]>
      : GetScalarType<T[P], AggregateLigneInventaire[P]>
  }




  export type LigneInventaireGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LigneInventaireWhereInput
    orderBy?: LigneInventaireOrderByWithAggregationInput | LigneInventaireOrderByWithAggregationInput[]
    by: LigneInventaireScalarFieldEnum[] | LigneInventaireScalarFieldEnum
    having?: LigneInventaireScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LigneInventaireCountAggregateInputType | true
    _avg?: LigneInventaireAvgAggregateInputType
    _sum?: LigneInventaireSumAggregateInputType
    _min?: LigneInventaireMinAggregateInputType
    _max?: LigneInventaireMaxAggregateInputType
  }

  export type LigneInventaireGroupByOutputType = {
    id: string
    inventaireId: string
    articleId: string
    quantiteTheorique: number
    quantiteReelle: number
    ecart: number
    valeurEcart: number
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: LigneInventaireCountAggregateOutputType | null
    _avg: LigneInventaireAvgAggregateOutputType | null
    _sum: LigneInventaireSumAggregateOutputType | null
    _min: LigneInventaireMinAggregateOutputType | null
    _max: LigneInventaireMaxAggregateOutputType | null
  }

  type GetLigneInventaireGroupByPayload<T extends LigneInventaireGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LigneInventaireGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LigneInventaireGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LigneInventaireGroupByOutputType[P]>
            : GetScalarType<T[P], LigneInventaireGroupByOutputType[P]>
        }
      >
    >


  export type LigneInventaireSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inventaireId?: boolean
    articleId?: boolean
    quantiteTheorique?: boolean
    quantiteReelle?: boolean
    ecart?: boolean
    valeurEcart?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inventaire?: boolean | InventaireDefaultArgs<ExtArgs>
    article?: boolean | ArticleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ligneInventaire"]>

  export type LigneInventaireSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inventaireId?: boolean
    articleId?: boolean
    quantiteTheorique?: boolean
    quantiteReelle?: boolean
    ecart?: boolean
    valeurEcart?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inventaire?: boolean | InventaireDefaultArgs<ExtArgs>
    article?: boolean | ArticleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ligneInventaire"]>

  export type LigneInventaireSelectScalar = {
    id?: boolean
    inventaireId?: boolean
    articleId?: boolean
    quantiteTheorique?: boolean
    quantiteReelle?: boolean
    ecart?: boolean
    valeurEcart?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LigneInventaireInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventaire?: boolean | InventaireDefaultArgs<ExtArgs>
    article?: boolean | ArticleDefaultArgs<ExtArgs>
  }
  export type LigneInventaireIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventaire?: boolean | InventaireDefaultArgs<ExtArgs>
    article?: boolean | ArticleDefaultArgs<ExtArgs>
  }

  export type $LigneInventairePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LigneInventaire"
    objects: {
      inventaire: Prisma.$InventairePayload<ExtArgs>
      article: Prisma.$ArticlePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      inventaireId: string
      articleId: string
      quantiteTheorique: number
      quantiteReelle: number
      ecart: number
      valeurEcart: number
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ligneInventaire"]>
    composites: {}
  }

  type LigneInventaireGetPayload<S extends boolean | null | undefined | LigneInventaireDefaultArgs> = $Result.GetResult<Prisma.$LigneInventairePayload, S>

  type LigneInventaireCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LigneInventaireFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LigneInventaireCountAggregateInputType | true
    }

  export interface LigneInventaireDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LigneInventaire'], meta: { name: 'LigneInventaire' } }
    /**
     * Find zero or one LigneInventaire that matches the filter.
     * @param {LigneInventaireFindUniqueArgs} args - Arguments to find a LigneInventaire
     * @example
     * // Get one LigneInventaire
     * const ligneInventaire = await prisma.ligneInventaire.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LigneInventaireFindUniqueArgs>(args: SelectSubset<T, LigneInventaireFindUniqueArgs<ExtArgs>>): Prisma__LigneInventaireClient<$Result.GetResult<Prisma.$LigneInventairePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LigneInventaire that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LigneInventaireFindUniqueOrThrowArgs} args - Arguments to find a LigneInventaire
     * @example
     * // Get one LigneInventaire
     * const ligneInventaire = await prisma.ligneInventaire.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LigneInventaireFindUniqueOrThrowArgs>(args: SelectSubset<T, LigneInventaireFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LigneInventaireClient<$Result.GetResult<Prisma.$LigneInventairePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LigneInventaire that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneInventaireFindFirstArgs} args - Arguments to find a LigneInventaire
     * @example
     * // Get one LigneInventaire
     * const ligneInventaire = await prisma.ligneInventaire.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LigneInventaireFindFirstArgs>(args?: SelectSubset<T, LigneInventaireFindFirstArgs<ExtArgs>>): Prisma__LigneInventaireClient<$Result.GetResult<Prisma.$LigneInventairePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LigneInventaire that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneInventaireFindFirstOrThrowArgs} args - Arguments to find a LigneInventaire
     * @example
     * // Get one LigneInventaire
     * const ligneInventaire = await prisma.ligneInventaire.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LigneInventaireFindFirstOrThrowArgs>(args?: SelectSubset<T, LigneInventaireFindFirstOrThrowArgs<ExtArgs>>): Prisma__LigneInventaireClient<$Result.GetResult<Prisma.$LigneInventairePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LigneInventaires that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneInventaireFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LigneInventaires
     * const ligneInventaires = await prisma.ligneInventaire.findMany()
     * 
     * // Get first 10 LigneInventaires
     * const ligneInventaires = await prisma.ligneInventaire.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ligneInventaireWithIdOnly = await prisma.ligneInventaire.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LigneInventaireFindManyArgs>(args?: SelectSubset<T, LigneInventaireFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneInventairePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LigneInventaire.
     * @param {LigneInventaireCreateArgs} args - Arguments to create a LigneInventaire.
     * @example
     * // Create one LigneInventaire
     * const LigneInventaire = await prisma.ligneInventaire.create({
     *   data: {
     *     // ... data to create a LigneInventaire
     *   }
     * })
     * 
     */
    create<T extends LigneInventaireCreateArgs>(args: SelectSubset<T, LigneInventaireCreateArgs<ExtArgs>>): Prisma__LigneInventaireClient<$Result.GetResult<Prisma.$LigneInventairePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LigneInventaires.
     * @param {LigneInventaireCreateManyArgs} args - Arguments to create many LigneInventaires.
     * @example
     * // Create many LigneInventaires
     * const ligneInventaire = await prisma.ligneInventaire.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LigneInventaireCreateManyArgs>(args?: SelectSubset<T, LigneInventaireCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LigneInventaires and returns the data saved in the database.
     * @param {LigneInventaireCreateManyAndReturnArgs} args - Arguments to create many LigneInventaires.
     * @example
     * // Create many LigneInventaires
     * const ligneInventaire = await prisma.ligneInventaire.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LigneInventaires and only return the `id`
     * const ligneInventaireWithIdOnly = await prisma.ligneInventaire.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LigneInventaireCreateManyAndReturnArgs>(args?: SelectSubset<T, LigneInventaireCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneInventairePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LigneInventaire.
     * @param {LigneInventaireDeleteArgs} args - Arguments to delete one LigneInventaire.
     * @example
     * // Delete one LigneInventaire
     * const LigneInventaire = await prisma.ligneInventaire.delete({
     *   where: {
     *     // ... filter to delete one LigneInventaire
     *   }
     * })
     * 
     */
    delete<T extends LigneInventaireDeleteArgs>(args: SelectSubset<T, LigneInventaireDeleteArgs<ExtArgs>>): Prisma__LigneInventaireClient<$Result.GetResult<Prisma.$LigneInventairePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LigneInventaire.
     * @param {LigneInventaireUpdateArgs} args - Arguments to update one LigneInventaire.
     * @example
     * // Update one LigneInventaire
     * const ligneInventaire = await prisma.ligneInventaire.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LigneInventaireUpdateArgs>(args: SelectSubset<T, LigneInventaireUpdateArgs<ExtArgs>>): Prisma__LigneInventaireClient<$Result.GetResult<Prisma.$LigneInventairePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LigneInventaires.
     * @param {LigneInventaireDeleteManyArgs} args - Arguments to filter LigneInventaires to delete.
     * @example
     * // Delete a few LigneInventaires
     * const { count } = await prisma.ligneInventaire.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LigneInventaireDeleteManyArgs>(args?: SelectSubset<T, LigneInventaireDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LigneInventaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneInventaireUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LigneInventaires
     * const ligneInventaire = await prisma.ligneInventaire.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LigneInventaireUpdateManyArgs>(args: SelectSubset<T, LigneInventaireUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LigneInventaire.
     * @param {LigneInventaireUpsertArgs} args - Arguments to update or create a LigneInventaire.
     * @example
     * // Update or create a LigneInventaire
     * const ligneInventaire = await prisma.ligneInventaire.upsert({
     *   create: {
     *     // ... data to create a LigneInventaire
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LigneInventaire we want to update
     *   }
     * })
     */
    upsert<T extends LigneInventaireUpsertArgs>(args: SelectSubset<T, LigneInventaireUpsertArgs<ExtArgs>>): Prisma__LigneInventaireClient<$Result.GetResult<Prisma.$LigneInventairePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LigneInventaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneInventaireCountArgs} args - Arguments to filter LigneInventaires to count.
     * @example
     * // Count the number of LigneInventaires
     * const count = await prisma.ligneInventaire.count({
     *   where: {
     *     // ... the filter for the LigneInventaires we want to count
     *   }
     * })
    **/
    count<T extends LigneInventaireCountArgs>(
      args?: Subset<T, LigneInventaireCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LigneInventaireCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LigneInventaire.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneInventaireAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LigneInventaireAggregateArgs>(args: Subset<T, LigneInventaireAggregateArgs>): Prisma.PrismaPromise<GetLigneInventaireAggregateType<T>>

    /**
     * Group by LigneInventaire.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneInventaireGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LigneInventaireGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LigneInventaireGroupByArgs['orderBy'] }
        : { orderBy?: LigneInventaireGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LigneInventaireGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLigneInventaireGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LigneInventaire model
   */
  readonly fields: LigneInventaireFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LigneInventaire.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LigneInventaireClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inventaire<T extends InventaireDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventaireDefaultArgs<ExtArgs>>): Prisma__InventaireClient<$Result.GetResult<Prisma.$InventairePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    article<T extends ArticleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArticleDefaultArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LigneInventaire model
   */ 
  interface LigneInventaireFieldRefs {
    readonly id: FieldRef<"LigneInventaire", 'String'>
    readonly inventaireId: FieldRef<"LigneInventaire", 'String'>
    readonly articleId: FieldRef<"LigneInventaire", 'String'>
    readonly quantiteTheorique: FieldRef<"LigneInventaire", 'Float'>
    readonly quantiteReelle: FieldRef<"LigneInventaire", 'Float'>
    readonly ecart: FieldRef<"LigneInventaire", 'Float'>
    readonly valeurEcart: FieldRef<"LigneInventaire", 'Float'>
    readonly notes: FieldRef<"LigneInventaire", 'String'>
    readonly createdAt: FieldRef<"LigneInventaire", 'DateTime'>
    readonly updatedAt: FieldRef<"LigneInventaire", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LigneInventaire findUnique
   */
  export type LigneInventaireFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneInventaire
     */
    select?: LigneInventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneInventaireInclude<ExtArgs> | null
    /**
     * Filter, which LigneInventaire to fetch.
     */
    where: LigneInventaireWhereUniqueInput
  }

  /**
   * LigneInventaire findUniqueOrThrow
   */
  export type LigneInventaireFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneInventaire
     */
    select?: LigneInventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneInventaireInclude<ExtArgs> | null
    /**
     * Filter, which LigneInventaire to fetch.
     */
    where: LigneInventaireWhereUniqueInput
  }

  /**
   * LigneInventaire findFirst
   */
  export type LigneInventaireFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneInventaire
     */
    select?: LigneInventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneInventaireInclude<ExtArgs> | null
    /**
     * Filter, which LigneInventaire to fetch.
     */
    where?: LigneInventaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneInventaires to fetch.
     */
    orderBy?: LigneInventaireOrderByWithRelationInput | LigneInventaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LigneInventaires.
     */
    cursor?: LigneInventaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneInventaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneInventaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LigneInventaires.
     */
    distinct?: LigneInventaireScalarFieldEnum | LigneInventaireScalarFieldEnum[]
  }

  /**
   * LigneInventaire findFirstOrThrow
   */
  export type LigneInventaireFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneInventaire
     */
    select?: LigneInventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneInventaireInclude<ExtArgs> | null
    /**
     * Filter, which LigneInventaire to fetch.
     */
    where?: LigneInventaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneInventaires to fetch.
     */
    orderBy?: LigneInventaireOrderByWithRelationInput | LigneInventaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LigneInventaires.
     */
    cursor?: LigneInventaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneInventaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneInventaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LigneInventaires.
     */
    distinct?: LigneInventaireScalarFieldEnum | LigneInventaireScalarFieldEnum[]
  }

  /**
   * LigneInventaire findMany
   */
  export type LigneInventaireFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneInventaire
     */
    select?: LigneInventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneInventaireInclude<ExtArgs> | null
    /**
     * Filter, which LigneInventaires to fetch.
     */
    where?: LigneInventaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneInventaires to fetch.
     */
    orderBy?: LigneInventaireOrderByWithRelationInput | LigneInventaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LigneInventaires.
     */
    cursor?: LigneInventaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneInventaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneInventaires.
     */
    skip?: number
    distinct?: LigneInventaireScalarFieldEnum | LigneInventaireScalarFieldEnum[]
  }

  /**
   * LigneInventaire create
   */
  export type LigneInventaireCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneInventaire
     */
    select?: LigneInventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneInventaireInclude<ExtArgs> | null
    /**
     * The data needed to create a LigneInventaire.
     */
    data: XOR<LigneInventaireCreateInput, LigneInventaireUncheckedCreateInput>
  }

  /**
   * LigneInventaire createMany
   */
  export type LigneInventaireCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LigneInventaires.
     */
    data: LigneInventaireCreateManyInput | LigneInventaireCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LigneInventaire createManyAndReturn
   */
  export type LigneInventaireCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneInventaire
     */
    select?: LigneInventaireSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LigneInventaires.
     */
    data: LigneInventaireCreateManyInput | LigneInventaireCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneInventaireIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LigneInventaire update
   */
  export type LigneInventaireUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneInventaire
     */
    select?: LigneInventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneInventaireInclude<ExtArgs> | null
    /**
     * The data needed to update a LigneInventaire.
     */
    data: XOR<LigneInventaireUpdateInput, LigneInventaireUncheckedUpdateInput>
    /**
     * Choose, which LigneInventaire to update.
     */
    where: LigneInventaireWhereUniqueInput
  }

  /**
   * LigneInventaire updateMany
   */
  export type LigneInventaireUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LigneInventaires.
     */
    data: XOR<LigneInventaireUpdateManyMutationInput, LigneInventaireUncheckedUpdateManyInput>
    /**
     * Filter which LigneInventaires to update
     */
    where?: LigneInventaireWhereInput
  }

  /**
   * LigneInventaire upsert
   */
  export type LigneInventaireUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneInventaire
     */
    select?: LigneInventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneInventaireInclude<ExtArgs> | null
    /**
     * The filter to search for the LigneInventaire to update in case it exists.
     */
    where: LigneInventaireWhereUniqueInput
    /**
     * In case the LigneInventaire found by the `where` argument doesn't exist, create a new LigneInventaire with this data.
     */
    create: XOR<LigneInventaireCreateInput, LigneInventaireUncheckedCreateInput>
    /**
     * In case the LigneInventaire was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LigneInventaireUpdateInput, LigneInventaireUncheckedUpdateInput>
  }

  /**
   * LigneInventaire delete
   */
  export type LigneInventaireDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneInventaire
     */
    select?: LigneInventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneInventaireInclude<ExtArgs> | null
    /**
     * Filter which LigneInventaire to delete.
     */
    where: LigneInventaireWhereUniqueInput
  }

  /**
   * LigneInventaire deleteMany
   */
  export type LigneInventaireDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LigneInventaires to delete
     */
    where?: LigneInventaireWhereInput
  }

  /**
   * LigneInventaire without action
   */
  export type LigneInventaireDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneInventaire
     */
    select?: LigneInventaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneInventaireInclude<ExtArgs> | null
  }


  /**
   * Model Equipement
   */

  export type AggregateEquipement = {
    _count: EquipementCountAggregateOutputType | null
    _avg: EquipementAvgAggregateOutputType | null
    _sum: EquipementSumAggregateOutputType | null
    _min: EquipementMinAggregateOutputType | null
    _max: EquipementMaxAggregateOutputType | null
  }

  export type EquipementAvgAggregateOutputType = {
    valeurAchat: number | null
  }

  export type EquipementSumAggregateOutputType = {
    valeurAchat: number | null
  }

  export type EquipementMinAggregateOutputType = {
    id: string | null
    reference: string | null
    nom: string | null
    description: string | null
    categorie: string | null
    dateAchat: Date | null
    valeurAchat: number | null
    departement: string | null
    utilisateurId: string | null
    emplacement: string | null
    status: $Enums.StatusEquipement | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipementMaxAggregateOutputType = {
    id: string | null
    reference: string | null
    nom: string | null
    description: string | null
    categorie: string | null
    dateAchat: Date | null
    valeurAchat: number | null
    departement: string | null
    utilisateurId: string | null
    emplacement: string | null
    status: $Enums.StatusEquipement | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipementCountAggregateOutputType = {
    id: number
    reference: number
    nom: number
    description: number
    categorie: number
    dateAchat: number
    valeurAchat: number
    departement: number
    utilisateurId: number
    emplacement: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EquipementAvgAggregateInputType = {
    valeurAchat?: true
  }

  export type EquipementSumAggregateInputType = {
    valeurAchat?: true
  }

  export type EquipementMinAggregateInputType = {
    id?: true
    reference?: true
    nom?: true
    description?: true
    categorie?: true
    dateAchat?: true
    valeurAchat?: true
    departement?: true
    utilisateurId?: true
    emplacement?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipementMaxAggregateInputType = {
    id?: true
    reference?: true
    nom?: true
    description?: true
    categorie?: true
    dateAchat?: true
    valeurAchat?: true
    departement?: true
    utilisateurId?: true
    emplacement?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipementCountAggregateInputType = {
    id?: true
    reference?: true
    nom?: true
    description?: true
    categorie?: true
    dateAchat?: true
    valeurAchat?: true
    departement?: true
    utilisateurId?: true
    emplacement?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EquipementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipement to aggregate.
     */
    where?: EquipementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipements to fetch.
     */
    orderBy?: EquipementOrderByWithRelationInput | EquipementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Equipements
    **/
    _count?: true | EquipementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipementMaxAggregateInputType
  }

  export type GetEquipementAggregateType<T extends EquipementAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipement[P]>
      : GetScalarType<T[P], AggregateEquipement[P]>
  }




  export type EquipementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipementWhereInput
    orderBy?: EquipementOrderByWithAggregationInput | EquipementOrderByWithAggregationInput[]
    by: EquipementScalarFieldEnum[] | EquipementScalarFieldEnum
    having?: EquipementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipementCountAggregateInputType | true
    _avg?: EquipementAvgAggregateInputType
    _sum?: EquipementSumAggregateInputType
    _min?: EquipementMinAggregateInputType
    _max?: EquipementMaxAggregateInputType
  }

  export type EquipementGroupByOutputType = {
    id: string
    reference: string
    nom: string
    description: string | null
    categorie: string
    dateAchat: Date | null
    valeurAchat: number
    departement: string | null
    utilisateurId: string | null
    emplacement: string | null
    status: $Enums.StatusEquipement
    createdAt: Date
    updatedAt: Date
    _count: EquipementCountAggregateOutputType | null
    _avg: EquipementAvgAggregateOutputType | null
    _sum: EquipementSumAggregateOutputType | null
    _min: EquipementMinAggregateOutputType | null
    _max: EquipementMaxAggregateOutputType | null
  }

  type GetEquipementGroupByPayload<T extends EquipementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipementGroupByOutputType[P]>
            : GetScalarType<T[P], EquipementGroupByOutputType[P]>
        }
      >
    >


  export type EquipementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reference?: boolean
    nom?: boolean
    description?: boolean
    categorie?: boolean
    dateAchat?: boolean
    valeurAchat?: boolean
    departement?: boolean
    utilisateurId?: boolean
    emplacement?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    maintenances?: boolean | Equipement$maintenancesArgs<ExtArgs>
    _count?: boolean | EquipementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipement"]>

  export type EquipementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reference?: boolean
    nom?: boolean
    description?: boolean
    categorie?: boolean
    dateAchat?: boolean
    valeurAchat?: boolean
    departement?: boolean
    utilisateurId?: boolean
    emplacement?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["equipement"]>

  export type EquipementSelectScalar = {
    id?: boolean
    reference?: boolean
    nom?: boolean
    description?: boolean
    categorie?: boolean
    dateAchat?: boolean
    valeurAchat?: boolean
    departement?: boolean
    utilisateurId?: boolean
    emplacement?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EquipementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maintenances?: boolean | Equipement$maintenancesArgs<ExtArgs>
    _count?: boolean | EquipementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EquipementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EquipementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Equipement"
    objects: {
      maintenances: Prisma.$MaintenanceEquipementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reference: string
      nom: string
      description: string | null
      categorie: string
      dateAchat: Date | null
      valeurAchat: number
      departement: string | null
      utilisateurId: string | null
      emplacement: string | null
      status: $Enums.StatusEquipement
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["equipement"]>
    composites: {}
  }

  type EquipementGetPayload<S extends boolean | null | undefined | EquipementDefaultArgs> = $Result.GetResult<Prisma.$EquipementPayload, S>

  type EquipementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EquipementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EquipementCountAggregateInputType | true
    }

  export interface EquipementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Equipement'], meta: { name: 'Equipement' } }
    /**
     * Find zero or one Equipement that matches the filter.
     * @param {EquipementFindUniqueArgs} args - Arguments to find a Equipement
     * @example
     * // Get one Equipement
     * const equipement = await prisma.equipement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipementFindUniqueArgs>(args: SelectSubset<T, EquipementFindUniqueArgs<ExtArgs>>): Prisma__EquipementClient<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Equipement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EquipementFindUniqueOrThrowArgs} args - Arguments to find a Equipement
     * @example
     * // Get one Equipement
     * const equipement = await prisma.equipement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipementFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipementClient<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Equipement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipementFindFirstArgs} args - Arguments to find a Equipement
     * @example
     * // Get one Equipement
     * const equipement = await prisma.equipement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipementFindFirstArgs>(args?: SelectSubset<T, EquipementFindFirstArgs<ExtArgs>>): Prisma__EquipementClient<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Equipement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipementFindFirstOrThrowArgs} args - Arguments to find a Equipement
     * @example
     * // Get one Equipement
     * const equipement = await prisma.equipement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipementFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipementFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipementClient<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Equipements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Equipements
     * const equipements = await prisma.equipement.findMany()
     * 
     * // Get first 10 Equipements
     * const equipements = await prisma.equipement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipementWithIdOnly = await prisma.equipement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EquipementFindManyArgs>(args?: SelectSubset<T, EquipementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Equipement.
     * @param {EquipementCreateArgs} args - Arguments to create a Equipement.
     * @example
     * // Create one Equipement
     * const Equipement = await prisma.equipement.create({
     *   data: {
     *     // ... data to create a Equipement
     *   }
     * })
     * 
     */
    create<T extends EquipementCreateArgs>(args: SelectSubset<T, EquipementCreateArgs<ExtArgs>>): Prisma__EquipementClient<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Equipements.
     * @param {EquipementCreateManyArgs} args - Arguments to create many Equipements.
     * @example
     * // Create many Equipements
     * const equipement = await prisma.equipement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipementCreateManyArgs>(args?: SelectSubset<T, EquipementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Equipements and returns the data saved in the database.
     * @param {EquipementCreateManyAndReturnArgs} args - Arguments to create many Equipements.
     * @example
     * // Create many Equipements
     * const equipement = await prisma.equipement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Equipements and only return the `id`
     * const equipementWithIdOnly = await prisma.equipement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EquipementCreateManyAndReturnArgs>(args?: SelectSubset<T, EquipementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Equipement.
     * @param {EquipementDeleteArgs} args - Arguments to delete one Equipement.
     * @example
     * // Delete one Equipement
     * const Equipement = await prisma.equipement.delete({
     *   where: {
     *     // ... filter to delete one Equipement
     *   }
     * })
     * 
     */
    delete<T extends EquipementDeleteArgs>(args: SelectSubset<T, EquipementDeleteArgs<ExtArgs>>): Prisma__EquipementClient<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Equipement.
     * @param {EquipementUpdateArgs} args - Arguments to update one Equipement.
     * @example
     * // Update one Equipement
     * const equipement = await prisma.equipement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipementUpdateArgs>(args: SelectSubset<T, EquipementUpdateArgs<ExtArgs>>): Prisma__EquipementClient<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Equipements.
     * @param {EquipementDeleteManyArgs} args - Arguments to filter Equipements to delete.
     * @example
     * // Delete a few Equipements
     * const { count } = await prisma.equipement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipementDeleteManyArgs>(args?: SelectSubset<T, EquipementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Equipements
     * const equipement = await prisma.equipement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipementUpdateManyArgs>(args: SelectSubset<T, EquipementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Equipement.
     * @param {EquipementUpsertArgs} args - Arguments to update or create a Equipement.
     * @example
     * // Update or create a Equipement
     * const equipement = await prisma.equipement.upsert({
     *   create: {
     *     // ... data to create a Equipement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Equipement we want to update
     *   }
     * })
     */
    upsert<T extends EquipementUpsertArgs>(args: SelectSubset<T, EquipementUpsertArgs<ExtArgs>>): Prisma__EquipementClient<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Equipements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipementCountArgs} args - Arguments to filter Equipements to count.
     * @example
     * // Count the number of Equipements
     * const count = await prisma.equipement.count({
     *   where: {
     *     // ... the filter for the Equipements we want to count
     *   }
     * })
    **/
    count<T extends EquipementCountArgs>(
      args?: Subset<T, EquipementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Equipement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipementAggregateArgs>(args: Subset<T, EquipementAggregateArgs>): Prisma.PrismaPromise<GetEquipementAggregateType<T>>

    /**
     * Group by Equipement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipementGroupByArgs['orderBy'] }
        : { orderBy?: EquipementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Equipement model
   */
  readonly fields: EquipementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Equipement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    maintenances<T extends Equipement$maintenancesArgs<ExtArgs> = {}>(args?: Subset<T, Equipement$maintenancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceEquipementPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Equipement model
   */ 
  interface EquipementFieldRefs {
    readonly id: FieldRef<"Equipement", 'String'>
    readonly reference: FieldRef<"Equipement", 'String'>
    readonly nom: FieldRef<"Equipement", 'String'>
    readonly description: FieldRef<"Equipement", 'String'>
    readonly categorie: FieldRef<"Equipement", 'String'>
    readonly dateAchat: FieldRef<"Equipement", 'DateTime'>
    readonly valeurAchat: FieldRef<"Equipement", 'Float'>
    readonly departement: FieldRef<"Equipement", 'String'>
    readonly utilisateurId: FieldRef<"Equipement", 'String'>
    readonly emplacement: FieldRef<"Equipement", 'String'>
    readonly status: FieldRef<"Equipement", 'StatusEquipement'>
    readonly createdAt: FieldRef<"Equipement", 'DateTime'>
    readonly updatedAt: FieldRef<"Equipement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Equipement findUnique
   */
  export type EquipementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipementInclude<ExtArgs> | null
    /**
     * Filter, which Equipement to fetch.
     */
    where: EquipementWhereUniqueInput
  }

  /**
   * Equipement findUniqueOrThrow
   */
  export type EquipementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipementInclude<ExtArgs> | null
    /**
     * Filter, which Equipement to fetch.
     */
    where: EquipementWhereUniqueInput
  }

  /**
   * Equipement findFirst
   */
  export type EquipementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipementInclude<ExtArgs> | null
    /**
     * Filter, which Equipement to fetch.
     */
    where?: EquipementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipements to fetch.
     */
    orderBy?: EquipementOrderByWithRelationInput | EquipementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipements.
     */
    cursor?: EquipementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipements.
     */
    distinct?: EquipementScalarFieldEnum | EquipementScalarFieldEnum[]
  }

  /**
   * Equipement findFirstOrThrow
   */
  export type EquipementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipementInclude<ExtArgs> | null
    /**
     * Filter, which Equipement to fetch.
     */
    where?: EquipementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipements to fetch.
     */
    orderBy?: EquipementOrderByWithRelationInput | EquipementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipements.
     */
    cursor?: EquipementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipements.
     */
    distinct?: EquipementScalarFieldEnum | EquipementScalarFieldEnum[]
  }

  /**
   * Equipement findMany
   */
  export type EquipementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipementInclude<ExtArgs> | null
    /**
     * Filter, which Equipements to fetch.
     */
    where?: EquipementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipements to fetch.
     */
    orderBy?: EquipementOrderByWithRelationInput | EquipementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Equipements.
     */
    cursor?: EquipementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipements.
     */
    skip?: number
    distinct?: EquipementScalarFieldEnum | EquipementScalarFieldEnum[]
  }

  /**
   * Equipement create
   */
  export type EquipementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipementInclude<ExtArgs> | null
    /**
     * The data needed to create a Equipement.
     */
    data: XOR<EquipementCreateInput, EquipementUncheckedCreateInput>
  }

  /**
   * Equipement createMany
   */
  export type EquipementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Equipements.
     */
    data: EquipementCreateManyInput | EquipementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Equipement createManyAndReturn
   */
  export type EquipementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Equipements.
     */
    data: EquipementCreateManyInput | EquipementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Equipement update
   */
  export type EquipementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipementInclude<ExtArgs> | null
    /**
     * The data needed to update a Equipement.
     */
    data: XOR<EquipementUpdateInput, EquipementUncheckedUpdateInput>
    /**
     * Choose, which Equipement to update.
     */
    where: EquipementWhereUniqueInput
  }

  /**
   * Equipement updateMany
   */
  export type EquipementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Equipements.
     */
    data: XOR<EquipementUpdateManyMutationInput, EquipementUncheckedUpdateManyInput>
    /**
     * Filter which Equipements to update
     */
    where?: EquipementWhereInput
  }

  /**
   * Equipement upsert
   */
  export type EquipementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipementInclude<ExtArgs> | null
    /**
     * The filter to search for the Equipement to update in case it exists.
     */
    where: EquipementWhereUniqueInput
    /**
     * In case the Equipement found by the `where` argument doesn't exist, create a new Equipement with this data.
     */
    create: XOR<EquipementCreateInput, EquipementUncheckedCreateInput>
    /**
     * In case the Equipement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipementUpdateInput, EquipementUncheckedUpdateInput>
  }

  /**
   * Equipement delete
   */
  export type EquipementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipementInclude<ExtArgs> | null
    /**
     * Filter which Equipement to delete.
     */
    where: EquipementWhereUniqueInput
  }

  /**
   * Equipement deleteMany
   */
  export type EquipementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipements to delete
     */
    where?: EquipementWhereInput
  }

  /**
   * Equipement.maintenances
   */
  export type Equipement$maintenancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceEquipement
     */
    select?: MaintenanceEquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceEquipementInclude<ExtArgs> | null
    where?: MaintenanceEquipementWhereInput
    orderBy?: MaintenanceEquipementOrderByWithRelationInput | MaintenanceEquipementOrderByWithRelationInput[]
    cursor?: MaintenanceEquipementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceEquipementScalarFieldEnum | MaintenanceEquipementScalarFieldEnum[]
  }

  /**
   * Equipement without action
   */
  export type EquipementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipementInclude<ExtArgs> | null
  }


  /**
   * Model MaintenanceEquipement
   */

  export type AggregateMaintenanceEquipement = {
    _count: MaintenanceEquipementCountAggregateOutputType | null
    _avg: MaintenanceEquipementAvgAggregateOutputType | null
    _sum: MaintenanceEquipementSumAggregateOutputType | null
    _min: MaintenanceEquipementMinAggregateOutputType | null
    _max: MaintenanceEquipementMaxAggregateOutputType | null
  }

  export type MaintenanceEquipementAvgAggregateOutputType = {
    coutReel: number | null
  }

  export type MaintenanceEquipementSumAggregateOutputType = {
    coutReel: number | null
  }

  export type MaintenanceEquipementMinAggregateOutputType = {
    id: string | null
    equipementId: string | null
    type: $Enums.TypeMaintenance | null
    dateDebut: Date | null
    dateFin: Date | null
    technicienId: string | null
    description: string | null
    coutReel: number | null
    status: $Enums.StatusMaintenance | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaintenanceEquipementMaxAggregateOutputType = {
    id: string | null
    equipementId: string | null
    type: $Enums.TypeMaintenance | null
    dateDebut: Date | null
    dateFin: Date | null
    technicienId: string | null
    description: string | null
    coutReel: number | null
    status: $Enums.StatusMaintenance | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaintenanceEquipementCountAggregateOutputType = {
    id: number
    equipementId: number
    type: number
    dateDebut: number
    dateFin: number
    technicienId: number
    description: number
    coutReel: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MaintenanceEquipementAvgAggregateInputType = {
    coutReel?: true
  }

  export type MaintenanceEquipementSumAggregateInputType = {
    coutReel?: true
  }

  export type MaintenanceEquipementMinAggregateInputType = {
    id?: true
    equipementId?: true
    type?: true
    dateDebut?: true
    dateFin?: true
    technicienId?: true
    description?: true
    coutReel?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaintenanceEquipementMaxAggregateInputType = {
    id?: true
    equipementId?: true
    type?: true
    dateDebut?: true
    dateFin?: true
    technicienId?: true
    description?: true
    coutReel?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaintenanceEquipementCountAggregateInputType = {
    id?: true
    equipementId?: true
    type?: true
    dateDebut?: true
    dateFin?: true
    technicienId?: true
    description?: true
    coutReel?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MaintenanceEquipementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceEquipement to aggregate.
     */
    where?: MaintenanceEquipementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceEquipements to fetch.
     */
    orderBy?: MaintenanceEquipementOrderByWithRelationInput | MaintenanceEquipementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaintenanceEquipementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceEquipements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceEquipements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaintenanceEquipements
    **/
    _count?: true | MaintenanceEquipementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaintenanceEquipementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaintenanceEquipementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaintenanceEquipementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaintenanceEquipementMaxAggregateInputType
  }

  export type GetMaintenanceEquipementAggregateType<T extends MaintenanceEquipementAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintenanceEquipement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintenanceEquipement[P]>
      : GetScalarType<T[P], AggregateMaintenanceEquipement[P]>
  }




  export type MaintenanceEquipementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceEquipementWhereInput
    orderBy?: MaintenanceEquipementOrderByWithAggregationInput | MaintenanceEquipementOrderByWithAggregationInput[]
    by: MaintenanceEquipementScalarFieldEnum[] | MaintenanceEquipementScalarFieldEnum
    having?: MaintenanceEquipementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaintenanceEquipementCountAggregateInputType | true
    _avg?: MaintenanceEquipementAvgAggregateInputType
    _sum?: MaintenanceEquipementSumAggregateInputType
    _min?: MaintenanceEquipementMinAggregateInputType
    _max?: MaintenanceEquipementMaxAggregateInputType
  }

  export type MaintenanceEquipementGroupByOutputType = {
    id: string
    equipementId: string
    type: $Enums.TypeMaintenance
    dateDebut: Date
    dateFin: Date | null
    technicienId: string | null
    description: string
    coutReel: number
    status: $Enums.StatusMaintenance
    createdAt: Date
    updatedAt: Date
    _count: MaintenanceEquipementCountAggregateOutputType | null
    _avg: MaintenanceEquipementAvgAggregateOutputType | null
    _sum: MaintenanceEquipementSumAggregateOutputType | null
    _min: MaintenanceEquipementMinAggregateOutputType | null
    _max: MaintenanceEquipementMaxAggregateOutputType | null
  }

  type GetMaintenanceEquipementGroupByPayload<T extends MaintenanceEquipementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaintenanceEquipementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaintenanceEquipementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaintenanceEquipementGroupByOutputType[P]>
            : GetScalarType<T[P], MaintenanceEquipementGroupByOutputType[P]>
        }
      >
    >


  export type MaintenanceEquipementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipementId?: boolean
    type?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    technicienId?: boolean
    description?: boolean
    coutReel?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    equipement?: boolean | EquipementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceEquipement"]>

  export type MaintenanceEquipementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipementId?: boolean
    type?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    technicienId?: boolean
    description?: boolean
    coutReel?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    equipement?: boolean | EquipementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceEquipement"]>

  export type MaintenanceEquipementSelectScalar = {
    id?: boolean
    equipementId?: boolean
    type?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    technicienId?: boolean
    description?: boolean
    coutReel?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MaintenanceEquipementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipement?: boolean | EquipementDefaultArgs<ExtArgs>
  }
  export type MaintenanceEquipementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipement?: boolean | EquipementDefaultArgs<ExtArgs>
  }

  export type $MaintenanceEquipementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaintenanceEquipement"
    objects: {
      equipement: Prisma.$EquipementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      equipementId: string
      type: $Enums.TypeMaintenance
      dateDebut: Date
      dateFin: Date | null
      technicienId: string | null
      description: string
      coutReel: number
      status: $Enums.StatusMaintenance
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["maintenanceEquipement"]>
    composites: {}
  }

  type MaintenanceEquipementGetPayload<S extends boolean | null | undefined | MaintenanceEquipementDefaultArgs> = $Result.GetResult<Prisma.$MaintenanceEquipementPayload, S>

  type MaintenanceEquipementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaintenanceEquipementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaintenanceEquipementCountAggregateInputType | true
    }

  export interface MaintenanceEquipementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaintenanceEquipement'], meta: { name: 'MaintenanceEquipement' } }
    /**
     * Find zero or one MaintenanceEquipement that matches the filter.
     * @param {MaintenanceEquipementFindUniqueArgs} args - Arguments to find a MaintenanceEquipement
     * @example
     * // Get one MaintenanceEquipement
     * const maintenanceEquipement = await prisma.maintenanceEquipement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaintenanceEquipementFindUniqueArgs>(args: SelectSubset<T, MaintenanceEquipementFindUniqueArgs<ExtArgs>>): Prisma__MaintenanceEquipementClient<$Result.GetResult<Prisma.$MaintenanceEquipementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MaintenanceEquipement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MaintenanceEquipementFindUniqueOrThrowArgs} args - Arguments to find a MaintenanceEquipement
     * @example
     * // Get one MaintenanceEquipement
     * const maintenanceEquipement = await prisma.maintenanceEquipement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaintenanceEquipementFindUniqueOrThrowArgs>(args: SelectSubset<T, MaintenanceEquipementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaintenanceEquipementClient<$Result.GetResult<Prisma.$MaintenanceEquipementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MaintenanceEquipement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceEquipementFindFirstArgs} args - Arguments to find a MaintenanceEquipement
     * @example
     * // Get one MaintenanceEquipement
     * const maintenanceEquipement = await prisma.maintenanceEquipement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaintenanceEquipementFindFirstArgs>(args?: SelectSubset<T, MaintenanceEquipementFindFirstArgs<ExtArgs>>): Prisma__MaintenanceEquipementClient<$Result.GetResult<Prisma.$MaintenanceEquipementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MaintenanceEquipement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceEquipementFindFirstOrThrowArgs} args - Arguments to find a MaintenanceEquipement
     * @example
     * // Get one MaintenanceEquipement
     * const maintenanceEquipement = await prisma.maintenanceEquipement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaintenanceEquipementFindFirstOrThrowArgs>(args?: SelectSubset<T, MaintenanceEquipementFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaintenanceEquipementClient<$Result.GetResult<Prisma.$MaintenanceEquipementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MaintenanceEquipements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceEquipementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaintenanceEquipements
     * const maintenanceEquipements = await prisma.maintenanceEquipement.findMany()
     * 
     * // Get first 10 MaintenanceEquipements
     * const maintenanceEquipements = await prisma.maintenanceEquipement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maintenanceEquipementWithIdOnly = await prisma.maintenanceEquipement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaintenanceEquipementFindManyArgs>(args?: SelectSubset<T, MaintenanceEquipementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceEquipementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MaintenanceEquipement.
     * @param {MaintenanceEquipementCreateArgs} args - Arguments to create a MaintenanceEquipement.
     * @example
     * // Create one MaintenanceEquipement
     * const MaintenanceEquipement = await prisma.maintenanceEquipement.create({
     *   data: {
     *     // ... data to create a MaintenanceEquipement
     *   }
     * })
     * 
     */
    create<T extends MaintenanceEquipementCreateArgs>(args: SelectSubset<T, MaintenanceEquipementCreateArgs<ExtArgs>>): Prisma__MaintenanceEquipementClient<$Result.GetResult<Prisma.$MaintenanceEquipementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MaintenanceEquipements.
     * @param {MaintenanceEquipementCreateManyArgs} args - Arguments to create many MaintenanceEquipements.
     * @example
     * // Create many MaintenanceEquipements
     * const maintenanceEquipement = await prisma.maintenanceEquipement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaintenanceEquipementCreateManyArgs>(args?: SelectSubset<T, MaintenanceEquipementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MaintenanceEquipements and returns the data saved in the database.
     * @param {MaintenanceEquipementCreateManyAndReturnArgs} args - Arguments to create many MaintenanceEquipements.
     * @example
     * // Create many MaintenanceEquipements
     * const maintenanceEquipement = await prisma.maintenanceEquipement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MaintenanceEquipements and only return the `id`
     * const maintenanceEquipementWithIdOnly = await prisma.maintenanceEquipement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaintenanceEquipementCreateManyAndReturnArgs>(args?: SelectSubset<T, MaintenanceEquipementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceEquipementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MaintenanceEquipement.
     * @param {MaintenanceEquipementDeleteArgs} args - Arguments to delete one MaintenanceEquipement.
     * @example
     * // Delete one MaintenanceEquipement
     * const MaintenanceEquipement = await prisma.maintenanceEquipement.delete({
     *   where: {
     *     // ... filter to delete one MaintenanceEquipement
     *   }
     * })
     * 
     */
    delete<T extends MaintenanceEquipementDeleteArgs>(args: SelectSubset<T, MaintenanceEquipementDeleteArgs<ExtArgs>>): Prisma__MaintenanceEquipementClient<$Result.GetResult<Prisma.$MaintenanceEquipementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MaintenanceEquipement.
     * @param {MaintenanceEquipementUpdateArgs} args - Arguments to update one MaintenanceEquipement.
     * @example
     * // Update one MaintenanceEquipement
     * const maintenanceEquipement = await prisma.maintenanceEquipement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaintenanceEquipementUpdateArgs>(args: SelectSubset<T, MaintenanceEquipementUpdateArgs<ExtArgs>>): Prisma__MaintenanceEquipementClient<$Result.GetResult<Prisma.$MaintenanceEquipementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MaintenanceEquipements.
     * @param {MaintenanceEquipementDeleteManyArgs} args - Arguments to filter MaintenanceEquipements to delete.
     * @example
     * // Delete a few MaintenanceEquipements
     * const { count } = await prisma.maintenanceEquipement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaintenanceEquipementDeleteManyArgs>(args?: SelectSubset<T, MaintenanceEquipementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenanceEquipements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceEquipementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaintenanceEquipements
     * const maintenanceEquipement = await prisma.maintenanceEquipement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaintenanceEquipementUpdateManyArgs>(args: SelectSubset<T, MaintenanceEquipementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MaintenanceEquipement.
     * @param {MaintenanceEquipementUpsertArgs} args - Arguments to update or create a MaintenanceEquipement.
     * @example
     * // Update or create a MaintenanceEquipement
     * const maintenanceEquipement = await prisma.maintenanceEquipement.upsert({
     *   create: {
     *     // ... data to create a MaintenanceEquipement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaintenanceEquipement we want to update
     *   }
     * })
     */
    upsert<T extends MaintenanceEquipementUpsertArgs>(args: SelectSubset<T, MaintenanceEquipementUpsertArgs<ExtArgs>>): Prisma__MaintenanceEquipementClient<$Result.GetResult<Prisma.$MaintenanceEquipementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MaintenanceEquipements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceEquipementCountArgs} args - Arguments to filter MaintenanceEquipements to count.
     * @example
     * // Count the number of MaintenanceEquipements
     * const count = await prisma.maintenanceEquipement.count({
     *   where: {
     *     // ... the filter for the MaintenanceEquipements we want to count
     *   }
     * })
    **/
    count<T extends MaintenanceEquipementCountArgs>(
      args?: Subset<T, MaintenanceEquipementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaintenanceEquipementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaintenanceEquipement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceEquipementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaintenanceEquipementAggregateArgs>(args: Subset<T, MaintenanceEquipementAggregateArgs>): Prisma.PrismaPromise<GetMaintenanceEquipementAggregateType<T>>

    /**
     * Group by MaintenanceEquipement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceEquipementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaintenanceEquipementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaintenanceEquipementGroupByArgs['orderBy'] }
        : { orderBy?: MaintenanceEquipementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaintenanceEquipementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintenanceEquipementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaintenanceEquipement model
   */
  readonly fields: MaintenanceEquipementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaintenanceEquipement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaintenanceEquipementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    equipement<T extends EquipementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EquipementDefaultArgs<ExtArgs>>): Prisma__EquipementClient<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaintenanceEquipement model
   */ 
  interface MaintenanceEquipementFieldRefs {
    readonly id: FieldRef<"MaintenanceEquipement", 'String'>
    readonly equipementId: FieldRef<"MaintenanceEquipement", 'String'>
    readonly type: FieldRef<"MaintenanceEquipement", 'TypeMaintenance'>
    readonly dateDebut: FieldRef<"MaintenanceEquipement", 'DateTime'>
    readonly dateFin: FieldRef<"MaintenanceEquipement", 'DateTime'>
    readonly technicienId: FieldRef<"MaintenanceEquipement", 'String'>
    readonly description: FieldRef<"MaintenanceEquipement", 'String'>
    readonly coutReel: FieldRef<"MaintenanceEquipement", 'Float'>
    readonly status: FieldRef<"MaintenanceEquipement", 'StatusMaintenance'>
    readonly createdAt: FieldRef<"MaintenanceEquipement", 'DateTime'>
    readonly updatedAt: FieldRef<"MaintenanceEquipement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MaintenanceEquipement findUnique
   */
  export type MaintenanceEquipementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceEquipement
     */
    select?: MaintenanceEquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceEquipementInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceEquipement to fetch.
     */
    where: MaintenanceEquipementWhereUniqueInput
  }

  /**
   * MaintenanceEquipement findUniqueOrThrow
   */
  export type MaintenanceEquipementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceEquipement
     */
    select?: MaintenanceEquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceEquipementInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceEquipement to fetch.
     */
    where: MaintenanceEquipementWhereUniqueInput
  }

  /**
   * MaintenanceEquipement findFirst
   */
  export type MaintenanceEquipementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceEquipement
     */
    select?: MaintenanceEquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceEquipementInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceEquipement to fetch.
     */
    where?: MaintenanceEquipementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceEquipements to fetch.
     */
    orderBy?: MaintenanceEquipementOrderByWithRelationInput | MaintenanceEquipementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceEquipements.
     */
    cursor?: MaintenanceEquipementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceEquipements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceEquipements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceEquipements.
     */
    distinct?: MaintenanceEquipementScalarFieldEnum | MaintenanceEquipementScalarFieldEnum[]
  }

  /**
   * MaintenanceEquipement findFirstOrThrow
   */
  export type MaintenanceEquipementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceEquipement
     */
    select?: MaintenanceEquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceEquipementInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceEquipement to fetch.
     */
    where?: MaintenanceEquipementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceEquipements to fetch.
     */
    orderBy?: MaintenanceEquipementOrderByWithRelationInput | MaintenanceEquipementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceEquipements.
     */
    cursor?: MaintenanceEquipementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceEquipements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceEquipements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceEquipements.
     */
    distinct?: MaintenanceEquipementScalarFieldEnum | MaintenanceEquipementScalarFieldEnum[]
  }

  /**
   * MaintenanceEquipement findMany
   */
  export type MaintenanceEquipementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceEquipement
     */
    select?: MaintenanceEquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceEquipementInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceEquipements to fetch.
     */
    where?: MaintenanceEquipementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceEquipements to fetch.
     */
    orderBy?: MaintenanceEquipementOrderByWithRelationInput | MaintenanceEquipementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaintenanceEquipements.
     */
    cursor?: MaintenanceEquipementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceEquipements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceEquipements.
     */
    skip?: number
    distinct?: MaintenanceEquipementScalarFieldEnum | MaintenanceEquipementScalarFieldEnum[]
  }

  /**
   * MaintenanceEquipement create
   */
  export type MaintenanceEquipementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceEquipement
     */
    select?: MaintenanceEquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceEquipementInclude<ExtArgs> | null
    /**
     * The data needed to create a MaintenanceEquipement.
     */
    data: XOR<MaintenanceEquipementCreateInput, MaintenanceEquipementUncheckedCreateInput>
  }

  /**
   * MaintenanceEquipement createMany
   */
  export type MaintenanceEquipementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaintenanceEquipements.
     */
    data: MaintenanceEquipementCreateManyInput | MaintenanceEquipementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaintenanceEquipement createManyAndReturn
   */
  export type MaintenanceEquipementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceEquipement
     */
    select?: MaintenanceEquipementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MaintenanceEquipements.
     */
    data: MaintenanceEquipementCreateManyInput | MaintenanceEquipementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceEquipementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaintenanceEquipement update
   */
  export type MaintenanceEquipementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceEquipement
     */
    select?: MaintenanceEquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceEquipementInclude<ExtArgs> | null
    /**
     * The data needed to update a MaintenanceEquipement.
     */
    data: XOR<MaintenanceEquipementUpdateInput, MaintenanceEquipementUncheckedUpdateInput>
    /**
     * Choose, which MaintenanceEquipement to update.
     */
    where: MaintenanceEquipementWhereUniqueInput
  }

  /**
   * MaintenanceEquipement updateMany
   */
  export type MaintenanceEquipementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaintenanceEquipements.
     */
    data: XOR<MaintenanceEquipementUpdateManyMutationInput, MaintenanceEquipementUncheckedUpdateManyInput>
    /**
     * Filter which MaintenanceEquipements to update
     */
    where?: MaintenanceEquipementWhereInput
  }

  /**
   * MaintenanceEquipement upsert
   */
  export type MaintenanceEquipementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceEquipement
     */
    select?: MaintenanceEquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceEquipementInclude<ExtArgs> | null
    /**
     * The filter to search for the MaintenanceEquipement to update in case it exists.
     */
    where: MaintenanceEquipementWhereUniqueInput
    /**
     * In case the MaintenanceEquipement found by the `where` argument doesn't exist, create a new MaintenanceEquipement with this data.
     */
    create: XOR<MaintenanceEquipementCreateInput, MaintenanceEquipementUncheckedCreateInput>
    /**
     * In case the MaintenanceEquipement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaintenanceEquipementUpdateInput, MaintenanceEquipementUncheckedUpdateInput>
  }

  /**
   * MaintenanceEquipement delete
   */
  export type MaintenanceEquipementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceEquipement
     */
    select?: MaintenanceEquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceEquipementInclude<ExtArgs> | null
    /**
     * Filter which MaintenanceEquipement to delete.
     */
    where: MaintenanceEquipementWhereUniqueInput
  }

  /**
   * MaintenanceEquipement deleteMany
   */
  export type MaintenanceEquipementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceEquipements to delete
     */
    where?: MaintenanceEquipementWhereInput
  }

  /**
   * MaintenanceEquipement without action
   */
  export type MaintenanceEquipementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceEquipement
     */
    select?: MaintenanceEquipementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceEquipementInclude<ExtArgs> | null
  }


  /**
   * Model Reception
   */

  export type AggregateReception = {
    _count: ReceptionCountAggregateOutputType | null
    _min: ReceptionMinAggregateOutputType | null
    _max: ReceptionMaxAggregateOutputType | null
  }

  export type ReceptionMinAggregateOutputType = {
    id: string | null
    numero: string | null
    bonCommandeId: string | null
    fournisseurId: string | null
    dateReception: Date | null
    status: $Enums.StatusReception | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReceptionMaxAggregateOutputType = {
    id: string | null
    numero: string | null
    bonCommandeId: string | null
    fournisseurId: string | null
    dateReception: Date | null
    status: $Enums.StatusReception | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReceptionCountAggregateOutputType = {
    id: number
    numero: number
    bonCommandeId: number
    fournisseurId: number
    dateReception: number
    status: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReceptionMinAggregateInputType = {
    id?: true
    numero?: true
    bonCommandeId?: true
    fournisseurId?: true
    dateReception?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReceptionMaxAggregateInputType = {
    id?: true
    numero?: true
    bonCommandeId?: true
    fournisseurId?: true
    dateReception?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReceptionCountAggregateInputType = {
    id?: true
    numero?: true
    bonCommandeId?: true
    fournisseurId?: true
    dateReception?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReceptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reception to aggregate.
     */
    where?: ReceptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receptions to fetch.
     */
    orderBy?: ReceptionOrderByWithRelationInput | ReceptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReceptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Receptions
    **/
    _count?: true | ReceptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReceptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReceptionMaxAggregateInputType
  }

  export type GetReceptionAggregateType<T extends ReceptionAggregateArgs> = {
        [P in keyof T & keyof AggregateReception]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReception[P]>
      : GetScalarType<T[P], AggregateReception[P]>
  }




  export type ReceptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceptionWhereInput
    orderBy?: ReceptionOrderByWithAggregationInput | ReceptionOrderByWithAggregationInput[]
    by: ReceptionScalarFieldEnum[] | ReceptionScalarFieldEnum
    having?: ReceptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReceptionCountAggregateInputType | true
    _min?: ReceptionMinAggregateInputType
    _max?: ReceptionMaxAggregateInputType
  }

  export type ReceptionGroupByOutputType = {
    id: string
    numero: string
    bonCommandeId: string
    fournisseurId: string | null
    dateReception: Date
    status: $Enums.StatusReception
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ReceptionCountAggregateOutputType | null
    _min: ReceptionMinAggregateOutputType | null
    _max: ReceptionMaxAggregateOutputType | null
  }

  type GetReceptionGroupByPayload<T extends ReceptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReceptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReceptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReceptionGroupByOutputType[P]>
            : GetScalarType<T[P], ReceptionGroupByOutputType[P]>
        }
      >
    >


  export type ReceptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numero?: boolean
    bonCommandeId?: boolean
    fournisseurId?: boolean
    dateReception?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lignes?: boolean | Reception$lignesArgs<ExtArgs>
    _count?: boolean | ReceptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reception"]>

  export type ReceptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numero?: boolean
    bonCommandeId?: boolean
    fournisseurId?: boolean
    dateReception?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["reception"]>

  export type ReceptionSelectScalar = {
    id?: boolean
    numero?: boolean
    bonCommandeId?: boolean
    fournisseurId?: boolean
    dateReception?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReceptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lignes?: boolean | Reception$lignesArgs<ExtArgs>
    _count?: boolean | ReceptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReceptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ReceptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reception"
    objects: {
      lignes: Prisma.$LigneReceptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      numero: string
      bonCommandeId: string
      fournisseurId: string | null
      dateReception: Date
      status: $Enums.StatusReception
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["reception"]>
    composites: {}
  }

  type ReceptionGetPayload<S extends boolean | null | undefined | ReceptionDefaultArgs> = $Result.GetResult<Prisma.$ReceptionPayload, S>

  type ReceptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReceptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReceptionCountAggregateInputType | true
    }

  export interface ReceptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reception'], meta: { name: 'Reception' } }
    /**
     * Find zero or one Reception that matches the filter.
     * @param {ReceptionFindUniqueArgs} args - Arguments to find a Reception
     * @example
     * // Get one Reception
     * const reception = await prisma.reception.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReceptionFindUniqueArgs>(args: SelectSubset<T, ReceptionFindUniqueArgs<ExtArgs>>): Prisma__ReceptionClient<$Result.GetResult<Prisma.$ReceptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Reception that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReceptionFindUniqueOrThrowArgs} args - Arguments to find a Reception
     * @example
     * // Get one Reception
     * const reception = await prisma.reception.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReceptionFindUniqueOrThrowArgs>(args: SelectSubset<T, ReceptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReceptionClient<$Result.GetResult<Prisma.$ReceptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Reception that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionFindFirstArgs} args - Arguments to find a Reception
     * @example
     * // Get one Reception
     * const reception = await prisma.reception.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReceptionFindFirstArgs>(args?: SelectSubset<T, ReceptionFindFirstArgs<ExtArgs>>): Prisma__ReceptionClient<$Result.GetResult<Prisma.$ReceptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Reception that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionFindFirstOrThrowArgs} args - Arguments to find a Reception
     * @example
     * // Get one Reception
     * const reception = await prisma.reception.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReceptionFindFirstOrThrowArgs>(args?: SelectSubset<T, ReceptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReceptionClient<$Result.GetResult<Prisma.$ReceptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Receptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Receptions
     * const receptions = await prisma.reception.findMany()
     * 
     * // Get first 10 Receptions
     * const receptions = await prisma.reception.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const receptionWithIdOnly = await prisma.reception.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReceptionFindManyArgs>(args?: SelectSubset<T, ReceptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Reception.
     * @param {ReceptionCreateArgs} args - Arguments to create a Reception.
     * @example
     * // Create one Reception
     * const Reception = await prisma.reception.create({
     *   data: {
     *     // ... data to create a Reception
     *   }
     * })
     * 
     */
    create<T extends ReceptionCreateArgs>(args: SelectSubset<T, ReceptionCreateArgs<ExtArgs>>): Prisma__ReceptionClient<$Result.GetResult<Prisma.$ReceptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Receptions.
     * @param {ReceptionCreateManyArgs} args - Arguments to create many Receptions.
     * @example
     * // Create many Receptions
     * const reception = await prisma.reception.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReceptionCreateManyArgs>(args?: SelectSubset<T, ReceptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Receptions and returns the data saved in the database.
     * @param {ReceptionCreateManyAndReturnArgs} args - Arguments to create many Receptions.
     * @example
     * // Create many Receptions
     * const reception = await prisma.reception.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Receptions and only return the `id`
     * const receptionWithIdOnly = await prisma.reception.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReceptionCreateManyAndReturnArgs>(args?: SelectSubset<T, ReceptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Reception.
     * @param {ReceptionDeleteArgs} args - Arguments to delete one Reception.
     * @example
     * // Delete one Reception
     * const Reception = await prisma.reception.delete({
     *   where: {
     *     // ... filter to delete one Reception
     *   }
     * })
     * 
     */
    delete<T extends ReceptionDeleteArgs>(args: SelectSubset<T, ReceptionDeleteArgs<ExtArgs>>): Prisma__ReceptionClient<$Result.GetResult<Prisma.$ReceptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Reception.
     * @param {ReceptionUpdateArgs} args - Arguments to update one Reception.
     * @example
     * // Update one Reception
     * const reception = await prisma.reception.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReceptionUpdateArgs>(args: SelectSubset<T, ReceptionUpdateArgs<ExtArgs>>): Prisma__ReceptionClient<$Result.GetResult<Prisma.$ReceptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Receptions.
     * @param {ReceptionDeleteManyArgs} args - Arguments to filter Receptions to delete.
     * @example
     * // Delete a few Receptions
     * const { count } = await prisma.reception.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReceptionDeleteManyArgs>(args?: SelectSubset<T, ReceptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Receptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Receptions
     * const reception = await prisma.reception.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReceptionUpdateManyArgs>(args: SelectSubset<T, ReceptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reception.
     * @param {ReceptionUpsertArgs} args - Arguments to update or create a Reception.
     * @example
     * // Update or create a Reception
     * const reception = await prisma.reception.upsert({
     *   create: {
     *     // ... data to create a Reception
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reception we want to update
     *   }
     * })
     */
    upsert<T extends ReceptionUpsertArgs>(args: SelectSubset<T, ReceptionUpsertArgs<ExtArgs>>): Prisma__ReceptionClient<$Result.GetResult<Prisma.$ReceptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Receptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionCountArgs} args - Arguments to filter Receptions to count.
     * @example
     * // Count the number of Receptions
     * const count = await prisma.reception.count({
     *   where: {
     *     // ... the filter for the Receptions we want to count
     *   }
     * })
    **/
    count<T extends ReceptionCountArgs>(
      args?: Subset<T, ReceptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReceptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reception.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReceptionAggregateArgs>(args: Subset<T, ReceptionAggregateArgs>): Prisma.PrismaPromise<GetReceptionAggregateType<T>>

    /**
     * Group by Reception.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReceptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReceptionGroupByArgs['orderBy'] }
        : { orderBy?: ReceptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReceptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReceptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reception model
   */
  readonly fields: ReceptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reception.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReceptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lignes<T extends Reception$lignesArgs<ExtArgs> = {}>(args?: Subset<T, Reception$lignesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneReceptionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reception model
   */ 
  interface ReceptionFieldRefs {
    readonly id: FieldRef<"Reception", 'String'>
    readonly numero: FieldRef<"Reception", 'String'>
    readonly bonCommandeId: FieldRef<"Reception", 'String'>
    readonly fournisseurId: FieldRef<"Reception", 'String'>
    readonly dateReception: FieldRef<"Reception", 'DateTime'>
    readonly status: FieldRef<"Reception", 'StatusReception'>
    readonly notes: FieldRef<"Reception", 'String'>
    readonly createdAt: FieldRef<"Reception", 'DateTime'>
    readonly updatedAt: FieldRef<"Reception", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reception findUnique
   */
  export type ReceptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reception
     */
    select?: ReceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionInclude<ExtArgs> | null
    /**
     * Filter, which Reception to fetch.
     */
    where: ReceptionWhereUniqueInput
  }

  /**
   * Reception findUniqueOrThrow
   */
  export type ReceptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reception
     */
    select?: ReceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionInclude<ExtArgs> | null
    /**
     * Filter, which Reception to fetch.
     */
    where: ReceptionWhereUniqueInput
  }

  /**
   * Reception findFirst
   */
  export type ReceptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reception
     */
    select?: ReceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionInclude<ExtArgs> | null
    /**
     * Filter, which Reception to fetch.
     */
    where?: ReceptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receptions to fetch.
     */
    orderBy?: ReceptionOrderByWithRelationInput | ReceptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Receptions.
     */
    cursor?: ReceptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Receptions.
     */
    distinct?: ReceptionScalarFieldEnum | ReceptionScalarFieldEnum[]
  }

  /**
   * Reception findFirstOrThrow
   */
  export type ReceptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reception
     */
    select?: ReceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionInclude<ExtArgs> | null
    /**
     * Filter, which Reception to fetch.
     */
    where?: ReceptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receptions to fetch.
     */
    orderBy?: ReceptionOrderByWithRelationInput | ReceptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Receptions.
     */
    cursor?: ReceptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Receptions.
     */
    distinct?: ReceptionScalarFieldEnum | ReceptionScalarFieldEnum[]
  }

  /**
   * Reception findMany
   */
  export type ReceptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reception
     */
    select?: ReceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionInclude<ExtArgs> | null
    /**
     * Filter, which Receptions to fetch.
     */
    where?: ReceptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receptions to fetch.
     */
    orderBy?: ReceptionOrderByWithRelationInput | ReceptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Receptions.
     */
    cursor?: ReceptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receptions.
     */
    skip?: number
    distinct?: ReceptionScalarFieldEnum | ReceptionScalarFieldEnum[]
  }

  /**
   * Reception create
   */
  export type ReceptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reception
     */
    select?: ReceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Reception.
     */
    data: XOR<ReceptionCreateInput, ReceptionUncheckedCreateInput>
  }

  /**
   * Reception createMany
   */
  export type ReceptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Receptions.
     */
    data: ReceptionCreateManyInput | ReceptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reception createManyAndReturn
   */
  export type ReceptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reception
     */
    select?: ReceptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Receptions.
     */
    data: ReceptionCreateManyInput | ReceptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reception update
   */
  export type ReceptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reception
     */
    select?: ReceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Reception.
     */
    data: XOR<ReceptionUpdateInput, ReceptionUncheckedUpdateInput>
    /**
     * Choose, which Reception to update.
     */
    where: ReceptionWhereUniqueInput
  }

  /**
   * Reception updateMany
   */
  export type ReceptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Receptions.
     */
    data: XOR<ReceptionUpdateManyMutationInput, ReceptionUncheckedUpdateManyInput>
    /**
     * Filter which Receptions to update
     */
    where?: ReceptionWhereInput
  }

  /**
   * Reception upsert
   */
  export type ReceptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reception
     */
    select?: ReceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Reception to update in case it exists.
     */
    where: ReceptionWhereUniqueInput
    /**
     * In case the Reception found by the `where` argument doesn't exist, create a new Reception with this data.
     */
    create: XOR<ReceptionCreateInput, ReceptionUncheckedCreateInput>
    /**
     * In case the Reception was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReceptionUpdateInput, ReceptionUncheckedUpdateInput>
  }

  /**
   * Reception delete
   */
  export type ReceptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reception
     */
    select?: ReceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionInclude<ExtArgs> | null
    /**
     * Filter which Reception to delete.
     */
    where: ReceptionWhereUniqueInput
  }

  /**
   * Reception deleteMany
   */
  export type ReceptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Receptions to delete
     */
    where?: ReceptionWhereInput
  }

  /**
   * Reception.lignes
   */
  export type Reception$lignesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneReception
     */
    select?: LigneReceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneReceptionInclude<ExtArgs> | null
    where?: LigneReceptionWhereInput
    orderBy?: LigneReceptionOrderByWithRelationInput | LigneReceptionOrderByWithRelationInput[]
    cursor?: LigneReceptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LigneReceptionScalarFieldEnum | LigneReceptionScalarFieldEnum[]
  }

  /**
   * Reception without action
   */
  export type ReceptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reception
     */
    select?: ReceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionInclude<ExtArgs> | null
  }


  /**
   * Model LigneReception
   */

  export type AggregateLigneReception = {
    _count: LigneReceptionCountAggregateOutputType | null
    _avg: LigneReceptionAvgAggregateOutputType | null
    _sum: LigneReceptionSumAggregateOutputType | null
    _min: LigneReceptionMinAggregateOutputType | null
    _max: LigneReceptionMaxAggregateOutputType | null
  }

  export type LigneReceptionAvgAggregateOutputType = {
    quantitePrev: number | null
    quantiteRecue: number | null
    prixUnitaire: number | null
    tva: number | null
    ecart: number | null
  }

  export type LigneReceptionSumAggregateOutputType = {
    quantitePrev: number | null
    quantiteRecue: number | null
    prixUnitaire: number | null
    tva: number | null
    ecart: number | null
  }

  export type LigneReceptionMinAggregateOutputType = {
    id: string | null
    receptionId: string | null
    articleId: string | null
    designation: string | null
    quantitePrev: number | null
    quantiteRecue: number | null
    prixUnitaire: number | null
    tva: number | null
    ecart: number | null
    notes: string | null
    createdAt: Date | null
  }

  export type LigneReceptionMaxAggregateOutputType = {
    id: string | null
    receptionId: string | null
    articleId: string | null
    designation: string | null
    quantitePrev: number | null
    quantiteRecue: number | null
    prixUnitaire: number | null
    tva: number | null
    ecart: number | null
    notes: string | null
    createdAt: Date | null
  }

  export type LigneReceptionCountAggregateOutputType = {
    id: number
    receptionId: number
    articleId: number
    designation: number
    quantitePrev: number
    quantiteRecue: number
    prixUnitaire: number
    tva: number
    ecart: number
    notes: number
    createdAt: number
    _all: number
  }


  export type LigneReceptionAvgAggregateInputType = {
    quantitePrev?: true
    quantiteRecue?: true
    prixUnitaire?: true
    tva?: true
    ecart?: true
  }

  export type LigneReceptionSumAggregateInputType = {
    quantitePrev?: true
    quantiteRecue?: true
    prixUnitaire?: true
    tva?: true
    ecart?: true
  }

  export type LigneReceptionMinAggregateInputType = {
    id?: true
    receptionId?: true
    articleId?: true
    designation?: true
    quantitePrev?: true
    quantiteRecue?: true
    prixUnitaire?: true
    tva?: true
    ecart?: true
    notes?: true
    createdAt?: true
  }

  export type LigneReceptionMaxAggregateInputType = {
    id?: true
    receptionId?: true
    articleId?: true
    designation?: true
    quantitePrev?: true
    quantiteRecue?: true
    prixUnitaire?: true
    tva?: true
    ecart?: true
    notes?: true
    createdAt?: true
  }

  export type LigneReceptionCountAggregateInputType = {
    id?: true
    receptionId?: true
    articleId?: true
    designation?: true
    quantitePrev?: true
    quantiteRecue?: true
    prixUnitaire?: true
    tva?: true
    ecart?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type LigneReceptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LigneReception to aggregate.
     */
    where?: LigneReceptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneReceptions to fetch.
     */
    orderBy?: LigneReceptionOrderByWithRelationInput | LigneReceptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LigneReceptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneReceptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneReceptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LigneReceptions
    **/
    _count?: true | LigneReceptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LigneReceptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LigneReceptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LigneReceptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LigneReceptionMaxAggregateInputType
  }

  export type GetLigneReceptionAggregateType<T extends LigneReceptionAggregateArgs> = {
        [P in keyof T & keyof AggregateLigneReception]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLigneReception[P]>
      : GetScalarType<T[P], AggregateLigneReception[P]>
  }




  export type LigneReceptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LigneReceptionWhereInput
    orderBy?: LigneReceptionOrderByWithAggregationInput | LigneReceptionOrderByWithAggregationInput[]
    by: LigneReceptionScalarFieldEnum[] | LigneReceptionScalarFieldEnum
    having?: LigneReceptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LigneReceptionCountAggregateInputType | true
    _avg?: LigneReceptionAvgAggregateInputType
    _sum?: LigneReceptionSumAggregateInputType
    _min?: LigneReceptionMinAggregateInputType
    _max?: LigneReceptionMaxAggregateInputType
  }

  export type LigneReceptionGroupByOutputType = {
    id: string
    receptionId: string
    articleId: string
    designation: string
    quantitePrev: number
    quantiteRecue: number
    prixUnitaire: number
    tva: number | null
    ecart: number
    notes: string | null
    createdAt: Date
    _count: LigneReceptionCountAggregateOutputType | null
    _avg: LigneReceptionAvgAggregateOutputType | null
    _sum: LigneReceptionSumAggregateOutputType | null
    _min: LigneReceptionMinAggregateOutputType | null
    _max: LigneReceptionMaxAggregateOutputType | null
  }

  type GetLigneReceptionGroupByPayload<T extends LigneReceptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LigneReceptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LigneReceptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LigneReceptionGroupByOutputType[P]>
            : GetScalarType<T[P], LigneReceptionGroupByOutputType[P]>
        }
      >
    >


  export type LigneReceptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receptionId?: boolean
    articleId?: boolean
    designation?: boolean
    quantitePrev?: boolean
    quantiteRecue?: boolean
    prixUnitaire?: boolean
    tva?: boolean
    ecart?: boolean
    notes?: boolean
    createdAt?: boolean
    reception?: boolean | ReceptionDefaultArgs<ExtArgs>
    article?: boolean | ArticleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ligneReception"]>

  export type LigneReceptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receptionId?: boolean
    articleId?: boolean
    designation?: boolean
    quantitePrev?: boolean
    quantiteRecue?: boolean
    prixUnitaire?: boolean
    tva?: boolean
    ecart?: boolean
    notes?: boolean
    createdAt?: boolean
    reception?: boolean | ReceptionDefaultArgs<ExtArgs>
    article?: boolean | ArticleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ligneReception"]>

  export type LigneReceptionSelectScalar = {
    id?: boolean
    receptionId?: boolean
    articleId?: boolean
    designation?: boolean
    quantitePrev?: boolean
    quantiteRecue?: boolean
    prixUnitaire?: boolean
    tva?: boolean
    ecart?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type LigneReceptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reception?: boolean | ReceptionDefaultArgs<ExtArgs>
    article?: boolean | ArticleDefaultArgs<ExtArgs>
  }
  export type LigneReceptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reception?: boolean | ReceptionDefaultArgs<ExtArgs>
    article?: boolean | ArticleDefaultArgs<ExtArgs>
  }

  export type $LigneReceptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LigneReception"
    objects: {
      reception: Prisma.$ReceptionPayload<ExtArgs>
      article: Prisma.$ArticlePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      receptionId: string
      articleId: string
      designation: string
      quantitePrev: number
      quantiteRecue: number
      prixUnitaire: number
      tva: number | null
      ecart: number
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["ligneReception"]>
    composites: {}
  }

  type LigneReceptionGetPayload<S extends boolean | null | undefined | LigneReceptionDefaultArgs> = $Result.GetResult<Prisma.$LigneReceptionPayload, S>

  type LigneReceptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LigneReceptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LigneReceptionCountAggregateInputType | true
    }

  export interface LigneReceptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LigneReception'], meta: { name: 'LigneReception' } }
    /**
     * Find zero or one LigneReception that matches the filter.
     * @param {LigneReceptionFindUniqueArgs} args - Arguments to find a LigneReception
     * @example
     * // Get one LigneReception
     * const ligneReception = await prisma.ligneReception.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LigneReceptionFindUniqueArgs>(args: SelectSubset<T, LigneReceptionFindUniqueArgs<ExtArgs>>): Prisma__LigneReceptionClient<$Result.GetResult<Prisma.$LigneReceptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LigneReception that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LigneReceptionFindUniqueOrThrowArgs} args - Arguments to find a LigneReception
     * @example
     * // Get one LigneReception
     * const ligneReception = await prisma.ligneReception.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LigneReceptionFindUniqueOrThrowArgs>(args: SelectSubset<T, LigneReceptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LigneReceptionClient<$Result.GetResult<Prisma.$LigneReceptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LigneReception that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneReceptionFindFirstArgs} args - Arguments to find a LigneReception
     * @example
     * // Get one LigneReception
     * const ligneReception = await prisma.ligneReception.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LigneReceptionFindFirstArgs>(args?: SelectSubset<T, LigneReceptionFindFirstArgs<ExtArgs>>): Prisma__LigneReceptionClient<$Result.GetResult<Prisma.$LigneReceptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LigneReception that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneReceptionFindFirstOrThrowArgs} args - Arguments to find a LigneReception
     * @example
     * // Get one LigneReception
     * const ligneReception = await prisma.ligneReception.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LigneReceptionFindFirstOrThrowArgs>(args?: SelectSubset<T, LigneReceptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__LigneReceptionClient<$Result.GetResult<Prisma.$LigneReceptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LigneReceptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneReceptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LigneReceptions
     * const ligneReceptions = await prisma.ligneReception.findMany()
     * 
     * // Get first 10 LigneReceptions
     * const ligneReceptions = await prisma.ligneReception.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ligneReceptionWithIdOnly = await prisma.ligneReception.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LigneReceptionFindManyArgs>(args?: SelectSubset<T, LigneReceptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneReceptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LigneReception.
     * @param {LigneReceptionCreateArgs} args - Arguments to create a LigneReception.
     * @example
     * // Create one LigneReception
     * const LigneReception = await prisma.ligneReception.create({
     *   data: {
     *     // ... data to create a LigneReception
     *   }
     * })
     * 
     */
    create<T extends LigneReceptionCreateArgs>(args: SelectSubset<T, LigneReceptionCreateArgs<ExtArgs>>): Prisma__LigneReceptionClient<$Result.GetResult<Prisma.$LigneReceptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LigneReceptions.
     * @param {LigneReceptionCreateManyArgs} args - Arguments to create many LigneReceptions.
     * @example
     * // Create many LigneReceptions
     * const ligneReception = await prisma.ligneReception.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LigneReceptionCreateManyArgs>(args?: SelectSubset<T, LigneReceptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LigneReceptions and returns the data saved in the database.
     * @param {LigneReceptionCreateManyAndReturnArgs} args - Arguments to create many LigneReceptions.
     * @example
     * // Create many LigneReceptions
     * const ligneReception = await prisma.ligneReception.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LigneReceptions and only return the `id`
     * const ligneReceptionWithIdOnly = await prisma.ligneReception.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LigneReceptionCreateManyAndReturnArgs>(args?: SelectSubset<T, LigneReceptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneReceptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LigneReception.
     * @param {LigneReceptionDeleteArgs} args - Arguments to delete one LigneReception.
     * @example
     * // Delete one LigneReception
     * const LigneReception = await prisma.ligneReception.delete({
     *   where: {
     *     // ... filter to delete one LigneReception
     *   }
     * })
     * 
     */
    delete<T extends LigneReceptionDeleteArgs>(args: SelectSubset<T, LigneReceptionDeleteArgs<ExtArgs>>): Prisma__LigneReceptionClient<$Result.GetResult<Prisma.$LigneReceptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LigneReception.
     * @param {LigneReceptionUpdateArgs} args - Arguments to update one LigneReception.
     * @example
     * // Update one LigneReception
     * const ligneReception = await prisma.ligneReception.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LigneReceptionUpdateArgs>(args: SelectSubset<T, LigneReceptionUpdateArgs<ExtArgs>>): Prisma__LigneReceptionClient<$Result.GetResult<Prisma.$LigneReceptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LigneReceptions.
     * @param {LigneReceptionDeleteManyArgs} args - Arguments to filter LigneReceptions to delete.
     * @example
     * // Delete a few LigneReceptions
     * const { count } = await prisma.ligneReception.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LigneReceptionDeleteManyArgs>(args?: SelectSubset<T, LigneReceptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LigneReceptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneReceptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LigneReceptions
     * const ligneReception = await prisma.ligneReception.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LigneReceptionUpdateManyArgs>(args: SelectSubset<T, LigneReceptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LigneReception.
     * @param {LigneReceptionUpsertArgs} args - Arguments to update or create a LigneReception.
     * @example
     * // Update or create a LigneReception
     * const ligneReception = await prisma.ligneReception.upsert({
     *   create: {
     *     // ... data to create a LigneReception
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LigneReception we want to update
     *   }
     * })
     */
    upsert<T extends LigneReceptionUpsertArgs>(args: SelectSubset<T, LigneReceptionUpsertArgs<ExtArgs>>): Prisma__LigneReceptionClient<$Result.GetResult<Prisma.$LigneReceptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LigneReceptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneReceptionCountArgs} args - Arguments to filter LigneReceptions to count.
     * @example
     * // Count the number of LigneReceptions
     * const count = await prisma.ligneReception.count({
     *   where: {
     *     // ... the filter for the LigneReceptions we want to count
     *   }
     * })
    **/
    count<T extends LigneReceptionCountArgs>(
      args?: Subset<T, LigneReceptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LigneReceptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LigneReception.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneReceptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LigneReceptionAggregateArgs>(args: Subset<T, LigneReceptionAggregateArgs>): Prisma.PrismaPromise<GetLigneReceptionAggregateType<T>>

    /**
     * Group by LigneReception.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneReceptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LigneReceptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LigneReceptionGroupByArgs['orderBy'] }
        : { orderBy?: LigneReceptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LigneReceptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLigneReceptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LigneReception model
   */
  readonly fields: LigneReceptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LigneReception.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LigneReceptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reception<T extends ReceptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReceptionDefaultArgs<ExtArgs>>): Prisma__ReceptionClient<$Result.GetResult<Prisma.$ReceptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    article<T extends ArticleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArticleDefaultArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LigneReception model
   */ 
  interface LigneReceptionFieldRefs {
    readonly id: FieldRef<"LigneReception", 'String'>
    readonly receptionId: FieldRef<"LigneReception", 'String'>
    readonly articleId: FieldRef<"LigneReception", 'String'>
    readonly designation: FieldRef<"LigneReception", 'String'>
    readonly quantitePrev: FieldRef<"LigneReception", 'Float'>
    readonly quantiteRecue: FieldRef<"LigneReception", 'Float'>
    readonly prixUnitaire: FieldRef<"LigneReception", 'Float'>
    readonly tva: FieldRef<"LigneReception", 'Float'>
    readonly ecart: FieldRef<"LigneReception", 'Float'>
    readonly notes: FieldRef<"LigneReception", 'String'>
    readonly createdAt: FieldRef<"LigneReception", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LigneReception findUnique
   */
  export type LigneReceptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneReception
     */
    select?: LigneReceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneReceptionInclude<ExtArgs> | null
    /**
     * Filter, which LigneReception to fetch.
     */
    where: LigneReceptionWhereUniqueInput
  }

  /**
   * LigneReception findUniqueOrThrow
   */
  export type LigneReceptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneReception
     */
    select?: LigneReceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneReceptionInclude<ExtArgs> | null
    /**
     * Filter, which LigneReception to fetch.
     */
    where: LigneReceptionWhereUniqueInput
  }

  /**
   * LigneReception findFirst
   */
  export type LigneReceptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneReception
     */
    select?: LigneReceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneReceptionInclude<ExtArgs> | null
    /**
     * Filter, which LigneReception to fetch.
     */
    where?: LigneReceptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneReceptions to fetch.
     */
    orderBy?: LigneReceptionOrderByWithRelationInput | LigneReceptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LigneReceptions.
     */
    cursor?: LigneReceptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneReceptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneReceptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LigneReceptions.
     */
    distinct?: LigneReceptionScalarFieldEnum | LigneReceptionScalarFieldEnum[]
  }

  /**
   * LigneReception findFirstOrThrow
   */
  export type LigneReceptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneReception
     */
    select?: LigneReceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneReceptionInclude<ExtArgs> | null
    /**
     * Filter, which LigneReception to fetch.
     */
    where?: LigneReceptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneReceptions to fetch.
     */
    orderBy?: LigneReceptionOrderByWithRelationInput | LigneReceptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LigneReceptions.
     */
    cursor?: LigneReceptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneReceptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneReceptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LigneReceptions.
     */
    distinct?: LigneReceptionScalarFieldEnum | LigneReceptionScalarFieldEnum[]
  }

  /**
   * LigneReception findMany
   */
  export type LigneReceptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneReception
     */
    select?: LigneReceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneReceptionInclude<ExtArgs> | null
    /**
     * Filter, which LigneReceptions to fetch.
     */
    where?: LigneReceptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneReceptions to fetch.
     */
    orderBy?: LigneReceptionOrderByWithRelationInput | LigneReceptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LigneReceptions.
     */
    cursor?: LigneReceptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneReceptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneReceptions.
     */
    skip?: number
    distinct?: LigneReceptionScalarFieldEnum | LigneReceptionScalarFieldEnum[]
  }

  /**
   * LigneReception create
   */
  export type LigneReceptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneReception
     */
    select?: LigneReceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneReceptionInclude<ExtArgs> | null
    /**
     * The data needed to create a LigneReception.
     */
    data: XOR<LigneReceptionCreateInput, LigneReceptionUncheckedCreateInput>
  }

  /**
   * LigneReception createMany
   */
  export type LigneReceptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LigneReceptions.
     */
    data: LigneReceptionCreateManyInput | LigneReceptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LigneReception createManyAndReturn
   */
  export type LigneReceptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneReception
     */
    select?: LigneReceptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LigneReceptions.
     */
    data: LigneReceptionCreateManyInput | LigneReceptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneReceptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LigneReception update
   */
  export type LigneReceptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneReception
     */
    select?: LigneReceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneReceptionInclude<ExtArgs> | null
    /**
     * The data needed to update a LigneReception.
     */
    data: XOR<LigneReceptionUpdateInput, LigneReceptionUncheckedUpdateInput>
    /**
     * Choose, which LigneReception to update.
     */
    where: LigneReceptionWhereUniqueInput
  }

  /**
   * LigneReception updateMany
   */
  export type LigneReceptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LigneReceptions.
     */
    data: XOR<LigneReceptionUpdateManyMutationInput, LigneReceptionUncheckedUpdateManyInput>
    /**
     * Filter which LigneReceptions to update
     */
    where?: LigneReceptionWhereInput
  }

  /**
   * LigneReception upsert
   */
  export type LigneReceptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneReception
     */
    select?: LigneReceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneReceptionInclude<ExtArgs> | null
    /**
     * The filter to search for the LigneReception to update in case it exists.
     */
    where: LigneReceptionWhereUniqueInput
    /**
     * In case the LigneReception found by the `where` argument doesn't exist, create a new LigneReception with this data.
     */
    create: XOR<LigneReceptionCreateInput, LigneReceptionUncheckedCreateInput>
    /**
     * In case the LigneReception was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LigneReceptionUpdateInput, LigneReceptionUncheckedUpdateInput>
  }

  /**
   * LigneReception delete
   */
  export type LigneReceptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneReception
     */
    select?: LigneReceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneReceptionInclude<ExtArgs> | null
    /**
     * Filter which LigneReception to delete.
     */
    where: LigneReceptionWhereUniqueInput
  }

  /**
   * LigneReception deleteMany
   */
  export type LigneReceptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LigneReceptions to delete
     */
    where?: LigneReceptionWhereInput
  }

  /**
   * LigneReception without action
   */
  export type LigneReceptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneReception
     */
    select?: LigneReceptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneReceptionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ArticleScalarFieldEnum: {
    id: 'id',
    reference: 'reference',
    nom: 'nom',
    description: 'description',
    categorie: 'categorie',
    unite: 'unite',
    prixAchat: 'prixAchat',
    prixVente: 'prixVente',
    quantiteStock: 'quantiteStock',
    seuilAlerte: 'seuilAlerte',
    seuilRupture: 'seuilRupture',
    emplacement: 'emplacement',
    fournisseurId: 'fournisseurId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ArticleScalarFieldEnum = (typeof ArticleScalarFieldEnum)[keyof typeof ArticleScalarFieldEnum]


  export const MouvementStockScalarFieldEnum: {
    id: 'id',
    articleId: 'articleId',
    type: 'type',
    quantite: 'quantite',
    dateOperation: 'dateOperation',
    utilisateurId: 'utilisateurId',
    numeroDocument: 'numeroDocument',
    emplacement: 'emplacement',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type MouvementStockScalarFieldEnum = (typeof MouvementStockScalarFieldEnum)[keyof typeof MouvementStockScalarFieldEnum]


  export const InventaireScalarFieldEnum: {
    id: 'id',
    numeroInventaire: 'numeroInventaire',
    dateDebut: 'dateDebut',
    dateFin: 'dateFin',
    status: 'status',
    nbArticles: 'nbArticles',
    nbEcarts: 'nbEcarts',
    montantEcart: 'montantEcart',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InventaireScalarFieldEnum = (typeof InventaireScalarFieldEnum)[keyof typeof InventaireScalarFieldEnum]


  export const LigneInventaireScalarFieldEnum: {
    id: 'id',
    inventaireId: 'inventaireId',
    articleId: 'articleId',
    quantiteTheorique: 'quantiteTheorique',
    quantiteReelle: 'quantiteReelle',
    ecart: 'ecart',
    valeurEcart: 'valeurEcart',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LigneInventaireScalarFieldEnum = (typeof LigneInventaireScalarFieldEnum)[keyof typeof LigneInventaireScalarFieldEnum]


  export const EquipementScalarFieldEnum: {
    id: 'id',
    reference: 'reference',
    nom: 'nom',
    description: 'description',
    categorie: 'categorie',
    dateAchat: 'dateAchat',
    valeurAchat: 'valeurAchat',
    departement: 'departement',
    utilisateurId: 'utilisateurId',
    emplacement: 'emplacement',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EquipementScalarFieldEnum = (typeof EquipementScalarFieldEnum)[keyof typeof EquipementScalarFieldEnum]


  export const MaintenanceEquipementScalarFieldEnum: {
    id: 'id',
    equipementId: 'equipementId',
    type: 'type',
    dateDebut: 'dateDebut',
    dateFin: 'dateFin',
    technicienId: 'technicienId',
    description: 'description',
    coutReel: 'coutReel',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MaintenanceEquipementScalarFieldEnum = (typeof MaintenanceEquipementScalarFieldEnum)[keyof typeof MaintenanceEquipementScalarFieldEnum]


  export const ReceptionScalarFieldEnum: {
    id: 'id',
    numero: 'numero',
    bonCommandeId: 'bonCommandeId',
    fournisseurId: 'fournisseurId',
    dateReception: 'dateReception',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReceptionScalarFieldEnum = (typeof ReceptionScalarFieldEnum)[keyof typeof ReceptionScalarFieldEnum]


  export const LigneReceptionScalarFieldEnum: {
    id: 'id',
    receptionId: 'receptionId',
    articleId: 'articleId',
    designation: 'designation',
    quantitePrev: 'quantitePrev',
    quantiteRecue: 'quantiteRecue',
    prixUnitaire: 'prixUnitaire',
    tva: 'tva',
    ecart: 'ecart',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type LigneReceptionScalarFieldEnum = (typeof LigneReceptionScalarFieldEnum)[keyof typeof LigneReceptionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Unite'
   */
  export type EnumUniteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Unite'>
    


  /**
   * Reference to a field of type 'Unite[]'
   */
  export type ListEnumUniteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Unite[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'StatusArticle'
   */
  export type EnumStatusArticleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusArticle'>
    


  /**
   * Reference to a field of type 'StatusArticle[]'
   */
  export type ListEnumStatusArticleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusArticle[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'TypeMouvement'
   */
  export type EnumTypeMouvementFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeMouvement'>
    


  /**
   * Reference to a field of type 'TypeMouvement[]'
   */
  export type ListEnumTypeMouvementFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeMouvement[]'>
    


  /**
   * Reference to a field of type 'StatusInventaire'
   */
  export type EnumStatusInventaireFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusInventaire'>
    


  /**
   * Reference to a field of type 'StatusInventaire[]'
   */
  export type ListEnumStatusInventaireFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusInventaire[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'StatusEquipement'
   */
  export type EnumStatusEquipementFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusEquipement'>
    


  /**
   * Reference to a field of type 'StatusEquipement[]'
   */
  export type ListEnumStatusEquipementFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusEquipement[]'>
    


  /**
   * Reference to a field of type 'TypeMaintenance'
   */
  export type EnumTypeMaintenanceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeMaintenance'>
    


  /**
   * Reference to a field of type 'TypeMaintenance[]'
   */
  export type ListEnumTypeMaintenanceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeMaintenance[]'>
    


  /**
   * Reference to a field of type 'StatusMaintenance'
   */
  export type EnumStatusMaintenanceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusMaintenance'>
    


  /**
   * Reference to a field of type 'StatusMaintenance[]'
   */
  export type ListEnumStatusMaintenanceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusMaintenance[]'>
    


  /**
   * Reference to a field of type 'StatusReception'
   */
  export type EnumStatusReceptionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusReception'>
    


  /**
   * Reference to a field of type 'StatusReception[]'
   */
  export type ListEnumStatusReceptionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusReception[]'>
    
  /**
   * Deep Input Types
   */


  export type ArticleWhereInput = {
    AND?: ArticleWhereInput | ArticleWhereInput[]
    OR?: ArticleWhereInput[]
    NOT?: ArticleWhereInput | ArticleWhereInput[]
    id?: StringFilter<"Article"> | string
    reference?: StringFilter<"Article"> | string
    nom?: StringFilter<"Article"> | string
    description?: StringNullableFilter<"Article"> | string | null
    categorie?: StringFilter<"Article"> | string
    unite?: EnumUniteFilter<"Article"> | $Enums.Unite
    prixAchat?: FloatFilter<"Article"> | number
    prixVente?: FloatFilter<"Article"> | number
    quantiteStock?: FloatFilter<"Article"> | number
    seuilAlerte?: FloatFilter<"Article"> | number
    seuilRupture?: FloatFilter<"Article"> | number
    emplacement?: StringNullableFilter<"Article"> | string | null
    fournisseurId?: StringNullableFilter<"Article"> | string | null
    status?: EnumStatusArticleFilter<"Article"> | $Enums.StatusArticle
    createdAt?: DateTimeFilter<"Article"> | Date | string
    updatedAt?: DateTimeFilter<"Article"> | Date | string
    mouvements?: MouvementStockListRelationFilter
    lignesInventaire?: LigneInventaireListRelationFilter
    lignesReception?: LigneReceptionListRelationFilter
  }

  export type ArticleOrderByWithRelationInput = {
    id?: SortOrder
    reference?: SortOrder
    nom?: SortOrder
    description?: SortOrderInput | SortOrder
    categorie?: SortOrder
    unite?: SortOrder
    prixAchat?: SortOrder
    prixVente?: SortOrder
    quantiteStock?: SortOrder
    seuilAlerte?: SortOrder
    seuilRupture?: SortOrder
    emplacement?: SortOrderInput | SortOrder
    fournisseurId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mouvements?: MouvementStockOrderByRelationAggregateInput
    lignesInventaire?: LigneInventaireOrderByRelationAggregateInput
    lignesReception?: LigneReceptionOrderByRelationAggregateInput
  }

  export type ArticleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    reference?: string
    AND?: ArticleWhereInput | ArticleWhereInput[]
    OR?: ArticleWhereInput[]
    NOT?: ArticleWhereInput | ArticleWhereInput[]
    nom?: StringFilter<"Article"> | string
    description?: StringNullableFilter<"Article"> | string | null
    categorie?: StringFilter<"Article"> | string
    unite?: EnumUniteFilter<"Article"> | $Enums.Unite
    prixAchat?: FloatFilter<"Article"> | number
    prixVente?: FloatFilter<"Article"> | number
    quantiteStock?: FloatFilter<"Article"> | number
    seuilAlerte?: FloatFilter<"Article"> | number
    seuilRupture?: FloatFilter<"Article"> | number
    emplacement?: StringNullableFilter<"Article"> | string | null
    fournisseurId?: StringNullableFilter<"Article"> | string | null
    status?: EnumStatusArticleFilter<"Article"> | $Enums.StatusArticle
    createdAt?: DateTimeFilter<"Article"> | Date | string
    updatedAt?: DateTimeFilter<"Article"> | Date | string
    mouvements?: MouvementStockListRelationFilter
    lignesInventaire?: LigneInventaireListRelationFilter
    lignesReception?: LigneReceptionListRelationFilter
  }, "id" | "reference">

  export type ArticleOrderByWithAggregationInput = {
    id?: SortOrder
    reference?: SortOrder
    nom?: SortOrder
    description?: SortOrderInput | SortOrder
    categorie?: SortOrder
    unite?: SortOrder
    prixAchat?: SortOrder
    prixVente?: SortOrder
    quantiteStock?: SortOrder
    seuilAlerte?: SortOrder
    seuilRupture?: SortOrder
    emplacement?: SortOrderInput | SortOrder
    fournisseurId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ArticleCountOrderByAggregateInput
    _avg?: ArticleAvgOrderByAggregateInput
    _max?: ArticleMaxOrderByAggregateInput
    _min?: ArticleMinOrderByAggregateInput
    _sum?: ArticleSumOrderByAggregateInput
  }

  export type ArticleScalarWhereWithAggregatesInput = {
    AND?: ArticleScalarWhereWithAggregatesInput | ArticleScalarWhereWithAggregatesInput[]
    OR?: ArticleScalarWhereWithAggregatesInput[]
    NOT?: ArticleScalarWhereWithAggregatesInput | ArticleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Article"> | string
    reference?: StringWithAggregatesFilter<"Article"> | string
    nom?: StringWithAggregatesFilter<"Article"> | string
    description?: StringNullableWithAggregatesFilter<"Article"> | string | null
    categorie?: StringWithAggregatesFilter<"Article"> | string
    unite?: EnumUniteWithAggregatesFilter<"Article"> | $Enums.Unite
    prixAchat?: FloatWithAggregatesFilter<"Article"> | number
    prixVente?: FloatWithAggregatesFilter<"Article"> | number
    quantiteStock?: FloatWithAggregatesFilter<"Article"> | number
    seuilAlerte?: FloatWithAggregatesFilter<"Article"> | number
    seuilRupture?: FloatWithAggregatesFilter<"Article"> | number
    emplacement?: StringNullableWithAggregatesFilter<"Article"> | string | null
    fournisseurId?: StringNullableWithAggregatesFilter<"Article"> | string | null
    status?: EnumStatusArticleWithAggregatesFilter<"Article"> | $Enums.StatusArticle
    createdAt?: DateTimeWithAggregatesFilter<"Article"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Article"> | Date | string
  }

  export type MouvementStockWhereInput = {
    AND?: MouvementStockWhereInput | MouvementStockWhereInput[]
    OR?: MouvementStockWhereInput[]
    NOT?: MouvementStockWhereInput | MouvementStockWhereInput[]
    id?: StringFilter<"MouvementStock"> | string
    articleId?: StringFilter<"MouvementStock"> | string
    type?: EnumTypeMouvementFilter<"MouvementStock"> | $Enums.TypeMouvement
    quantite?: FloatFilter<"MouvementStock"> | number
    dateOperation?: DateTimeFilter<"MouvementStock"> | Date | string
    utilisateurId?: StringFilter<"MouvementStock"> | string
    numeroDocument?: StringNullableFilter<"MouvementStock"> | string | null
    emplacement?: StringNullableFilter<"MouvementStock"> | string | null
    notes?: StringNullableFilter<"MouvementStock"> | string | null
    createdAt?: DateTimeFilter<"MouvementStock"> | Date | string
    article?: XOR<ArticleRelationFilter, ArticleWhereInput>
  }

  export type MouvementStockOrderByWithRelationInput = {
    id?: SortOrder
    articleId?: SortOrder
    type?: SortOrder
    quantite?: SortOrder
    dateOperation?: SortOrder
    utilisateurId?: SortOrder
    numeroDocument?: SortOrderInput | SortOrder
    emplacement?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    article?: ArticleOrderByWithRelationInput
  }

  export type MouvementStockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MouvementStockWhereInput | MouvementStockWhereInput[]
    OR?: MouvementStockWhereInput[]
    NOT?: MouvementStockWhereInput | MouvementStockWhereInput[]
    articleId?: StringFilter<"MouvementStock"> | string
    type?: EnumTypeMouvementFilter<"MouvementStock"> | $Enums.TypeMouvement
    quantite?: FloatFilter<"MouvementStock"> | number
    dateOperation?: DateTimeFilter<"MouvementStock"> | Date | string
    utilisateurId?: StringFilter<"MouvementStock"> | string
    numeroDocument?: StringNullableFilter<"MouvementStock"> | string | null
    emplacement?: StringNullableFilter<"MouvementStock"> | string | null
    notes?: StringNullableFilter<"MouvementStock"> | string | null
    createdAt?: DateTimeFilter<"MouvementStock"> | Date | string
    article?: XOR<ArticleRelationFilter, ArticleWhereInput>
  }, "id">

  export type MouvementStockOrderByWithAggregationInput = {
    id?: SortOrder
    articleId?: SortOrder
    type?: SortOrder
    quantite?: SortOrder
    dateOperation?: SortOrder
    utilisateurId?: SortOrder
    numeroDocument?: SortOrderInput | SortOrder
    emplacement?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MouvementStockCountOrderByAggregateInput
    _avg?: MouvementStockAvgOrderByAggregateInput
    _max?: MouvementStockMaxOrderByAggregateInput
    _min?: MouvementStockMinOrderByAggregateInput
    _sum?: MouvementStockSumOrderByAggregateInput
  }

  export type MouvementStockScalarWhereWithAggregatesInput = {
    AND?: MouvementStockScalarWhereWithAggregatesInput | MouvementStockScalarWhereWithAggregatesInput[]
    OR?: MouvementStockScalarWhereWithAggregatesInput[]
    NOT?: MouvementStockScalarWhereWithAggregatesInput | MouvementStockScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MouvementStock"> | string
    articleId?: StringWithAggregatesFilter<"MouvementStock"> | string
    type?: EnumTypeMouvementWithAggregatesFilter<"MouvementStock"> | $Enums.TypeMouvement
    quantite?: FloatWithAggregatesFilter<"MouvementStock"> | number
    dateOperation?: DateTimeWithAggregatesFilter<"MouvementStock"> | Date | string
    utilisateurId?: StringWithAggregatesFilter<"MouvementStock"> | string
    numeroDocument?: StringNullableWithAggregatesFilter<"MouvementStock"> | string | null
    emplacement?: StringNullableWithAggregatesFilter<"MouvementStock"> | string | null
    notes?: StringNullableWithAggregatesFilter<"MouvementStock"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MouvementStock"> | Date | string
  }

  export type InventaireWhereInput = {
    AND?: InventaireWhereInput | InventaireWhereInput[]
    OR?: InventaireWhereInput[]
    NOT?: InventaireWhereInput | InventaireWhereInput[]
    id?: StringFilter<"Inventaire"> | string
    numeroInventaire?: StringFilter<"Inventaire"> | string
    dateDebut?: DateTimeFilter<"Inventaire"> | Date | string
    dateFin?: DateTimeNullableFilter<"Inventaire"> | Date | string | null
    status?: EnumStatusInventaireFilter<"Inventaire"> | $Enums.StatusInventaire
    nbArticles?: IntFilter<"Inventaire"> | number
    nbEcarts?: IntFilter<"Inventaire"> | number
    montantEcart?: FloatFilter<"Inventaire"> | number
    notes?: StringNullableFilter<"Inventaire"> | string | null
    createdAt?: DateTimeFilter<"Inventaire"> | Date | string
    updatedAt?: DateTimeFilter<"Inventaire"> | Date | string
    lignes?: LigneInventaireListRelationFilter
  }

  export type InventaireOrderByWithRelationInput = {
    id?: SortOrder
    numeroInventaire?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrderInput | SortOrder
    status?: SortOrder
    nbArticles?: SortOrder
    nbEcarts?: SortOrder
    montantEcart?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lignes?: LigneInventaireOrderByRelationAggregateInput
  }

  export type InventaireWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    numeroInventaire?: string
    AND?: InventaireWhereInput | InventaireWhereInput[]
    OR?: InventaireWhereInput[]
    NOT?: InventaireWhereInput | InventaireWhereInput[]
    dateDebut?: DateTimeFilter<"Inventaire"> | Date | string
    dateFin?: DateTimeNullableFilter<"Inventaire"> | Date | string | null
    status?: EnumStatusInventaireFilter<"Inventaire"> | $Enums.StatusInventaire
    nbArticles?: IntFilter<"Inventaire"> | number
    nbEcarts?: IntFilter<"Inventaire"> | number
    montantEcart?: FloatFilter<"Inventaire"> | number
    notes?: StringNullableFilter<"Inventaire"> | string | null
    createdAt?: DateTimeFilter<"Inventaire"> | Date | string
    updatedAt?: DateTimeFilter<"Inventaire"> | Date | string
    lignes?: LigneInventaireListRelationFilter
  }, "id" | "numeroInventaire">

  export type InventaireOrderByWithAggregationInput = {
    id?: SortOrder
    numeroInventaire?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrderInput | SortOrder
    status?: SortOrder
    nbArticles?: SortOrder
    nbEcarts?: SortOrder
    montantEcart?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InventaireCountOrderByAggregateInput
    _avg?: InventaireAvgOrderByAggregateInput
    _max?: InventaireMaxOrderByAggregateInput
    _min?: InventaireMinOrderByAggregateInput
    _sum?: InventaireSumOrderByAggregateInput
  }

  export type InventaireScalarWhereWithAggregatesInput = {
    AND?: InventaireScalarWhereWithAggregatesInput | InventaireScalarWhereWithAggregatesInput[]
    OR?: InventaireScalarWhereWithAggregatesInput[]
    NOT?: InventaireScalarWhereWithAggregatesInput | InventaireScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Inventaire"> | string
    numeroInventaire?: StringWithAggregatesFilter<"Inventaire"> | string
    dateDebut?: DateTimeWithAggregatesFilter<"Inventaire"> | Date | string
    dateFin?: DateTimeNullableWithAggregatesFilter<"Inventaire"> | Date | string | null
    status?: EnumStatusInventaireWithAggregatesFilter<"Inventaire"> | $Enums.StatusInventaire
    nbArticles?: IntWithAggregatesFilter<"Inventaire"> | number
    nbEcarts?: IntWithAggregatesFilter<"Inventaire"> | number
    montantEcart?: FloatWithAggregatesFilter<"Inventaire"> | number
    notes?: StringNullableWithAggregatesFilter<"Inventaire"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Inventaire"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Inventaire"> | Date | string
  }

  export type LigneInventaireWhereInput = {
    AND?: LigneInventaireWhereInput | LigneInventaireWhereInput[]
    OR?: LigneInventaireWhereInput[]
    NOT?: LigneInventaireWhereInput | LigneInventaireWhereInput[]
    id?: StringFilter<"LigneInventaire"> | string
    inventaireId?: StringFilter<"LigneInventaire"> | string
    articleId?: StringFilter<"LigneInventaire"> | string
    quantiteTheorique?: FloatFilter<"LigneInventaire"> | number
    quantiteReelle?: FloatFilter<"LigneInventaire"> | number
    ecart?: FloatFilter<"LigneInventaire"> | number
    valeurEcart?: FloatFilter<"LigneInventaire"> | number
    notes?: StringNullableFilter<"LigneInventaire"> | string | null
    createdAt?: DateTimeFilter<"LigneInventaire"> | Date | string
    updatedAt?: DateTimeFilter<"LigneInventaire"> | Date | string
    inventaire?: XOR<InventaireRelationFilter, InventaireWhereInput>
    article?: XOR<ArticleRelationFilter, ArticleWhereInput>
  }

  export type LigneInventaireOrderByWithRelationInput = {
    id?: SortOrder
    inventaireId?: SortOrder
    articleId?: SortOrder
    quantiteTheorique?: SortOrder
    quantiteReelle?: SortOrder
    ecart?: SortOrder
    valeurEcart?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inventaire?: InventaireOrderByWithRelationInput
    article?: ArticleOrderByWithRelationInput
  }

  export type LigneInventaireWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LigneInventaireWhereInput | LigneInventaireWhereInput[]
    OR?: LigneInventaireWhereInput[]
    NOT?: LigneInventaireWhereInput | LigneInventaireWhereInput[]
    inventaireId?: StringFilter<"LigneInventaire"> | string
    articleId?: StringFilter<"LigneInventaire"> | string
    quantiteTheorique?: FloatFilter<"LigneInventaire"> | number
    quantiteReelle?: FloatFilter<"LigneInventaire"> | number
    ecart?: FloatFilter<"LigneInventaire"> | number
    valeurEcart?: FloatFilter<"LigneInventaire"> | number
    notes?: StringNullableFilter<"LigneInventaire"> | string | null
    createdAt?: DateTimeFilter<"LigneInventaire"> | Date | string
    updatedAt?: DateTimeFilter<"LigneInventaire"> | Date | string
    inventaire?: XOR<InventaireRelationFilter, InventaireWhereInput>
    article?: XOR<ArticleRelationFilter, ArticleWhereInput>
  }, "id">

  export type LigneInventaireOrderByWithAggregationInput = {
    id?: SortOrder
    inventaireId?: SortOrder
    articleId?: SortOrder
    quantiteTheorique?: SortOrder
    quantiteReelle?: SortOrder
    ecart?: SortOrder
    valeurEcart?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LigneInventaireCountOrderByAggregateInput
    _avg?: LigneInventaireAvgOrderByAggregateInput
    _max?: LigneInventaireMaxOrderByAggregateInput
    _min?: LigneInventaireMinOrderByAggregateInput
    _sum?: LigneInventaireSumOrderByAggregateInput
  }

  export type LigneInventaireScalarWhereWithAggregatesInput = {
    AND?: LigneInventaireScalarWhereWithAggregatesInput | LigneInventaireScalarWhereWithAggregatesInput[]
    OR?: LigneInventaireScalarWhereWithAggregatesInput[]
    NOT?: LigneInventaireScalarWhereWithAggregatesInput | LigneInventaireScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LigneInventaire"> | string
    inventaireId?: StringWithAggregatesFilter<"LigneInventaire"> | string
    articleId?: StringWithAggregatesFilter<"LigneInventaire"> | string
    quantiteTheorique?: FloatWithAggregatesFilter<"LigneInventaire"> | number
    quantiteReelle?: FloatWithAggregatesFilter<"LigneInventaire"> | number
    ecart?: FloatWithAggregatesFilter<"LigneInventaire"> | number
    valeurEcart?: FloatWithAggregatesFilter<"LigneInventaire"> | number
    notes?: StringNullableWithAggregatesFilter<"LigneInventaire"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LigneInventaire"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LigneInventaire"> | Date | string
  }

  export type EquipementWhereInput = {
    AND?: EquipementWhereInput | EquipementWhereInput[]
    OR?: EquipementWhereInput[]
    NOT?: EquipementWhereInput | EquipementWhereInput[]
    id?: StringFilter<"Equipement"> | string
    reference?: StringFilter<"Equipement"> | string
    nom?: StringFilter<"Equipement"> | string
    description?: StringNullableFilter<"Equipement"> | string | null
    categorie?: StringFilter<"Equipement"> | string
    dateAchat?: DateTimeNullableFilter<"Equipement"> | Date | string | null
    valeurAchat?: FloatFilter<"Equipement"> | number
    departement?: StringNullableFilter<"Equipement"> | string | null
    utilisateurId?: StringNullableFilter<"Equipement"> | string | null
    emplacement?: StringNullableFilter<"Equipement"> | string | null
    status?: EnumStatusEquipementFilter<"Equipement"> | $Enums.StatusEquipement
    createdAt?: DateTimeFilter<"Equipement"> | Date | string
    updatedAt?: DateTimeFilter<"Equipement"> | Date | string
    maintenances?: MaintenanceEquipementListRelationFilter
  }

  export type EquipementOrderByWithRelationInput = {
    id?: SortOrder
    reference?: SortOrder
    nom?: SortOrder
    description?: SortOrderInput | SortOrder
    categorie?: SortOrder
    dateAchat?: SortOrderInput | SortOrder
    valeurAchat?: SortOrder
    departement?: SortOrderInput | SortOrder
    utilisateurId?: SortOrderInput | SortOrder
    emplacement?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    maintenances?: MaintenanceEquipementOrderByRelationAggregateInput
  }

  export type EquipementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    reference?: string
    AND?: EquipementWhereInput | EquipementWhereInput[]
    OR?: EquipementWhereInput[]
    NOT?: EquipementWhereInput | EquipementWhereInput[]
    nom?: StringFilter<"Equipement"> | string
    description?: StringNullableFilter<"Equipement"> | string | null
    categorie?: StringFilter<"Equipement"> | string
    dateAchat?: DateTimeNullableFilter<"Equipement"> | Date | string | null
    valeurAchat?: FloatFilter<"Equipement"> | number
    departement?: StringNullableFilter<"Equipement"> | string | null
    utilisateurId?: StringNullableFilter<"Equipement"> | string | null
    emplacement?: StringNullableFilter<"Equipement"> | string | null
    status?: EnumStatusEquipementFilter<"Equipement"> | $Enums.StatusEquipement
    createdAt?: DateTimeFilter<"Equipement"> | Date | string
    updatedAt?: DateTimeFilter<"Equipement"> | Date | string
    maintenances?: MaintenanceEquipementListRelationFilter
  }, "id" | "reference">

  export type EquipementOrderByWithAggregationInput = {
    id?: SortOrder
    reference?: SortOrder
    nom?: SortOrder
    description?: SortOrderInput | SortOrder
    categorie?: SortOrder
    dateAchat?: SortOrderInput | SortOrder
    valeurAchat?: SortOrder
    departement?: SortOrderInput | SortOrder
    utilisateurId?: SortOrderInput | SortOrder
    emplacement?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EquipementCountOrderByAggregateInput
    _avg?: EquipementAvgOrderByAggregateInput
    _max?: EquipementMaxOrderByAggregateInput
    _min?: EquipementMinOrderByAggregateInput
    _sum?: EquipementSumOrderByAggregateInput
  }

  export type EquipementScalarWhereWithAggregatesInput = {
    AND?: EquipementScalarWhereWithAggregatesInput | EquipementScalarWhereWithAggregatesInput[]
    OR?: EquipementScalarWhereWithAggregatesInput[]
    NOT?: EquipementScalarWhereWithAggregatesInput | EquipementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Equipement"> | string
    reference?: StringWithAggregatesFilter<"Equipement"> | string
    nom?: StringWithAggregatesFilter<"Equipement"> | string
    description?: StringNullableWithAggregatesFilter<"Equipement"> | string | null
    categorie?: StringWithAggregatesFilter<"Equipement"> | string
    dateAchat?: DateTimeNullableWithAggregatesFilter<"Equipement"> | Date | string | null
    valeurAchat?: FloatWithAggregatesFilter<"Equipement"> | number
    departement?: StringNullableWithAggregatesFilter<"Equipement"> | string | null
    utilisateurId?: StringNullableWithAggregatesFilter<"Equipement"> | string | null
    emplacement?: StringNullableWithAggregatesFilter<"Equipement"> | string | null
    status?: EnumStatusEquipementWithAggregatesFilter<"Equipement"> | $Enums.StatusEquipement
    createdAt?: DateTimeWithAggregatesFilter<"Equipement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Equipement"> | Date | string
  }

  export type MaintenanceEquipementWhereInput = {
    AND?: MaintenanceEquipementWhereInput | MaintenanceEquipementWhereInput[]
    OR?: MaintenanceEquipementWhereInput[]
    NOT?: MaintenanceEquipementWhereInput | MaintenanceEquipementWhereInput[]
    id?: StringFilter<"MaintenanceEquipement"> | string
    equipementId?: StringFilter<"MaintenanceEquipement"> | string
    type?: EnumTypeMaintenanceFilter<"MaintenanceEquipement"> | $Enums.TypeMaintenance
    dateDebut?: DateTimeFilter<"MaintenanceEquipement"> | Date | string
    dateFin?: DateTimeNullableFilter<"MaintenanceEquipement"> | Date | string | null
    technicienId?: StringNullableFilter<"MaintenanceEquipement"> | string | null
    description?: StringFilter<"MaintenanceEquipement"> | string
    coutReel?: FloatFilter<"MaintenanceEquipement"> | number
    status?: EnumStatusMaintenanceFilter<"MaintenanceEquipement"> | $Enums.StatusMaintenance
    createdAt?: DateTimeFilter<"MaintenanceEquipement"> | Date | string
    updatedAt?: DateTimeFilter<"MaintenanceEquipement"> | Date | string
    equipement?: XOR<EquipementRelationFilter, EquipementWhereInput>
  }

  export type MaintenanceEquipementOrderByWithRelationInput = {
    id?: SortOrder
    equipementId?: SortOrder
    type?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrderInput | SortOrder
    technicienId?: SortOrderInput | SortOrder
    description?: SortOrder
    coutReel?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    equipement?: EquipementOrderByWithRelationInput
  }

  export type MaintenanceEquipementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MaintenanceEquipementWhereInput | MaintenanceEquipementWhereInput[]
    OR?: MaintenanceEquipementWhereInput[]
    NOT?: MaintenanceEquipementWhereInput | MaintenanceEquipementWhereInput[]
    equipementId?: StringFilter<"MaintenanceEquipement"> | string
    type?: EnumTypeMaintenanceFilter<"MaintenanceEquipement"> | $Enums.TypeMaintenance
    dateDebut?: DateTimeFilter<"MaintenanceEquipement"> | Date | string
    dateFin?: DateTimeNullableFilter<"MaintenanceEquipement"> | Date | string | null
    technicienId?: StringNullableFilter<"MaintenanceEquipement"> | string | null
    description?: StringFilter<"MaintenanceEquipement"> | string
    coutReel?: FloatFilter<"MaintenanceEquipement"> | number
    status?: EnumStatusMaintenanceFilter<"MaintenanceEquipement"> | $Enums.StatusMaintenance
    createdAt?: DateTimeFilter<"MaintenanceEquipement"> | Date | string
    updatedAt?: DateTimeFilter<"MaintenanceEquipement"> | Date | string
    equipement?: XOR<EquipementRelationFilter, EquipementWhereInput>
  }, "id">

  export type MaintenanceEquipementOrderByWithAggregationInput = {
    id?: SortOrder
    equipementId?: SortOrder
    type?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrderInput | SortOrder
    technicienId?: SortOrderInput | SortOrder
    description?: SortOrder
    coutReel?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MaintenanceEquipementCountOrderByAggregateInput
    _avg?: MaintenanceEquipementAvgOrderByAggregateInput
    _max?: MaintenanceEquipementMaxOrderByAggregateInput
    _min?: MaintenanceEquipementMinOrderByAggregateInput
    _sum?: MaintenanceEquipementSumOrderByAggregateInput
  }

  export type MaintenanceEquipementScalarWhereWithAggregatesInput = {
    AND?: MaintenanceEquipementScalarWhereWithAggregatesInput | MaintenanceEquipementScalarWhereWithAggregatesInput[]
    OR?: MaintenanceEquipementScalarWhereWithAggregatesInput[]
    NOT?: MaintenanceEquipementScalarWhereWithAggregatesInput | MaintenanceEquipementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MaintenanceEquipement"> | string
    equipementId?: StringWithAggregatesFilter<"MaintenanceEquipement"> | string
    type?: EnumTypeMaintenanceWithAggregatesFilter<"MaintenanceEquipement"> | $Enums.TypeMaintenance
    dateDebut?: DateTimeWithAggregatesFilter<"MaintenanceEquipement"> | Date | string
    dateFin?: DateTimeNullableWithAggregatesFilter<"MaintenanceEquipement"> | Date | string | null
    technicienId?: StringNullableWithAggregatesFilter<"MaintenanceEquipement"> | string | null
    description?: StringWithAggregatesFilter<"MaintenanceEquipement"> | string
    coutReel?: FloatWithAggregatesFilter<"MaintenanceEquipement"> | number
    status?: EnumStatusMaintenanceWithAggregatesFilter<"MaintenanceEquipement"> | $Enums.StatusMaintenance
    createdAt?: DateTimeWithAggregatesFilter<"MaintenanceEquipement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MaintenanceEquipement"> | Date | string
  }

  export type ReceptionWhereInput = {
    AND?: ReceptionWhereInput | ReceptionWhereInput[]
    OR?: ReceptionWhereInput[]
    NOT?: ReceptionWhereInput | ReceptionWhereInput[]
    id?: StringFilter<"Reception"> | string
    numero?: StringFilter<"Reception"> | string
    bonCommandeId?: StringFilter<"Reception"> | string
    fournisseurId?: StringNullableFilter<"Reception"> | string | null
    dateReception?: DateTimeFilter<"Reception"> | Date | string
    status?: EnumStatusReceptionFilter<"Reception"> | $Enums.StatusReception
    notes?: StringNullableFilter<"Reception"> | string | null
    createdAt?: DateTimeFilter<"Reception"> | Date | string
    updatedAt?: DateTimeFilter<"Reception"> | Date | string
    lignes?: LigneReceptionListRelationFilter
  }

  export type ReceptionOrderByWithRelationInput = {
    id?: SortOrder
    numero?: SortOrder
    bonCommandeId?: SortOrder
    fournisseurId?: SortOrderInput | SortOrder
    dateReception?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lignes?: LigneReceptionOrderByRelationAggregateInput
  }

  export type ReceptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    numero?: string
    AND?: ReceptionWhereInput | ReceptionWhereInput[]
    OR?: ReceptionWhereInput[]
    NOT?: ReceptionWhereInput | ReceptionWhereInput[]
    bonCommandeId?: StringFilter<"Reception"> | string
    fournisseurId?: StringNullableFilter<"Reception"> | string | null
    dateReception?: DateTimeFilter<"Reception"> | Date | string
    status?: EnumStatusReceptionFilter<"Reception"> | $Enums.StatusReception
    notes?: StringNullableFilter<"Reception"> | string | null
    createdAt?: DateTimeFilter<"Reception"> | Date | string
    updatedAt?: DateTimeFilter<"Reception"> | Date | string
    lignes?: LigneReceptionListRelationFilter
  }, "id" | "numero">

  export type ReceptionOrderByWithAggregationInput = {
    id?: SortOrder
    numero?: SortOrder
    bonCommandeId?: SortOrder
    fournisseurId?: SortOrderInput | SortOrder
    dateReception?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReceptionCountOrderByAggregateInput
    _max?: ReceptionMaxOrderByAggregateInput
    _min?: ReceptionMinOrderByAggregateInput
  }

  export type ReceptionScalarWhereWithAggregatesInput = {
    AND?: ReceptionScalarWhereWithAggregatesInput | ReceptionScalarWhereWithAggregatesInput[]
    OR?: ReceptionScalarWhereWithAggregatesInput[]
    NOT?: ReceptionScalarWhereWithAggregatesInput | ReceptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Reception"> | string
    numero?: StringWithAggregatesFilter<"Reception"> | string
    bonCommandeId?: StringWithAggregatesFilter<"Reception"> | string
    fournisseurId?: StringNullableWithAggregatesFilter<"Reception"> | string | null
    dateReception?: DateTimeWithAggregatesFilter<"Reception"> | Date | string
    status?: EnumStatusReceptionWithAggregatesFilter<"Reception"> | $Enums.StatusReception
    notes?: StringNullableWithAggregatesFilter<"Reception"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Reception"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Reception"> | Date | string
  }

  export type LigneReceptionWhereInput = {
    AND?: LigneReceptionWhereInput | LigneReceptionWhereInput[]
    OR?: LigneReceptionWhereInput[]
    NOT?: LigneReceptionWhereInput | LigneReceptionWhereInput[]
    id?: StringFilter<"LigneReception"> | string
    receptionId?: StringFilter<"LigneReception"> | string
    articleId?: StringFilter<"LigneReception"> | string
    designation?: StringFilter<"LigneReception"> | string
    quantitePrev?: FloatFilter<"LigneReception"> | number
    quantiteRecue?: FloatFilter<"LigneReception"> | number
    prixUnitaire?: FloatFilter<"LigneReception"> | number
    tva?: FloatNullableFilter<"LigneReception"> | number | null
    ecart?: FloatFilter<"LigneReception"> | number
    notes?: StringNullableFilter<"LigneReception"> | string | null
    createdAt?: DateTimeFilter<"LigneReception"> | Date | string
    reception?: XOR<ReceptionRelationFilter, ReceptionWhereInput>
    article?: XOR<ArticleRelationFilter, ArticleWhereInput>
  }

  export type LigneReceptionOrderByWithRelationInput = {
    id?: SortOrder
    receptionId?: SortOrder
    articleId?: SortOrder
    designation?: SortOrder
    quantitePrev?: SortOrder
    quantiteRecue?: SortOrder
    prixUnitaire?: SortOrder
    tva?: SortOrderInput | SortOrder
    ecart?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    reception?: ReceptionOrderByWithRelationInput
    article?: ArticleOrderByWithRelationInput
  }

  export type LigneReceptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LigneReceptionWhereInput | LigneReceptionWhereInput[]
    OR?: LigneReceptionWhereInput[]
    NOT?: LigneReceptionWhereInput | LigneReceptionWhereInput[]
    receptionId?: StringFilter<"LigneReception"> | string
    articleId?: StringFilter<"LigneReception"> | string
    designation?: StringFilter<"LigneReception"> | string
    quantitePrev?: FloatFilter<"LigneReception"> | number
    quantiteRecue?: FloatFilter<"LigneReception"> | number
    prixUnitaire?: FloatFilter<"LigneReception"> | number
    tva?: FloatNullableFilter<"LigneReception"> | number | null
    ecart?: FloatFilter<"LigneReception"> | number
    notes?: StringNullableFilter<"LigneReception"> | string | null
    createdAt?: DateTimeFilter<"LigneReception"> | Date | string
    reception?: XOR<ReceptionRelationFilter, ReceptionWhereInput>
    article?: XOR<ArticleRelationFilter, ArticleWhereInput>
  }, "id">

  export type LigneReceptionOrderByWithAggregationInput = {
    id?: SortOrder
    receptionId?: SortOrder
    articleId?: SortOrder
    designation?: SortOrder
    quantitePrev?: SortOrder
    quantiteRecue?: SortOrder
    prixUnitaire?: SortOrder
    tva?: SortOrderInput | SortOrder
    ecart?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LigneReceptionCountOrderByAggregateInput
    _avg?: LigneReceptionAvgOrderByAggregateInput
    _max?: LigneReceptionMaxOrderByAggregateInput
    _min?: LigneReceptionMinOrderByAggregateInput
    _sum?: LigneReceptionSumOrderByAggregateInput
  }

  export type LigneReceptionScalarWhereWithAggregatesInput = {
    AND?: LigneReceptionScalarWhereWithAggregatesInput | LigneReceptionScalarWhereWithAggregatesInput[]
    OR?: LigneReceptionScalarWhereWithAggregatesInput[]
    NOT?: LigneReceptionScalarWhereWithAggregatesInput | LigneReceptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LigneReception"> | string
    receptionId?: StringWithAggregatesFilter<"LigneReception"> | string
    articleId?: StringWithAggregatesFilter<"LigneReception"> | string
    designation?: StringWithAggregatesFilter<"LigneReception"> | string
    quantitePrev?: FloatWithAggregatesFilter<"LigneReception"> | number
    quantiteRecue?: FloatWithAggregatesFilter<"LigneReception"> | number
    prixUnitaire?: FloatWithAggregatesFilter<"LigneReception"> | number
    tva?: FloatNullableWithAggregatesFilter<"LigneReception"> | number | null
    ecart?: FloatWithAggregatesFilter<"LigneReception"> | number
    notes?: StringNullableWithAggregatesFilter<"LigneReception"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LigneReception"> | Date | string
  }

  export type ArticleCreateInput = {
    id?: string
    reference: string
    nom: string
    description?: string | null
    categorie: string
    unite?: $Enums.Unite
    prixAchat?: number
    prixVente?: number
    quantiteStock?: number
    seuilAlerte?: number
    seuilRupture?: number
    emplacement?: string | null
    fournisseurId?: string | null
    status?: $Enums.StatusArticle
    createdAt?: Date | string
    updatedAt?: Date | string
    mouvements?: MouvementStockCreateNestedManyWithoutArticleInput
    lignesInventaire?: LigneInventaireCreateNestedManyWithoutArticleInput
    lignesReception?: LigneReceptionCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateInput = {
    id?: string
    reference: string
    nom: string
    description?: string | null
    categorie: string
    unite?: $Enums.Unite
    prixAchat?: number
    prixVente?: number
    quantiteStock?: number
    seuilAlerte?: number
    seuilRupture?: number
    emplacement?: string | null
    fournisseurId?: string | null
    status?: $Enums.StatusArticle
    createdAt?: Date | string
    updatedAt?: Date | string
    mouvements?: MouvementStockUncheckedCreateNestedManyWithoutArticleInput
    lignesInventaire?: LigneInventaireUncheckedCreateNestedManyWithoutArticleInput
    lignesReception?: LigneReceptionUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    unite?: EnumUniteFieldUpdateOperationsInput | $Enums.Unite
    prixAchat?: FloatFieldUpdateOperationsInput | number
    prixVente?: FloatFieldUpdateOperationsInput | number
    quantiteStock?: FloatFieldUpdateOperationsInput | number
    seuilAlerte?: FloatFieldUpdateOperationsInput | number
    seuilRupture?: FloatFieldUpdateOperationsInput | number
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    fournisseurId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusArticleFieldUpdateOperationsInput | $Enums.StatusArticle
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mouvements?: MouvementStockUpdateManyWithoutArticleNestedInput
    lignesInventaire?: LigneInventaireUpdateManyWithoutArticleNestedInput
    lignesReception?: LigneReceptionUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    unite?: EnumUniteFieldUpdateOperationsInput | $Enums.Unite
    prixAchat?: FloatFieldUpdateOperationsInput | number
    prixVente?: FloatFieldUpdateOperationsInput | number
    quantiteStock?: FloatFieldUpdateOperationsInput | number
    seuilAlerte?: FloatFieldUpdateOperationsInput | number
    seuilRupture?: FloatFieldUpdateOperationsInput | number
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    fournisseurId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusArticleFieldUpdateOperationsInput | $Enums.StatusArticle
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mouvements?: MouvementStockUncheckedUpdateManyWithoutArticleNestedInput
    lignesInventaire?: LigneInventaireUncheckedUpdateManyWithoutArticleNestedInput
    lignesReception?: LigneReceptionUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ArticleCreateManyInput = {
    id?: string
    reference: string
    nom: string
    description?: string | null
    categorie: string
    unite?: $Enums.Unite
    prixAchat?: number
    prixVente?: number
    quantiteStock?: number
    seuilAlerte?: number
    seuilRupture?: number
    emplacement?: string | null
    fournisseurId?: string | null
    status?: $Enums.StatusArticle
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArticleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    unite?: EnumUniteFieldUpdateOperationsInput | $Enums.Unite
    prixAchat?: FloatFieldUpdateOperationsInput | number
    prixVente?: FloatFieldUpdateOperationsInput | number
    quantiteStock?: FloatFieldUpdateOperationsInput | number
    seuilAlerte?: FloatFieldUpdateOperationsInput | number
    seuilRupture?: FloatFieldUpdateOperationsInput | number
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    fournisseurId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusArticleFieldUpdateOperationsInput | $Enums.StatusArticle
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    unite?: EnumUniteFieldUpdateOperationsInput | $Enums.Unite
    prixAchat?: FloatFieldUpdateOperationsInput | number
    prixVente?: FloatFieldUpdateOperationsInput | number
    quantiteStock?: FloatFieldUpdateOperationsInput | number
    seuilAlerte?: FloatFieldUpdateOperationsInput | number
    seuilRupture?: FloatFieldUpdateOperationsInput | number
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    fournisseurId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusArticleFieldUpdateOperationsInput | $Enums.StatusArticle
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementStockCreateInput = {
    id?: string
    type: $Enums.TypeMouvement
    quantite: number
    dateOperation?: Date | string
    utilisateurId: string
    numeroDocument?: string | null
    emplacement?: string | null
    notes?: string | null
    createdAt?: Date | string
    article: ArticleCreateNestedOneWithoutMouvementsInput
  }

  export type MouvementStockUncheckedCreateInput = {
    id?: string
    articleId: string
    type: $Enums.TypeMouvement
    quantite: number
    dateOperation?: Date | string
    utilisateurId: string
    numeroDocument?: string | null
    emplacement?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type MouvementStockUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeMouvementFieldUpdateOperationsInput | $Enums.TypeMouvement
    quantite?: FloatFieldUpdateOperationsInput | number
    dateOperation?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateurId?: StringFieldUpdateOperationsInput | string
    numeroDocument?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: ArticleUpdateOneRequiredWithoutMouvementsNestedInput
  }

  export type MouvementStockUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeMouvementFieldUpdateOperationsInput | $Enums.TypeMouvement
    quantite?: FloatFieldUpdateOperationsInput | number
    dateOperation?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateurId?: StringFieldUpdateOperationsInput | string
    numeroDocument?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementStockCreateManyInput = {
    id?: string
    articleId: string
    type: $Enums.TypeMouvement
    quantite: number
    dateOperation?: Date | string
    utilisateurId: string
    numeroDocument?: string | null
    emplacement?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type MouvementStockUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeMouvementFieldUpdateOperationsInput | $Enums.TypeMouvement
    quantite?: FloatFieldUpdateOperationsInput | number
    dateOperation?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateurId?: StringFieldUpdateOperationsInput | string
    numeroDocument?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementStockUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeMouvementFieldUpdateOperationsInput | $Enums.TypeMouvement
    quantite?: FloatFieldUpdateOperationsInput | number
    dateOperation?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateurId?: StringFieldUpdateOperationsInput | string
    numeroDocument?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventaireCreateInput = {
    id?: string
    numeroInventaire: string
    dateDebut: Date | string
    dateFin?: Date | string | null
    status?: $Enums.StatusInventaire
    nbArticles?: number
    nbEcarts?: number
    montantEcart?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lignes?: LigneInventaireCreateNestedManyWithoutInventaireInput
  }

  export type InventaireUncheckedCreateInput = {
    id?: string
    numeroInventaire: string
    dateDebut: Date | string
    dateFin?: Date | string | null
    status?: $Enums.StatusInventaire
    nbArticles?: number
    nbEcarts?: number
    montantEcart?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lignes?: LigneInventaireUncheckedCreateNestedManyWithoutInventaireInput
  }

  export type InventaireUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroInventaire?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusInventaireFieldUpdateOperationsInput | $Enums.StatusInventaire
    nbArticles?: IntFieldUpdateOperationsInput | number
    nbEcarts?: IntFieldUpdateOperationsInput | number
    montantEcart?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lignes?: LigneInventaireUpdateManyWithoutInventaireNestedInput
  }

  export type InventaireUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroInventaire?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusInventaireFieldUpdateOperationsInput | $Enums.StatusInventaire
    nbArticles?: IntFieldUpdateOperationsInput | number
    nbEcarts?: IntFieldUpdateOperationsInput | number
    montantEcart?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lignes?: LigneInventaireUncheckedUpdateManyWithoutInventaireNestedInput
  }

  export type InventaireCreateManyInput = {
    id?: string
    numeroInventaire: string
    dateDebut: Date | string
    dateFin?: Date | string | null
    status?: $Enums.StatusInventaire
    nbArticles?: number
    nbEcarts?: number
    montantEcart?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventaireUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroInventaire?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusInventaireFieldUpdateOperationsInput | $Enums.StatusInventaire
    nbArticles?: IntFieldUpdateOperationsInput | number
    nbEcarts?: IntFieldUpdateOperationsInput | number
    montantEcart?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventaireUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroInventaire?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusInventaireFieldUpdateOperationsInput | $Enums.StatusInventaire
    nbArticles?: IntFieldUpdateOperationsInput | number
    nbEcarts?: IntFieldUpdateOperationsInput | number
    montantEcart?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneInventaireCreateInput = {
    id?: string
    quantiteTheorique?: number
    quantiteReelle?: number
    ecart?: number
    valeurEcart?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventaire: InventaireCreateNestedOneWithoutLignesInput
    article: ArticleCreateNestedOneWithoutLignesInventaireInput
  }

  export type LigneInventaireUncheckedCreateInput = {
    id?: string
    inventaireId: string
    articleId: string
    quantiteTheorique?: number
    quantiteReelle?: number
    ecart?: number
    valeurEcart?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LigneInventaireUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantiteTheorique?: FloatFieldUpdateOperationsInput | number
    quantiteReelle?: FloatFieldUpdateOperationsInput | number
    ecart?: FloatFieldUpdateOperationsInput | number
    valeurEcart?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventaire?: InventaireUpdateOneRequiredWithoutLignesNestedInput
    article?: ArticleUpdateOneRequiredWithoutLignesInventaireNestedInput
  }

  export type LigneInventaireUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventaireId?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    quantiteTheorique?: FloatFieldUpdateOperationsInput | number
    quantiteReelle?: FloatFieldUpdateOperationsInput | number
    ecart?: FloatFieldUpdateOperationsInput | number
    valeurEcart?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneInventaireCreateManyInput = {
    id?: string
    inventaireId: string
    articleId: string
    quantiteTheorique?: number
    quantiteReelle?: number
    ecart?: number
    valeurEcart?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LigneInventaireUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantiteTheorique?: FloatFieldUpdateOperationsInput | number
    quantiteReelle?: FloatFieldUpdateOperationsInput | number
    ecart?: FloatFieldUpdateOperationsInput | number
    valeurEcart?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneInventaireUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventaireId?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    quantiteTheorique?: FloatFieldUpdateOperationsInput | number
    quantiteReelle?: FloatFieldUpdateOperationsInput | number
    ecart?: FloatFieldUpdateOperationsInput | number
    valeurEcart?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipementCreateInput = {
    id?: string
    reference: string
    nom: string
    description?: string | null
    categorie: string
    dateAchat?: Date | string | null
    valeurAchat?: number
    departement?: string | null
    utilisateurId?: string | null
    emplacement?: string | null
    status?: $Enums.StatusEquipement
    createdAt?: Date | string
    updatedAt?: Date | string
    maintenances?: MaintenanceEquipementCreateNestedManyWithoutEquipementInput
  }

  export type EquipementUncheckedCreateInput = {
    id?: string
    reference: string
    nom: string
    description?: string | null
    categorie: string
    dateAchat?: Date | string | null
    valeurAchat?: number
    departement?: string | null
    utilisateurId?: string | null
    emplacement?: string | null
    status?: $Enums.StatusEquipement
    createdAt?: Date | string
    updatedAt?: Date | string
    maintenances?: MaintenanceEquipementUncheckedCreateNestedManyWithoutEquipementInput
  }

  export type EquipementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    dateAchat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valeurAchat?: FloatFieldUpdateOperationsInput | number
    departement?: NullableStringFieldUpdateOperationsInput | string | null
    utilisateurId?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusEquipementFieldUpdateOperationsInput | $Enums.StatusEquipement
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenances?: MaintenanceEquipementUpdateManyWithoutEquipementNestedInput
  }

  export type EquipementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    dateAchat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valeurAchat?: FloatFieldUpdateOperationsInput | number
    departement?: NullableStringFieldUpdateOperationsInput | string | null
    utilisateurId?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusEquipementFieldUpdateOperationsInput | $Enums.StatusEquipement
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenances?: MaintenanceEquipementUncheckedUpdateManyWithoutEquipementNestedInput
  }

  export type EquipementCreateManyInput = {
    id?: string
    reference: string
    nom: string
    description?: string | null
    categorie: string
    dateAchat?: Date | string | null
    valeurAchat?: number
    departement?: string | null
    utilisateurId?: string | null
    emplacement?: string | null
    status?: $Enums.StatusEquipement
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    dateAchat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valeurAchat?: FloatFieldUpdateOperationsInput | number
    departement?: NullableStringFieldUpdateOperationsInput | string | null
    utilisateurId?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusEquipementFieldUpdateOperationsInput | $Enums.StatusEquipement
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    dateAchat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valeurAchat?: FloatFieldUpdateOperationsInput | number
    departement?: NullableStringFieldUpdateOperationsInput | string | null
    utilisateurId?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusEquipementFieldUpdateOperationsInput | $Enums.StatusEquipement
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceEquipementCreateInput = {
    id?: string
    type: $Enums.TypeMaintenance
    dateDebut: Date | string
    dateFin?: Date | string | null
    technicienId?: string | null
    description: string
    coutReel?: number
    status?: $Enums.StatusMaintenance
    createdAt?: Date | string
    updatedAt?: Date | string
    equipement: EquipementCreateNestedOneWithoutMaintenancesInput
  }

  export type MaintenanceEquipementUncheckedCreateInput = {
    id?: string
    equipementId: string
    type: $Enums.TypeMaintenance
    dateDebut: Date | string
    dateFin?: Date | string | null
    technicienId?: string | null
    description: string
    coutReel?: number
    status?: $Enums.StatusMaintenance
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceEquipementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeMaintenanceFieldUpdateOperationsInput | $Enums.TypeMaintenance
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    technicienId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    coutReel?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusMaintenanceFieldUpdateOperationsInput | $Enums.StatusMaintenance
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipement?: EquipementUpdateOneRequiredWithoutMaintenancesNestedInput
  }

  export type MaintenanceEquipementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipementId?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeMaintenanceFieldUpdateOperationsInput | $Enums.TypeMaintenance
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    technicienId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    coutReel?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusMaintenanceFieldUpdateOperationsInput | $Enums.StatusMaintenance
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceEquipementCreateManyInput = {
    id?: string
    equipementId: string
    type: $Enums.TypeMaintenance
    dateDebut: Date | string
    dateFin?: Date | string | null
    technicienId?: string | null
    description: string
    coutReel?: number
    status?: $Enums.StatusMaintenance
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceEquipementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeMaintenanceFieldUpdateOperationsInput | $Enums.TypeMaintenance
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    technicienId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    coutReel?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusMaintenanceFieldUpdateOperationsInput | $Enums.StatusMaintenance
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceEquipementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipementId?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeMaintenanceFieldUpdateOperationsInput | $Enums.TypeMaintenance
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    technicienId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    coutReel?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusMaintenanceFieldUpdateOperationsInput | $Enums.StatusMaintenance
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceptionCreateInput = {
    id?: string
    numero: string
    bonCommandeId: string
    fournisseurId?: string | null
    dateReception?: Date | string
    status?: $Enums.StatusReception
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lignes?: LigneReceptionCreateNestedManyWithoutReceptionInput
  }

  export type ReceptionUncheckedCreateInput = {
    id?: string
    numero: string
    bonCommandeId: string
    fournisseurId?: string | null
    dateReception?: Date | string
    status?: $Enums.StatusReception
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lignes?: LigneReceptionUncheckedCreateNestedManyWithoutReceptionInput
  }

  export type ReceptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    bonCommandeId?: StringFieldUpdateOperationsInput | string
    fournisseurId?: NullableStringFieldUpdateOperationsInput | string | null
    dateReception?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusReceptionFieldUpdateOperationsInput | $Enums.StatusReception
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lignes?: LigneReceptionUpdateManyWithoutReceptionNestedInput
  }

  export type ReceptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    bonCommandeId?: StringFieldUpdateOperationsInput | string
    fournisseurId?: NullableStringFieldUpdateOperationsInput | string | null
    dateReception?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusReceptionFieldUpdateOperationsInput | $Enums.StatusReception
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lignes?: LigneReceptionUncheckedUpdateManyWithoutReceptionNestedInput
  }

  export type ReceptionCreateManyInput = {
    id?: string
    numero: string
    bonCommandeId: string
    fournisseurId?: string | null
    dateReception?: Date | string
    status?: $Enums.StatusReception
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    bonCommandeId?: StringFieldUpdateOperationsInput | string
    fournisseurId?: NullableStringFieldUpdateOperationsInput | string | null
    dateReception?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusReceptionFieldUpdateOperationsInput | $Enums.StatusReception
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    bonCommandeId?: StringFieldUpdateOperationsInput | string
    fournisseurId?: NullableStringFieldUpdateOperationsInput | string | null
    dateReception?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusReceptionFieldUpdateOperationsInput | $Enums.StatusReception
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneReceptionCreateInput = {
    id?: string
    designation: string
    quantitePrev?: number
    quantiteRecue?: number
    prixUnitaire?: number
    tva?: number | null
    ecart?: number
    notes?: string | null
    createdAt?: Date | string
    reception: ReceptionCreateNestedOneWithoutLignesInput
    article: ArticleCreateNestedOneWithoutLignesReceptionInput
  }

  export type LigneReceptionUncheckedCreateInput = {
    id?: string
    receptionId: string
    articleId: string
    designation: string
    quantitePrev?: number
    quantiteRecue?: number
    prixUnitaire?: number
    tva?: number | null
    ecart?: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type LigneReceptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    quantitePrev?: FloatFieldUpdateOperationsInput | number
    quantiteRecue?: FloatFieldUpdateOperationsInput | number
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    tva?: NullableFloatFieldUpdateOperationsInput | number | null
    ecart?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reception?: ReceptionUpdateOneRequiredWithoutLignesNestedInput
    article?: ArticleUpdateOneRequiredWithoutLignesReceptionNestedInput
  }

  export type LigneReceptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    receptionId?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    quantitePrev?: FloatFieldUpdateOperationsInput | number
    quantiteRecue?: FloatFieldUpdateOperationsInput | number
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    tva?: NullableFloatFieldUpdateOperationsInput | number | null
    ecart?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneReceptionCreateManyInput = {
    id?: string
    receptionId: string
    articleId: string
    designation: string
    quantitePrev?: number
    quantiteRecue?: number
    prixUnitaire?: number
    tva?: number | null
    ecart?: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type LigneReceptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    quantitePrev?: FloatFieldUpdateOperationsInput | number
    quantiteRecue?: FloatFieldUpdateOperationsInput | number
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    tva?: NullableFloatFieldUpdateOperationsInput | number | null
    ecart?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneReceptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    receptionId?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    quantitePrev?: FloatFieldUpdateOperationsInput | number
    quantiteRecue?: FloatFieldUpdateOperationsInput | number
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    tva?: NullableFloatFieldUpdateOperationsInput | number | null
    ecart?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUniteFilter<$PrismaModel = never> = {
    equals?: $Enums.Unite | EnumUniteFieldRefInput<$PrismaModel>
    in?: $Enums.Unite[] | ListEnumUniteFieldRefInput<$PrismaModel>
    notIn?: $Enums.Unite[] | ListEnumUniteFieldRefInput<$PrismaModel>
    not?: NestedEnumUniteFilter<$PrismaModel> | $Enums.Unite
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumStatusArticleFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusArticle | EnumStatusArticleFieldRefInput<$PrismaModel>
    in?: $Enums.StatusArticle[] | ListEnumStatusArticleFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusArticle[] | ListEnumStatusArticleFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusArticleFilter<$PrismaModel> | $Enums.StatusArticle
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type MouvementStockListRelationFilter = {
    every?: MouvementStockWhereInput
    some?: MouvementStockWhereInput
    none?: MouvementStockWhereInput
  }

  export type LigneInventaireListRelationFilter = {
    every?: LigneInventaireWhereInput
    some?: LigneInventaireWhereInput
    none?: LigneInventaireWhereInput
  }

  export type LigneReceptionListRelationFilter = {
    every?: LigneReceptionWhereInput
    some?: LigneReceptionWhereInput
    none?: LigneReceptionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type MouvementStockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LigneInventaireOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LigneReceptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArticleCountOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    categorie?: SortOrder
    unite?: SortOrder
    prixAchat?: SortOrder
    prixVente?: SortOrder
    quantiteStock?: SortOrder
    seuilAlerte?: SortOrder
    seuilRupture?: SortOrder
    emplacement?: SortOrder
    fournisseurId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArticleAvgOrderByAggregateInput = {
    prixAchat?: SortOrder
    prixVente?: SortOrder
    quantiteStock?: SortOrder
    seuilAlerte?: SortOrder
    seuilRupture?: SortOrder
  }

  export type ArticleMaxOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    categorie?: SortOrder
    unite?: SortOrder
    prixAchat?: SortOrder
    prixVente?: SortOrder
    quantiteStock?: SortOrder
    seuilAlerte?: SortOrder
    seuilRupture?: SortOrder
    emplacement?: SortOrder
    fournisseurId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArticleMinOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    categorie?: SortOrder
    unite?: SortOrder
    prixAchat?: SortOrder
    prixVente?: SortOrder
    quantiteStock?: SortOrder
    seuilAlerte?: SortOrder
    seuilRupture?: SortOrder
    emplacement?: SortOrder
    fournisseurId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArticleSumOrderByAggregateInput = {
    prixAchat?: SortOrder
    prixVente?: SortOrder
    quantiteStock?: SortOrder
    seuilAlerte?: SortOrder
    seuilRupture?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUniteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Unite | EnumUniteFieldRefInput<$PrismaModel>
    in?: $Enums.Unite[] | ListEnumUniteFieldRefInput<$PrismaModel>
    notIn?: $Enums.Unite[] | ListEnumUniteFieldRefInput<$PrismaModel>
    not?: NestedEnumUniteWithAggregatesFilter<$PrismaModel> | $Enums.Unite
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUniteFilter<$PrismaModel>
    _max?: NestedEnumUniteFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumStatusArticleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusArticle | EnumStatusArticleFieldRefInput<$PrismaModel>
    in?: $Enums.StatusArticle[] | ListEnumStatusArticleFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusArticle[] | ListEnumStatusArticleFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusArticleWithAggregatesFilter<$PrismaModel> | $Enums.StatusArticle
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusArticleFilter<$PrismaModel>
    _max?: NestedEnumStatusArticleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumTypeMouvementFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeMouvement | EnumTypeMouvementFieldRefInput<$PrismaModel>
    in?: $Enums.TypeMouvement[] | ListEnumTypeMouvementFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeMouvement[] | ListEnumTypeMouvementFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeMouvementFilter<$PrismaModel> | $Enums.TypeMouvement
  }

  export type ArticleRelationFilter = {
    is?: ArticleWhereInput
    isNot?: ArticleWhereInput
  }

  export type MouvementStockCountOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    type?: SortOrder
    quantite?: SortOrder
    dateOperation?: SortOrder
    utilisateurId?: SortOrder
    numeroDocument?: SortOrder
    emplacement?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type MouvementStockAvgOrderByAggregateInput = {
    quantite?: SortOrder
  }

  export type MouvementStockMaxOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    type?: SortOrder
    quantite?: SortOrder
    dateOperation?: SortOrder
    utilisateurId?: SortOrder
    numeroDocument?: SortOrder
    emplacement?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type MouvementStockMinOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    type?: SortOrder
    quantite?: SortOrder
    dateOperation?: SortOrder
    utilisateurId?: SortOrder
    numeroDocument?: SortOrder
    emplacement?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type MouvementStockSumOrderByAggregateInput = {
    quantite?: SortOrder
  }

  export type EnumTypeMouvementWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeMouvement | EnumTypeMouvementFieldRefInput<$PrismaModel>
    in?: $Enums.TypeMouvement[] | ListEnumTypeMouvementFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeMouvement[] | ListEnumTypeMouvementFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeMouvementWithAggregatesFilter<$PrismaModel> | $Enums.TypeMouvement
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeMouvementFilter<$PrismaModel>
    _max?: NestedEnumTypeMouvementFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumStatusInventaireFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusInventaire | EnumStatusInventaireFieldRefInput<$PrismaModel>
    in?: $Enums.StatusInventaire[] | ListEnumStatusInventaireFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusInventaire[] | ListEnumStatusInventaireFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusInventaireFilter<$PrismaModel> | $Enums.StatusInventaire
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type InventaireCountOrderByAggregateInput = {
    id?: SortOrder
    numeroInventaire?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    status?: SortOrder
    nbArticles?: SortOrder
    nbEcarts?: SortOrder
    montantEcart?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventaireAvgOrderByAggregateInput = {
    nbArticles?: SortOrder
    nbEcarts?: SortOrder
    montantEcart?: SortOrder
  }

  export type InventaireMaxOrderByAggregateInput = {
    id?: SortOrder
    numeroInventaire?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    status?: SortOrder
    nbArticles?: SortOrder
    nbEcarts?: SortOrder
    montantEcart?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventaireMinOrderByAggregateInput = {
    id?: SortOrder
    numeroInventaire?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    status?: SortOrder
    nbArticles?: SortOrder
    nbEcarts?: SortOrder
    montantEcart?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventaireSumOrderByAggregateInput = {
    nbArticles?: SortOrder
    nbEcarts?: SortOrder
    montantEcart?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumStatusInventaireWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusInventaire | EnumStatusInventaireFieldRefInput<$PrismaModel>
    in?: $Enums.StatusInventaire[] | ListEnumStatusInventaireFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusInventaire[] | ListEnumStatusInventaireFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusInventaireWithAggregatesFilter<$PrismaModel> | $Enums.StatusInventaire
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusInventaireFilter<$PrismaModel>
    _max?: NestedEnumStatusInventaireFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type InventaireRelationFilter = {
    is?: InventaireWhereInput
    isNot?: InventaireWhereInput
  }

  export type LigneInventaireCountOrderByAggregateInput = {
    id?: SortOrder
    inventaireId?: SortOrder
    articleId?: SortOrder
    quantiteTheorique?: SortOrder
    quantiteReelle?: SortOrder
    ecart?: SortOrder
    valeurEcart?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LigneInventaireAvgOrderByAggregateInput = {
    quantiteTheorique?: SortOrder
    quantiteReelle?: SortOrder
    ecart?: SortOrder
    valeurEcart?: SortOrder
  }

  export type LigneInventaireMaxOrderByAggregateInput = {
    id?: SortOrder
    inventaireId?: SortOrder
    articleId?: SortOrder
    quantiteTheorique?: SortOrder
    quantiteReelle?: SortOrder
    ecart?: SortOrder
    valeurEcart?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LigneInventaireMinOrderByAggregateInput = {
    id?: SortOrder
    inventaireId?: SortOrder
    articleId?: SortOrder
    quantiteTheorique?: SortOrder
    quantiteReelle?: SortOrder
    ecart?: SortOrder
    valeurEcart?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LigneInventaireSumOrderByAggregateInput = {
    quantiteTheorique?: SortOrder
    quantiteReelle?: SortOrder
    ecart?: SortOrder
    valeurEcart?: SortOrder
  }

  export type EnumStatusEquipementFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusEquipement | EnumStatusEquipementFieldRefInput<$PrismaModel>
    in?: $Enums.StatusEquipement[] | ListEnumStatusEquipementFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusEquipement[] | ListEnumStatusEquipementFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusEquipementFilter<$PrismaModel> | $Enums.StatusEquipement
  }

  export type MaintenanceEquipementListRelationFilter = {
    every?: MaintenanceEquipementWhereInput
    some?: MaintenanceEquipementWhereInput
    none?: MaintenanceEquipementWhereInput
  }

  export type MaintenanceEquipementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquipementCountOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    categorie?: SortOrder
    dateAchat?: SortOrder
    valeurAchat?: SortOrder
    departement?: SortOrder
    utilisateurId?: SortOrder
    emplacement?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipementAvgOrderByAggregateInput = {
    valeurAchat?: SortOrder
  }

  export type EquipementMaxOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    categorie?: SortOrder
    dateAchat?: SortOrder
    valeurAchat?: SortOrder
    departement?: SortOrder
    utilisateurId?: SortOrder
    emplacement?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipementMinOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    categorie?: SortOrder
    dateAchat?: SortOrder
    valeurAchat?: SortOrder
    departement?: SortOrder
    utilisateurId?: SortOrder
    emplacement?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipementSumOrderByAggregateInput = {
    valeurAchat?: SortOrder
  }

  export type EnumStatusEquipementWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusEquipement | EnumStatusEquipementFieldRefInput<$PrismaModel>
    in?: $Enums.StatusEquipement[] | ListEnumStatusEquipementFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusEquipement[] | ListEnumStatusEquipementFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusEquipementWithAggregatesFilter<$PrismaModel> | $Enums.StatusEquipement
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusEquipementFilter<$PrismaModel>
    _max?: NestedEnumStatusEquipementFilter<$PrismaModel>
  }

  export type EnumTypeMaintenanceFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeMaintenance | EnumTypeMaintenanceFieldRefInput<$PrismaModel>
    in?: $Enums.TypeMaintenance[] | ListEnumTypeMaintenanceFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeMaintenance[] | ListEnumTypeMaintenanceFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeMaintenanceFilter<$PrismaModel> | $Enums.TypeMaintenance
  }

  export type EnumStatusMaintenanceFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusMaintenance | EnumStatusMaintenanceFieldRefInput<$PrismaModel>
    in?: $Enums.StatusMaintenance[] | ListEnumStatusMaintenanceFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusMaintenance[] | ListEnumStatusMaintenanceFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusMaintenanceFilter<$PrismaModel> | $Enums.StatusMaintenance
  }

  export type EquipementRelationFilter = {
    is?: EquipementWhereInput
    isNot?: EquipementWhereInput
  }

  export type MaintenanceEquipementCountOrderByAggregateInput = {
    id?: SortOrder
    equipementId?: SortOrder
    type?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    technicienId?: SortOrder
    description?: SortOrder
    coutReel?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaintenanceEquipementAvgOrderByAggregateInput = {
    coutReel?: SortOrder
  }

  export type MaintenanceEquipementMaxOrderByAggregateInput = {
    id?: SortOrder
    equipementId?: SortOrder
    type?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    technicienId?: SortOrder
    description?: SortOrder
    coutReel?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaintenanceEquipementMinOrderByAggregateInput = {
    id?: SortOrder
    equipementId?: SortOrder
    type?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    technicienId?: SortOrder
    description?: SortOrder
    coutReel?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaintenanceEquipementSumOrderByAggregateInput = {
    coutReel?: SortOrder
  }

  export type EnumTypeMaintenanceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeMaintenance | EnumTypeMaintenanceFieldRefInput<$PrismaModel>
    in?: $Enums.TypeMaintenance[] | ListEnumTypeMaintenanceFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeMaintenance[] | ListEnumTypeMaintenanceFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeMaintenanceWithAggregatesFilter<$PrismaModel> | $Enums.TypeMaintenance
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeMaintenanceFilter<$PrismaModel>
    _max?: NestedEnumTypeMaintenanceFilter<$PrismaModel>
  }

  export type EnumStatusMaintenanceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusMaintenance | EnumStatusMaintenanceFieldRefInput<$PrismaModel>
    in?: $Enums.StatusMaintenance[] | ListEnumStatusMaintenanceFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusMaintenance[] | ListEnumStatusMaintenanceFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusMaintenanceWithAggregatesFilter<$PrismaModel> | $Enums.StatusMaintenance
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusMaintenanceFilter<$PrismaModel>
    _max?: NestedEnumStatusMaintenanceFilter<$PrismaModel>
  }

  export type EnumStatusReceptionFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusReception | EnumStatusReceptionFieldRefInput<$PrismaModel>
    in?: $Enums.StatusReception[] | ListEnumStatusReceptionFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusReception[] | ListEnumStatusReceptionFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusReceptionFilter<$PrismaModel> | $Enums.StatusReception
  }

  export type ReceptionCountOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    bonCommandeId?: SortOrder
    fournisseurId?: SortOrder
    dateReception?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReceptionMaxOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    bonCommandeId?: SortOrder
    fournisseurId?: SortOrder
    dateReception?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReceptionMinOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    bonCommandeId?: SortOrder
    fournisseurId?: SortOrder
    dateReception?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStatusReceptionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusReception | EnumStatusReceptionFieldRefInput<$PrismaModel>
    in?: $Enums.StatusReception[] | ListEnumStatusReceptionFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusReception[] | ListEnumStatusReceptionFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusReceptionWithAggregatesFilter<$PrismaModel> | $Enums.StatusReception
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusReceptionFilter<$PrismaModel>
    _max?: NestedEnumStatusReceptionFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ReceptionRelationFilter = {
    is?: ReceptionWhereInput
    isNot?: ReceptionWhereInput
  }

  export type LigneReceptionCountOrderByAggregateInput = {
    id?: SortOrder
    receptionId?: SortOrder
    articleId?: SortOrder
    designation?: SortOrder
    quantitePrev?: SortOrder
    quantiteRecue?: SortOrder
    prixUnitaire?: SortOrder
    tva?: SortOrder
    ecart?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type LigneReceptionAvgOrderByAggregateInput = {
    quantitePrev?: SortOrder
    quantiteRecue?: SortOrder
    prixUnitaire?: SortOrder
    tva?: SortOrder
    ecart?: SortOrder
  }

  export type LigneReceptionMaxOrderByAggregateInput = {
    id?: SortOrder
    receptionId?: SortOrder
    articleId?: SortOrder
    designation?: SortOrder
    quantitePrev?: SortOrder
    quantiteRecue?: SortOrder
    prixUnitaire?: SortOrder
    tva?: SortOrder
    ecart?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type LigneReceptionMinOrderByAggregateInput = {
    id?: SortOrder
    receptionId?: SortOrder
    articleId?: SortOrder
    designation?: SortOrder
    quantitePrev?: SortOrder
    quantiteRecue?: SortOrder
    prixUnitaire?: SortOrder
    tva?: SortOrder
    ecart?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type LigneReceptionSumOrderByAggregateInput = {
    quantitePrev?: SortOrder
    quantiteRecue?: SortOrder
    prixUnitaire?: SortOrder
    tva?: SortOrder
    ecart?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type MouvementStockCreateNestedManyWithoutArticleInput = {
    create?: XOR<MouvementStockCreateWithoutArticleInput, MouvementStockUncheckedCreateWithoutArticleInput> | MouvementStockCreateWithoutArticleInput[] | MouvementStockUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: MouvementStockCreateOrConnectWithoutArticleInput | MouvementStockCreateOrConnectWithoutArticleInput[]
    createMany?: MouvementStockCreateManyArticleInputEnvelope
    connect?: MouvementStockWhereUniqueInput | MouvementStockWhereUniqueInput[]
  }

  export type LigneInventaireCreateNestedManyWithoutArticleInput = {
    create?: XOR<LigneInventaireCreateWithoutArticleInput, LigneInventaireUncheckedCreateWithoutArticleInput> | LigneInventaireCreateWithoutArticleInput[] | LigneInventaireUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: LigneInventaireCreateOrConnectWithoutArticleInput | LigneInventaireCreateOrConnectWithoutArticleInput[]
    createMany?: LigneInventaireCreateManyArticleInputEnvelope
    connect?: LigneInventaireWhereUniqueInput | LigneInventaireWhereUniqueInput[]
  }

  export type LigneReceptionCreateNestedManyWithoutArticleInput = {
    create?: XOR<LigneReceptionCreateWithoutArticleInput, LigneReceptionUncheckedCreateWithoutArticleInput> | LigneReceptionCreateWithoutArticleInput[] | LigneReceptionUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: LigneReceptionCreateOrConnectWithoutArticleInput | LigneReceptionCreateOrConnectWithoutArticleInput[]
    createMany?: LigneReceptionCreateManyArticleInputEnvelope
    connect?: LigneReceptionWhereUniqueInput | LigneReceptionWhereUniqueInput[]
  }

  export type MouvementStockUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<MouvementStockCreateWithoutArticleInput, MouvementStockUncheckedCreateWithoutArticleInput> | MouvementStockCreateWithoutArticleInput[] | MouvementStockUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: MouvementStockCreateOrConnectWithoutArticleInput | MouvementStockCreateOrConnectWithoutArticleInput[]
    createMany?: MouvementStockCreateManyArticleInputEnvelope
    connect?: MouvementStockWhereUniqueInput | MouvementStockWhereUniqueInput[]
  }

  export type LigneInventaireUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<LigneInventaireCreateWithoutArticleInput, LigneInventaireUncheckedCreateWithoutArticleInput> | LigneInventaireCreateWithoutArticleInput[] | LigneInventaireUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: LigneInventaireCreateOrConnectWithoutArticleInput | LigneInventaireCreateOrConnectWithoutArticleInput[]
    createMany?: LigneInventaireCreateManyArticleInputEnvelope
    connect?: LigneInventaireWhereUniqueInput | LigneInventaireWhereUniqueInput[]
  }

  export type LigneReceptionUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<LigneReceptionCreateWithoutArticleInput, LigneReceptionUncheckedCreateWithoutArticleInput> | LigneReceptionCreateWithoutArticleInput[] | LigneReceptionUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: LigneReceptionCreateOrConnectWithoutArticleInput | LigneReceptionCreateOrConnectWithoutArticleInput[]
    createMany?: LigneReceptionCreateManyArticleInputEnvelope
    connect?: LigneReceptionWhereUniqueInput | LigneReceptionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUniteFieldUpdateOperationsInput = {
    set?: $Enums.Unite
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumStatusArticleFieldUpdateOperationsInput = {
    set?: $Enums.StatusArticle
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type MouvementStockUpdateManyWithoutArticleNestedInput = {
    create?: XOR<MouvementStockCreateWithoutArticleInput, MouvementStockUncheckedCreateWithoutArticleInput> | MouvementStockCreateWithoutArticleInput[] | MouvementStockUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: MouvementStockCreateOrConnectWithoutArticleInput | MouvementStockCreateOrConnectWithoutArticleInput[]
    upsert?: MouvementStockUpsertWithWhereUniqueWithoutArticleInput | MouvementStockUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: MouvementStockCreateManyArticleInputEnvelope
    set?: MouvementStockWhereUniqueInput | MouvementStockWhereUniqueInput[]
    disconnect?: MouvementStockWhereUniqueInput | MouvementStockWhereUniqueInput[]
    delete?: MouvementStockWhereUniqueInput | MouvementStockWhereUniqueInput[]
    connect?: MouvementStockWhereUniqueInput | MouvementStockWhereUniqueInput[]
    update?: MouvementStockUpdateWithWhereUniqueWithoutArticleInput | MouvementStockUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: MouvementStockUpdateManyWithWhereWithoutArticleInput | MouvementStockUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: MouvementStockScalarWhereInput | MouvementStockScalarWhereInput[]
  }

  export type LigneInventaireUpdateManyWithoutArticleNestedInput = {
    create?: XOR<LigneInventaireCreateWithoutArticleInput, LigneInventaireUncheckedCreateWithoutArticleInput> | LigneInventaireCreateWithoutArticleInput[] | LigneInventaireUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: LigneInventaireCreateOrConnectWithoutArticleInput | LigneInventaireCreateOrConnectWithoutArticleInput[]
    upsert?: LigneInventaireUpsertWithWhereUniqueWithoutArticleInput | LigneInventaireUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: LigneInventaireCreateManyArticleInputEnvelope
    set?: LigneInventaireWhereUniqueInput | LigneInventaireWhereUniqueInput[]
    disconnect?: LigneInventaireWhereUniqueInput | LigneInventaireWhereUniqueInput[]
    delete?: LigneInventaireWhereUniqueInput | LigneInventaireWhereUniqueInput[]
    connect?: LigneInventaireWhereUniqueInput | LigneInventaireWhereUniqueInput[]
    update?: LigneInventaireUpdateWithWhereUniqueWithoutArticleInput | LigneInventaireUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: LigneInventaireUpdateManyWithWhereWithoutArticleInput | LigneInventaireUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: LigneInventaireScalarWhereInput | LigneInventaireScalarWhereInput[]
  }

  export type LigneReceptionUpdateManyWithoutArticleNestedInput = {
    create?: XOR<LigneReceptionCreateWithoutArticleInput, LigneReceptionUncheckedCreateWithoutArticleInput> | LigneReceptionCreateWithoutArticleInput[] | LigneReceptionUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: LigneReceptionCreateOrConnectWithoutArticleInput | LigneReceptionCreateOrConnectWithoutArticleInput[]
    upsert?: LigneReceptionUpsertWithWhereUniqueWithoutArticleInput | LigneReceptionUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: LigneReceptionCreateManyArticleInputEnvelope
    set?: LigneReceptionWhereUniqueInput | LigneReceptionWhereUniqueInput[]
    disconnect?: LigneReceptionWhereUniqueInput | LigneReceptionWhereUniqueInput[]
    delete?: LigneReceptionWhereUniqueInput | LigneReceptionWhereUniqueInput[]
    connect?: LigneReceptionWhereUniqueInput | LigneReceptionWhereUniqueInput[]
    update?: LigneReceptionUpdateWithWhereUniqueWithoutArticleInput | LigneReceptionUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: LigneReceptionUpdateManyWithWhereWithoutArticleInput | LigneReceptionUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: LigneReceptionScalarWhereInput | LigneReceptionScalarWhereInput[]
  }

  export type MouvementStockUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<MouvementStockCreateWithoutArticleInput, MouvementStockUncheckedCreateWithoutArticleInput> | MouvementStockCreateWithoutArticleInput[] | MouvementStockUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: MouvementStockCreateOrConnectWithoutArticleInput | MouvementStockCreateOrConnectWithoutArticleInput[]
    upsert?: MouvementStockUpsertWithWhereUniqueWithoutArticleInput | MouvementStockUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: MouvementStockCreateManyArticleInputEnvelope
    set?: MouvementStockWhereUniqueInput | MouvementStockWhereUniqueInput[]
    disconnect?: MouvementStockWhereUniqueInput | MouvementStockWhereUniqueInput[]
    delete?: MouvementStockWhereUniqueInput | MouvementStockWhereUniqueInput[]
    connect?: MouvementStockWhereUniqueInput | MouvementStockWhereUniqueInput[]
    update?: MouvementStockUpdateWithWhereUniqueWithoutArticleInput | MouvementStockUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: MouvementStockUpdateManyWithWhereWithoutArticleInput | MouvementStockUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: MouvementStockScalarWhereInput | MouvementStockScalarWhereInput[]
  }

  export type LigneInventaireUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<LigneInventaireCreateWithoutArticleInput, LigneInventaireUncheckedCreateWithoutArticleInput> | LigneInventaireCreateWithoutArticleInput[] | LigneInventaireUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: LigneInventaireCreateOrConnectWithoutArticleInput | LigneInventaireCreateOrConnectWithoutArticleInput[]
    upsert?: LigneInventaireUpsertWithWhereUniqueWithoutArticleInput | LigneInventaireUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: LigneInventaireCreateManyArticleInputEnvelope
    set?: LigneInventaireWhereUniqueInput | LigneInventaireWhereUniqueInput[]
    disconnect?: LigneInventaireWhereUniqueInput | LigneInventaireWhereUniqueInput[]
    delete?: LigneInventaireWhereUniqueInput | LigneInventaireWhereUniqueInput[]
    connect?: LigneInventaireWhereUniqueInput | LigneInventaireWhereUniqueInput[]
    update?: LigneInventaireUpdateWithWhereUniqueWithoutArticleInput | LigneInventaireUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: LigneInventaireUpdateManyWithWhereWithoutArticleInput | LigneInventaireUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: LigneInventaireScalarWhereInput | LigneInventaireScalarWhereInput[]
  }

  export type LigneReceptionUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<LigneReceptionCreateWithoutArticleInput, LigneReceptionUncheckedCreateWithoutArticleInput> | LigneReceptionCreateWithoutArticleInput[] | LigneReceptionUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: LigneReceptionCreateOrConnectWithoutArticleInput | LigneReceptionCreateOrConnectWithoutArticleInput[]
    upsert?: LigneReceptionUpsertWithWhereUniqueWithoutArticleInput | LigneReceptionUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: LigneReceptionCreateManyArticleInputEnvelope
    set?: LigneReceptionWhereUniqueInput | LigneReceptionWhereUniqueInput[]
    disconnect?: LigneReceptionWhereUniqueInput | LigneReceptionWhereUniqueInput[]
    delete?: LigneReceptionWhereUniqueInput | LigneReceptionWhereUniqueInput[]
    connect?: LigneReceptionWhereUniqueInput | LigneReceptionWhereUniqueInput[]
    update?: LigneReceptionUpdateWithWhereUniqueWithoutArticleInput | LigneReceptionUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: LigneReceptionUpdateManyWithWhereWithoutArticleInput | LigneReceptionUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: LigneReceptionScalarWhereInput | LigneReceptionScalarWhereInput[]
  }

  export type ArticleCreateNestedOneWithoutMouvementsInput = {
    create?: XOR<ArticleCreateWithoutMouvementsInput, ArticleUncheckedCreateWithoutMouvementsInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutMouvementsInput
    connect?: ArticleWhereUniqueInput
  }

  export type EnumTypeMouvementFieldUpdateOperationsInput = {
    set?: $Enums.TypeMouvement
  }

  export type ArticleUpdateOneRequiredWithoutMouvementsNestedInput = {
    create?: XOR<ArticleCreateWithoutMouvementsInput, ArticleUncheckedCreateWithoutMouvementsInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutMouvementsInput
    upsert?: ArticleUpsertWithoutMouvementsInput
    connect?: ArticleWhereUniqueInput
    update?: XOR<XOR<ArticleUpdateToOneWithWhereWithoutMouvementsInput, ArticleUpdateWithoutMouvementsInput>, ArticleUncheckedUpdateWithoutMouvementsInput>
  }

  export type LigneInventaireCreateNestedManyWithoutInventaireInput = {
    create?: XOR<LigneInventaireCreateWithoutInventaireInput, LigneInventaireUncheckedCreateWithoutInventaireInput> | LigneInventaireCreateWithoutInventaireInput[] | LigneInventaireUncheckedCreateWithoutInventaireInput[]
    connectOrCreate?: LigneInventaireCreateOrConnectWithoutInventaireInput | LigneInventaireCreateOrConnectWithoutInventaireInput[]
    createMany?: LigneInventaireCreateManyInventaireInputEnvelope
    connect?: LigneInventaireWhereUniqueInput | LigneInventaireWhereUniqueInput[]
  }

  export type LigneInventaireUncheckedCreateNestedManyWithoutInventaireInput = {
    create?: XOR<LigneInventaireCreateWithoutInventaireInput, LigneInventaireUncheckedCreateWithoutInventaireInput> | LigneInventaireCreateWithoutInventaireInput[] | LigneInventaireUncheckedCreateWithoutInventaireInput[]
    connectOrCreate?: LigneInventaireCreateOrConnectWithoutInventaireInput | LigneInventaireCreateOrConnectWithoutInventaireInput[]
    createMany?: LigneInventaireCreateManyInventaireInputEnvelope
    connect?: LigneInventaireWhereUniqueInput | LigneInventaireWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumStatusInventaireFieldUpdateOperationsInput = {
    set?: $Enums.StatusInventaire
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LigneInventaireUpdateManyWithoutInventaireNestedInput = {
    create?: XOR<LigneInventaireCreateWithoutInventaireInput, LigneInventaireUncheckedCreateWithoutInventaireInput> | LigneInventaireCreateWithoutInventaireInput[] | LigneInventaireUncheckedCreateWithoutInventaireInput[]
    connectOrCreate?: LigneInventaireCreateOrConnectWithoutInventaireInput | LigneInventaireCreateOrConnectWithoutInventaireInput[]
    upsert?: LigneInventaireUpsertWithWhereUniqueWithoutInventaireInput | LigneInventaireUpsertWithWhereUniqueWithoutInventaireInput[]
    createMany?: LigneInventaireCreateManyInventaireInputEnvelope
    set?: LigneInventaireWhereUniqueInput | LigneInventaireWhereUniqueInput[]
    disconnect?: LigneInventaireWhereUniqueInput | LigneInventaireWhereUniqueInput[]
    delete?: LigneInventaireWhereUniqueInput | LigneInventaireWhereUniqueInput[]
    connect?: LigneInventaireWhereUniqueInput | LigneInventaireWhereUniqueInput[]
    update?: LigneInventaireUpdateWithWhereUniqueWithoutInventaireInput | LigneInventaireUpdateWithWhereUniqueWithoutInventaireInput[]
    updateMany?: LigneInventaireUpdateManyWithWhereWithoutInventaireInput | LigneInventaireUpdateManyWithWhereWithoutInventaireInput[]
    deleteMany?: LigneInventaireScalarWhereInput | LigneInventaireScalarWhereInput[]
  }

  export type LigneInventaireUncheckedUpdateManyWithoutInventaireNestedInput = {
    create?: XOR<LigneInventaireCreateWithoutInventaireInput, LigneInventaireUncheckedCreateWithoutInventaireInput> | LigneInventaireCreateWithoutInventaireInput[] | LigneInventaireUncheckedCreateWithoutInventaireInput[]
    connectOrCreate?: LigneInventaireCreateOrConnectWithoutInventaireInput | LigneInventaireCreateOrConnectWithoutInventaireInput[]
    upsert?: LigneInventaireUpsertWithWhereUniqueWithoutInventaireInput | LigneInventaireUpsertWithWhereUniqueWithoutInventaireInput[]
    createMany?: LigneInventaireCreateManyInventaireInputEnvelope
    set?: LigneInventaireWhereUniqueInput | LigneInventaireWhereUniqueInput[]
    disconnect?: LigneInventaireWhereUniqueInput | LigneInventaireWhereUniqueInput[]
    delete?: LigneInventaireWhereUniqueInput | LigneInventaireWhereUniqueInput[]
    connect?: LigneInventaireWhereUniqueInput | LigneInventaireWhereUniqueInput[]
    update?: LigneInventaireUpdateWithWhereUniqueWithoutInventaireInput | LigneInventaireUpdateWithWhereUniqueWithoutInventaireInput[]
    updateMany?: LigneInventaireUpdateManyWithWhereWithoutInventaireInput | LigneInventaireUpdateManyWithWhereWithoutInventaireInput[]
    deleteMany?: LigneInventaireScalarWhereInput | LigneInventaireScalarWhereInput[]
  }

  export type InventaireCreateNestedOneWithoutLignesInput = {
    create?: XOR<InventaireCreateWithoutLignesInput, InventaireUncheckedCreateWithoutLignesInput>
    connectOrCreate?: InventaireCreateOrConnectWithoutLignesInput
    connect?: InventaireWhereUniqueInput
  }

  export type ArticleCreateNestedOneWithoutLignesInventaireInput = {
    create?: XOR<ArticleCreateWithoutLignesInventaireInput, ArticleUncheckedCreateWithoutLignesInventaireInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutLignesInventaireInput
    connect?: ArticleWhereUniqueInput
  }

  export type InventaireUpdateOneRequiredWithoutLignesNestedInput = {
    create?: XOR<InventaireCreateWithoutLignesInput, InventaireUncheckedCreateWithoutLignesInput>
    connectOrCreate?: InventaireCreateOrConnectWithoutLignesInput
    upsert?: InventaireUpsertWithoutLignesInput
    connect?: InventaireWhereUniqueInput
    update?: XOR<XOR<InventaireUpdateToOneWithWhereWithoutLignesInput, InventaireUpdateWithoutLignesInput>, InventaireUncheckedUpdateWithoutLignesInput>
  }

  export type ArticleUpdateOneRequiredWithoutLignesInventaireNestedInput = {
    create?: XOR<ArticleCreateWithoutLignesInventaireInput, ArticleUncheckedCreateWithoutLignesInventaireInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutLignesInventaireInput
    upsert?: ArticleUpsertWithoutLignesInventaireInput
    connect?: ArticleWhereUniqueInput
    update?: XOR<XOR<ArticleUpdateToOneWithWhereWithoutLignesInventaireInput, ArticleUpdateWithoutLignesInventaireInput>, ArticleUncheckedUpdateWithoutLignesInventaireInput>
  }

  export type MaintenanceEquipementCreateNestedManyWithoutEquipementInput = {
    create?: XOR<MaintenanceEquipementCreateWithoutEquipementInput, MaintenanceEquipementUncheckedCreateWithoutEquipementInput> | MaintenanceEquipementCreateWithoutEquipementInput[] | MaintenanceEquipementUncheckedCreateWithoutEquipementInput[]
    connectOrCreate?: MaintenanceEquipementCreateOrConnectWithoutEquipementInput | MaintenanceEquipementCreateOrConnectWithoutEquipementInput[]
    createMany?: MaintenanceEquipementCreateManyEquipementInputEnvelope
    connect?: MaintenanceEquipementWhereUniqueInput | MaintenanceEquipementWhereUniqueInput[]
  }

  export type MaintenanceEquipementUncheckedCreateNestedManyWithoutEquipementInput = {
    create?: XOR<MaintenanceEquipementCreateWithoutEquipementInput, MaintenanceEquipementUncheckedCreateWithoutEquipementInput> | MaintenanceEquipementCreateWithoutEquipementInput[] | MaintenanceEquipementUncheckedCreateWithoutEquipementInput[]
    connectOrCreate?: MaintenanceEquipementCreateOrConnectWithoutEquipementInput | MaintenanceEquipementCreateOrConnectWithoutEquipementInput[]
    createMany?: MaintenanceEquipementCreateManyEquipementInputEnvelope
    connect?: MaintenanceEquipementWhereUniqueInput | MaintenanceEquipementWhereUniqueInput[]
  }

  export type EnumStatusEquipementFieldUpdateOperationsInput = {
    set?: $Enums.StatusEquipement
  }

  export type MaintenanceEquipementUpdateManyWithoutEquipementNestedInput = {
    create?: XOR<MaintenanceEquipementCreateWithoutEquipementInput, MaintenanceEquipementUncheckedCreateWithoutEquipementInput> | MaintenanceEquipementCreateWithoutEquipementInput[] | MaintenanceEquipementUncheckedCreateWithoutEquipementInput[]
    connectOrCreate?: MaintenanceEquipementCreateOrConnectWithoutEquipementInput | MaintenanceEquipementCreateOrConnectWithoutEquipementInput[]
    upsert?: MaintenanceEquipementUpsertWithWhereUniqueWithoutEquipementInput | MaintenanceEquipementUpsertWithWhereUniqueWithoutEquipementInput[]
    createMany?: MaintenanceEquipementCreateManyEquipementInputEnvelope
    set?: MaintenanceEquipementWhereUniqueInput | MaintenanceEquipementWhereUniqueInput[]
    disconnect?: MaintenanceEquipementWhereUniqueInput | MaintenanceEquipementWhereUniqueInput[]
    delete?: MaintenanceEquipementWhereUniqueInput | MaintenanceEquipementWhereUniqueInput[]
    connect?: MaintenanceEquipementWhereUniqueInput | MaintenanceEquipementWhereUniqueInput[]
    update?: MaintenanceEquipementUpdateWithWhereUniqueWithoutEquipementInput | MaintenanceEquipementUpdateWithWhereUniqueWithoutEquipementInput[]
    updateMany?: MaintenanceEquipementUpdateManyWithWhereWithoutEquipementInput | MaintenanceEquipementUpdateManyWithWhereWithoutEquipementInput[]
    deleteMany?: MaintenanceEquipementScalarWhereInput | MaintenanceEquipementScalarWhereInput[]
  }

  export type MaintenanceEquipementUncheckedUpdateManyWithoutEquipementNestedInput = {
    create?: XOR<MaintenanceEquipementCreateWithoutEquipementInput, MaintenanceEquipementUncheckedCreateWithoutEquipementInput> | MaintenanceEquipementCreateWithoutEquipementInput[] | MaintenanceEquipementUncheckedCreateWithoutEquipementInput[]
    connectOrCreate?: MaintenanceEquipementCreateOrConnectWithoutEquipementInput | MaintenanceEquipementCreateOrConnectWithoutEquipementInput[]
    upsert?: MaintenanceEquipementUpsertWithWhereUniqueWithoutEquipementInput | MaintenanceEquipementUpsertWithWhereUniqueWithoutEquipementInput[]
    createMany?: MaintenanceEquipementCreateManyEquipementInputEnvelope
    set?: MaintenanceEquipementWhereUniqueInput | MaintenanceEquipementWhereUniqueInput[]
    disconnect?: MaintenanceEquipementWhereUniqueInput | MaintenanceEquipementWhereUniqueInput[]
    delete?: MaintenanceEquipementWhereUniqueInput | MaintenanceEquipementWhereUniqueInput[]
    connect?: MaintenanceEquipementWhereUniqueInput | MaintenanceEquipementWhereUniqueInput[]
    update?: MaintenanceEquipementUpdateWithWhereUniqueWithoutEquipementInput | MaintenanceEquipementUpdateWithWhereUniqueWithoutEquipementInput[]
    updateMany?: MaintenanceEquipementUpdateManyWithWhereWithoutEquipementInput | MaintenanceEquipementUpdateManyWithWhereWithoutEquipementInput[]
    deleteMany?: MaintenanceEquipementScalarWhereInput | MaintenanceEquipementScalarWhereInput[]
  }

  export type EquipementCreateNestedOneWithoutMaintenancesInput = {
    create?: XOR<EquipementCreateWithoutMaintenancesInput, EquipementUncheckedCreateWithoutMaintenancesInput>
    connectOrCreate?: EquipementCreateOrConnectWithoutMaintenancesInput
    connect?: EquipementWhereUniqueInput
  }

  export type EnumTypeMaintenanceFieldUpdateOperationsInput = {
    set?: $Enums.TypeMaintenance
  }

  export type EnumStatusMaintenanceFieldUpdateOperationsInput = {
    set?: $Enums.StatusMaintenance
  }

  export type EquipementUpdateOneRequiredWithoutMaintenancesNestedInput = {
    create?: XOR<EquipementCreateWithoutMaintenancesInput, EquipementUncheckedCreateWithoutMaintenancesInput>
    connectOrCreate?: EquipementCreateOrConnectWithoutMaintenancesInput
    upsert?: EquipementUpsertWithoutMaintenancesInput
    connect?: EquipementWhereUniqueInput
    update?: XOR<XOR<EquipementUpdateToOneWithWhereWithoutMaintenancesInput, EquipementUpdateWithoutMaintenancesInput>, EquipementUncheckedUpdateWithoutMaintenancesInput>
  }

  export type LigneReceptionCreateNestedManyWithoutReceptionInput = {
    create?: XOR<LigneReceptionCreateWithoutReceptionInput, LigneReceptionUncheckedCreateWithoutReceptionInput> | LigneReceptionCreateWithoutReceptionInput[] | LigneReceptionUncheckedCreateWithoutReceptionInput[]
    connectOrCreate?: LigneReceptionCreateOrConnectWithoutReceptionInput | LigneReceptionCreateOrConnectWithoutReceptionInput[]
    createMany?: LigneReceptionCreateManyReceptionInputEnvelope
    connect?: LigneReceptionWhereUniqueInput | LigneReceptionWhereUniqueInput[]
  }

  export type LigneReceptionUncheckedCreateNestedManyWithoutReceptionInput = {
    create?: XOR<LigneReceptionCreateWithoutReceptionInput, LigneReceptionUncheckedCreateWithoutReceptionInput> | LigneReceptionCreateWithoutReceptionInput[] | LigneReceptionUncheckedCreateWithoutReceptionInput[]
    connectOrCreate?: LigneReceptionCreateOrConnectWithoutReceptionInput | LigneReceptionCreateOrConnectWithoutReceptionInput[]
    createMany?: LigneReceptionCreateManyReceptionInputEnvelope
    connect?: LigneReceptionWhereUniqueInput | LigneReceptionWhereUniqueInput[]
  }

  export type EnumStatusReceptionFieldUpdateOperationsInput = {
    set?: $Enums.StatusReception
  }

  export type LigneReceptionUpdateManyWithoutReceptionNestedInput = {
    create?: XOR<LigneReceptionCreateWithoutReceptionInput, LigneReceptionUncheckedCreateWithoutReceptionInput> | LigneReceptionCreateWithoutReceptionInput[] | LigneReceptionUncheckedCreateWithoutReceptionInput[]
    connectOrCreate?: LigneReceptionCreateOrConnectWithoutReceptionInput | LigneReceptionCreateOrConnectWithoutReceptionInput[]
    upsert?: LigneReceptionUpsertWithWhereUniqueWithoutReceptionInput | LigneReceptionUpsertWithWhereUniqueWithoutReceptionInput[]
    createMany?: LigneReceptionCreateManyReceptionInputEnvelope
    set?: LigneReceptionWhereUniqueInput | LigneReceptionWhereUniqueInput[]
    disconnect?: LigneReceptionWhereUniqueInput | LigneReceptionWhereUniqueInput[]
    delete?: LigneReceptionWhereUniqueInput | LigneReceptionWhereUniqueInput[]
    connect?: LigneReceptionWhereUniqueInput | LigneReceptionWhereUniqueInput[]
    update?: LigneReceptionUpdateWithWhereUniqueWithoutReceptionInput | LigneReceptionUpdateWithWhereUniqueWithoutReceptionInput[]
    updateMany?: LigneReceptionUpdateManyWithWhereWithoutReceptionInput | LigneReceptionUpdateManyWithWhereWithoutReceptionInput[]
    deleteMany?: LigneReceptionScalarWhereInput | LigneReceptionScalarWhereInput[]
  }

  export type LigneReceptionUncheckedUpdateManyWithoutReceptionNestedInput = {
    create?: XOR<LigneReceptionCreateWithoutReceptionInput, LigneReceptionUncheckedCreateWithoutReceptionInput> | LigneReceptionCreateWithoutReceptionInput[] | LigneReceptionUncheckedCreateWithoutReceptionInput[]
    connectOrCreate?: LigneReceptionCreateOrConnectWithoutReceptionInput | LigneReceptionCreateOrConnectWithoutReceptionInput[]
    upsert?: LigneReceptionUpsertWithWhereUniqueWithoutReceptionInput | LigneReceptionUpsertWithWhereUniqueWithoutReceptionInput[]
    createMany?: LigneReceptionCreateManyReceptionInputEnvelope
    set?: LigneReceptionWhereUniqueInput | LigneReceptionWhereUniqueInput[]
    disconnect?: LigneReceptionWhereUniqueInput | LigneReceptionWhereUniqueInput[]
    delete?: LigneReceptionWhereUniqueInput | LigneReceptionWhereUniqueInput[]
    connect?: LigneReceptionWhereUniqueInput | LigneReceptionWhereUniqueInput[]
    update?: LigneReceptionUpdateWithWhereUniqueWithoutReceptionInput | LigneReceptionUpdateWithWhereUniqueWithoutReceptionInput[]
    updateMany?: LigneReceptionUpdateManyWithWhereWithoutReceptionInput | LigneReceptionUpdateManyWithWhereWithoutReceptionInput[]
    deleteMany?: LigneReceptionScalarWhereInput | LigneReceptionScalarWhereInput[]
  }

  export type ReceptionCreateNestedOneWithoutLignesInput = {
    create?: XOR<ReceptionCreateWithoutLignesInput, ReceptionUncheckedCreateWithoutLignesInput>
    connectOrCreate?: ReceptionCreateOrConnectWithoutLignesInput
    connect?: ReceptionWhereUniqueInput
  }

  export type ArticleCreateNestedOneWithoutLignesReceptionInput = {
    create?: XOR<ArticleCreateWithoutLignesReceptionInput, ArticleUncheckedCreateWithoutLignesReceptionInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutLignesReceptionInput
    connect?: ArticleWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ReceptionUpdateOneRequiredWithoutLignesNestedInput = {
    create?: XOR<ReceptionCreateWithoutLignesInput, ReceptionUncheckedCreateWithoutLignesInput>
    connectOrCreate?: ReceptionCreateOrConnectWithoutLignesInput
    upsert?: ReceptionUpsertWithoutLignesInput
    connect?: ReceptionWhereUniqueInput
    update?: XOR<XOR<ReceptionUpdateToOneWithWhereWithoutLignesInput, ReceptionUpdateWithoutLignesInput>, ReceptionUncheckedUpdateWithoutLignesInput>
  }

  export type ArticleUpdateOneRequiredWithoutLignesReceptionNestedInput = {
    create?: XOR<ArticleCreateWithoutLignesReceptionInput, ArticleUncheckedCreateWithoutLignesReceptionInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutLignesReceptionInput
    upsert?: ArticleUpsertWithoutLignesReceptionInput
    connect?: ArticleWhereUniqueInput
    update?: XOR<XOR<ArticleUpdateToOneWithWhereWithoutLignesReceptionInput, ArticleUpdateWithoutLignesReceptionInput>, ArticleUncheckedUpdateWithoutLignesReceptionInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUniteFilter<$PrismaModel = never> = {
    equals?: $Enums.Unite | EnumUniteFieldRefInput<$PrismaModel>
    in?: $Enums.Unite[] | ListEnumUniteFieldRefInput<$PrismaModel>
    notIn?: $Enums.Unite[] | ListEnumUniteFieldRefInput<$PrismaModel>
    not?: NestedEnumUniteFilter<$PrismaModel> | $Enums.Unite
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumStatusArticleFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusArticle | EnumStatusArticleFieldRefInput<$PrismaModel>
    in?: $Enums.StatusArticle[] | ListEnumStatusArticleFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusArticle[] | ListEnumStatusArticleFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusArticleFilter<$PrismaModel> | $Enums.StatusArticle
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUniteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Unite | EnumUniteFieldRefInput<$PrismaModel>
    in?: $Enums.Unite[] | ListEnumUniteFieldRefInput<$PrismaModel>
    notIn?: $Enums.Unite[] | ListEnumUniteFieldRefInput<$PrismaModel>
    not?: NestedEnumUniteWithAggregatesFilter<$PrismaModel> | $Enums.Unite
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUniteFilter<$PrismaModel>
    _max?: NestedEnumUniteFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumStatusArticleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusArticle | EnumStatusArticleFieldRefInput<$PrismaModel>
    in?: $Enums.StatusArticle[] | ListEnumStatusArticleFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusArticle[] | ListEnumStatusArticleFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusArticleWithAggregatesFilter<$PrismaModel> | $Enums.StatusArticle
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusArticleFilter<$PrismaModel>
    _max?: NestedEnumStatusArticleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumTypeMouvementFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeMouvement | EnumTypeMouvementFieldRefInput<$PrismaModel>
    in?: $Enums.TypeMouvement[] | ListEnumTypeMouvementFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeMouvement[] | ListEnumTypeMouvementFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeMouvementFilter<$PrismaModel> | $Enums.TypeMouvement
  }

  export type NestedEnumTypeMouvementWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeMouvement | EnumTypeMouvementFieldRefInput<$PrismaModel>
    in?: $Enums.TypeMouvement[] | ListEnumTypeMouvementFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeMouvement[] | ListEnumTypeMouvementFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeMouvementWithAggregatesFilter<$PrismaModel> | $Enums.TypeMouvement
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeMouvementFilter<$PrismaModel>
    _max?: NestedEnumTypeMouvementFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumStatusInventaireFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusInventaire | EnumStatusInventaireFieldRefInput<$PrismaModel>
    in?: $Enums.StatusInventaire[] | ListEnumStatusInventaireFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusInventaire[] | ListEnumStatusInventaireFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusInventaireFilter<$PrismaModel> | $Enums.StatusInventaire
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumStatusInventaireWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusInventaire | EnumStatusInventaireFieldRefInput<$PrismaModel>
    in?: $Enums.StatusInventaire[] | ListEnumStatusInventaireFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusInventaire[] | ListEnumStatusInventaireFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusInventaireWithAggregatesFilter<$PrismaModel> | $Enums.StatusInventaire
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusInventaireFilter<$PrismaModel>
    _max?: NestedEnumStatusInventaireFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumStatusEquipementFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusEquipement | EnumStatusEquipementFieldRefInput<$PrismaModel>
    in?: $Enums.StatusEquipement[] | ListEnumStatusEquipementFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusEquipement[] | ListEnumStatusEquipementFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusEquipementFilter<$PrismaModel> | $Enums.StatusEquipement
  }

  export type NestedEnumStatusEquipementWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusEquipement | EnumStatusEquipementFieldRefInput<$PrismaModel>
    in?: $Enums.StatusEquipement[] | ListEnumStatusEquipementFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusEquipement[] | ListEnumStatusEquipementFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusEquipementWithAggregatesFilter<$PrismaModel> | $Enums.StatusEquipement
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusEquipementFilter<$PrismaModel>
    _max?: NestedEnumStatusEquipementFilter<$PrismaModel>
  }

  export type NestedEnumTypeMaintenanceFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeMaintenance | EnumTypeMaintenanceFieldRefInput<$PrismaModel>
    in?: $Enums.TypeMaintenance[] | ListEnumTypeMaintenanceFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeMaintenance[] | ListEnumTypeMaintenanceFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeMaintenanceFilter<$PrismaModel> | $Enums.TypeMaintenance
  }

  export type NestedEnumStatusMaintenanceFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusMaintenance | EnumStatusMaintenanceFieldRefInput<$PrismaModel>
    in?: $Enums.StatusMaintenance[] | ListEnumStatusMaintenanceFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusMaintenance[] | ListEnumStatusMaintenanceFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusMaintenanceFilter<$PrismaModel> | $Enums.StatusMaintenance
  }

  export type NestedEnumTypeMaintenanceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeMaintenance | EnumTypeMaintenanceFieldRefInput<$PrismaModel>
    in?: $Enums.TypeMaintenance[] | ListEnumTypeMaintenanceFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeMaintenance[] | ListEnumTypeMaintenanceFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeMaintenanceWithAggregatesFilter<$PrismaModel> | $Enums.TypeMaintenance
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeMaintenanceFilter<$PrismaModel>
    _max?: NestedEnumTypeMaintenanceFilter<$PrismaModel>
  }

  export type NestedEnumStatusMaintenanceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusMaintenance | EnumStatusMaintenanceFieldRefInput<$PrismaModel>
    in?: $Enums.StatusMaintenance[] | ListEnumStatusMaintenanceFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusMaintenance[] | ListEnumStatusMaintenanceFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusMaintenanceWithAggregatesFilter<$PrismaModel> | $Enums.StatusMaintenance
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusMaintenanceFilter<$PrismaModel>
    _max?: NestedEnumStatusMaintenanceFilter<$PrismaModel>
  }

  export type NestedEnumStatusReceptionFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusReception | EnumStatusReceptionFieldRefInput<$PrismaModel>
    in?: $Enums.StatusReception[] | ListEnumStatusReceptionFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusReception[] | ListEnumStatusReceptionFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusReceptionFilter<$PrismaModel> | $Enums.StatusReception
  }

  export type NestedEnumStatusReceptionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusReception | EnumStatusReceptionFieldRefInput<$PrismaModel>
    in?: $Enums.StatusReception[] | ListEnumStatusReceptionFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusReception[] | ListEnumStatusReceptionFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusReceptionWithAggregatesFilter<$PrismaModel> | $Enums.StatusReception
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusReceptionFilter<$PrismaModel>
    _max?: NestedEnumStatusReceptionFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type MouvementStockCreateWithoutArticleInput = {
    id?: string
    type: $Enums.TypeMouvement
    quantite: number
    dateOperation?: Date | string
    utilisateurId: string
    numeroDocument?: string | null
    emplacement?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type MouvementStockUncheckedCreateWithoutArticleInput = {
    id?: string
    type: $Enums.TypeMouvement
    quantite: number
    dateOperation?: Date | string
    utilisateurId: string
    numeroDocument?: string | null
    emplacement?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type MouvementStockCreateOrConnectWithoutArticleInput = {
    where: MouvementStockWhereUniqueInput
    create: XOR<MouvementStockCreateWithoutArticleInput, MouvementStockUncheckedCreateWithoutArticleInput>
  }

  export type MouvementStockCreateManyArticleInputEnvelope = {
    data: MouvementStockCreateManyArticleInput | MouvementStockCreateManyArticleInput[]
    skipDuplicates?: boolean
  }

  export type LigneInventaireCreateWithoutArticleInput = {
    id?: string
    quantiteTheorique?: number
    quantiteReelle?: number
    ecart?: number
    valeurEcart?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventaire: InventaireCreateNestedOneWithoutLignesInput
  }

  export type LigneInventaireUncheckedCreateWithoutArticleInput = {
    id?: string
    inventaireId: string
    quantiteTheorique?: number
    quantiteReelle?: number
    ecart?: number
    valeurEcart?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LigneInventaireCreateOrConnectWithoutArticleInput = {
    where: LigneInventaireWhereUniqueInput
    create: XOR<LigneInventaireCreateWithoutArticleInput, LigneInventaireUncheckedCreateWithoutArticleInput>
  }

  export type LigneInventaireCreateManyArticleInputEnvelope = {
    data: LigneInventaireCreateManyArticleInput | LigneInventaireCreateManyArticleInput[]
    skipDuplicates?: boolean
  }

  export type LigneReceptionCreateWithoutArticleInput = {
    id?: string
    designation: string
    quantitePrev?: number
    quantiteRecue?: number
    prixUnitaire?: number
    tva?: number | null
    ecart?: number
    notes?: string | null
    createdAt?: Date | string
    reception: ReceptionCreateNestedOneWithoutLignesInput
  }

  export type LigneReceptionUncheckedCreateWithoutArticleInput = {
    id?: string
    receptionId: string
    designation: string
    quantitePrev?: number
    quantiteRecue?: number
    prixUnitaire?: number
    tva?: number | null
    ecart?: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type LigneReceptionCreateOrConnectWithoutArticleInput = {
    where: LigneReceptionWhereUniqueInput
    create: XOR<LigneReceptionCreateWithoutArticleInput, LigneReceptionUncheckedCreateWithoutArticleInput>
  }

  export type LigneReceptionCreateManyArticleInputEnvelope = {
    data: LigneReceptionCreateManyArticleInput | LigneReceptionCreateManyArticleInput[]
    skipDuplicates?: boolean
  }

  export type MouvementStockUpsertWithWhereUniqueWithoutArticleInput = {
    where: MouvementStockWhereUniqueInput
    update: XOR<MouvementStockUpdateWithoutArticleInput, MouvementStockUncheckedUpdateWithoutArticleInput>
    create: XOR<MouvementStockCreateWithoutArticleInput, MouvementStockUncheckedCreateWithoutArticleInput>
  }

  export type MouvementStockUpdateWithWhereUniqueWithoutArticleInput = {
    where: MouvementStockWhereUniqueInput
    data: XOR<MouvementStockUpdateWithoutArticleInput, MouvementStockUncheckedUpdateWithoutArticleInput>
  }

  export type MouvementStockUpdateManyWithWhereWithoutArticleInput = {
    where: MouvementStockScalarWhereInput
    data: XOR<MouvementStockUpdateManyMutationInput, MouvementStockUncheckedUpdateManyWithoutArticleInput>
  }

  export type MouvementStockScalarWhereInput = {
    AND?: MouvementStockScalarWhereInput | MouvementStockScalarWhereInput[]
    OR?: MouvementStockScalarWhereInput[]
    NOT?: MouvementStockScalarWhereInput | MouvementStockScalarWhereInput[]
    id?: StringFilter<"MouvementStock"> | string
    articleId?: StringFilter<"MouvementStock"> | string
    type?: EnumTypeMouvementFilter<"MouvementStock"> | $Enums.TypeMouvement
    quantite?: FloatFilter<"MouvementStock"> | number
    dateOperation?: DateTimeFilter<"MouvementStock"> | Date | string
    utilisateurId?: StringFilter<"MouvementStock"> | string
    numeroDocument?: StringNullableFilter<"MouvementStock"> | string | null
    emplacement?: StringNullableFilter<"MouvementStock"> | string | null
    notes?: StringNullableFilter<"MouvementStock"> | string | null
    createdAt?: DateTimeFilter<"MouvementStock"> | Date | string
  }

  export type LigneInventaireUpsertWithWhereUniqueWithoutArticleInput = {
    where: LigneInventaireWhereUniqueInput
    update: XOR<LigneInventaireUpdateWithoutArticleInput, LigneInventaireUncheckedUpdateWithoutArticleInput>
    create: XOR<LigneInventaireCreateWithoutArticleInput, LigneInventaireUncheckedCreateWithoutArticleInput>
  }

  export type LigneInventaireUpdateWithWhereUniqueWithoutArticleInput = {
    where: LigneInventaireWhereUniqueInput
    data: XOR<LigneInventaireUpdateWithoutArticleInput, LigneInventaireUncheckedUpdateWithoutArticleInput>
  }

  export type LigneInventaireUpdateManyWithWhereWithoutArticleInput = {
    where: LigneInventaireScalarWhereInput
    data: XOR<LigneInventaireUpdateManyMutationInput, LigneInventaireUncheckedUpdateManyWithoutArticleInput>
  }

  export type LigneInventaireScalarWhereInput = {
    AND?: LigneInventaireScalarWhereInput | LigneInventaireScalarWhereInput[]
    OR?: LigneInventaireScalarWhereInput[]
    NOT?: LigneInventaireScalarWhereInput | LigneInventaireScalarWhereInput[]
    id?: StringFilter<"LigneInventaire"> | string
    inventaireId?: StringFilter<"LigneInventaire"> | string
    articleId?: StringFilter<"LigneInventaire"> | string
    quantiteTheorique?: FloatFilter<"LigneInventaire"> | number
    quantiteReelle?: FloatFilter<"LigneInventaire"> | number
    ecart?: FloatFilter<"LigneInventaire"> | number
    valeurEcart?: FloatFilter<"LigneInventaire"> | number
    notes?: StringNullableFilter<"LigneInventaire"> | string | null
    createdAt?: DateTimeFilter<"LigneInventaire"> | Date | string
    updatedAt?: DateTimeFilter<"LigneInventaire"> | Date | string
  }

  export type LigneReceptionUpsertWithWhereUniqueWithoutArticleInput = {
    where: LigneReceptionWhereUniqueInput
    update: XOR<LigneReceptionUpdateWithoutArticleInput, LigneReceptionUncheckedUpdateWithoutArticleInput>
    create: XOR<LigneReceptionCreateWithoutArticleInput, LigneReceptionUncheckedCreateWithoutArticleInput>
  }

  export type LigneReceptionUpdateWithWhereUniqueWithoutArticleInput = {
    where: LigneReceptionWhereUniqueInput
    data: XOR<LigneReceptionUpdateWithoutArticleInput, LigneReceptionUncheckedUpdateWithoutArticleInput>
  }

  export type LigneReceptionUpdateManyWithWhereWithoutArticleInput = {
    where: LigneReceptionScalarWhereInput
    data: XOR<LigneReceptionUpdateManyMutationInput, LigneReceptionUncheckedUpdateManyWithoutArticleInput>
  }

  export type LigneReceptionScalarWhereInput = {
    AND?: LigneReceptionScalarWhereInput | LigneReceptionScalarWhereInput[]
    OR?: LigneReceptionScalarWhereInput[]
    NOT?: LigneReceptionScalarWhereInput | LigneReceptionScalarWhereInput[]
    id?: StringFilter<"LigneReception"> | string
    receptionId?: StringFilter<"LigneReception"> | string
    articleId?: StringFilter<"LigneReception"> | string
    designation?: StringFilter<"LigneReception"> | string
    quantitePrev?: FloatFilter<"LigneReception"> | number
    quantiteRecue?: FloatFilter<"LigneReception"> | number
    prixUnitaire?: FloatFilter<"LigneReception"> | number
    tva?: FloatNullableFilter<"LigneReception"> | number | null
    ecart?: FloatFilter<"LigneReception"> | number
    notes?: StringNullableFilter<"LigneReception"> | string | null
    createdAt?: DateTimeFilter<"LigneReception"> | Date | string
  }

  export type ArticleCreateWithoutMouvementsInput = {
    id?: string
    reference: string
    nom: string
    description?: string | null
    categorie: string
    unite?: $Enums.Unite
    prixAchat?: number
    prixVente?: number
    quantiteStock?: number
    seuilAlerte?: number
    seuilRupture?: number
    emplacement?: string | null
    fournisseurId?: string | null
    status?: $Enums.StatusArticle
    createdAt?: Date | string
    updatedAt?: Date | string
    lignesInventaire?: LigneInventaireCreateNestedManyWithoutArticleInput
    lignesReception?: LigneReceptionCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutMouvementsInput = {
    id?: string
    reference: string
    nom: string
    description?: string | null
    categorie: string
    unite?: $Enums.Unite
    prixAchat?: number
    prixVente?: number
    quantiteStock?: number
    seuilAlerte?: number
    seuilRupture?: number
    emplacement?: string | null
    fournisseurId?: string | null
    status?: $Enums.StatusArticle
    createdAt?: Date | string
    updatedAt?: Date | string
    lignesInventaire?: LigneInventaireUncheckedCreateNestedManyWithoutArticleInput
    lignesReception?: LigneReceptionUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutMouvementsInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutMouvementsInput, ArticleUncheckedCreateWithoutMouvementsInput>
  }

  export type ArticleUpsertWithoutMouvementsInput = {
    update: XOR<ArticleUpdateWithoutMouvementsInput, ArticleUncheckedUpdateWithoutMouvementsInput>
    create: XOR<ArticleCreateWithoutMouvementsInput, ArticleUncheckedCreateWithoutMouvementsInput>
    where?: ArticleWhereInput
  }

  export type ArticleUpdateToOneWithWhereWithoutMouvementsInput = {
    where?: ArticleWhereInput
    data: XOR<ArticleUpdateWithoutMouvementsInput, ArticleUncheckedUpdateWithoutMouvementsInput>
  }

  export type ArticleUpdateWithoutMouvementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    unite?: EnumUniteFieldUpdateOperationsInput | $Enums.Unite
    prixAchat?: FloatFieldUpdateOperationsInput | number
    prixVente?: FloatFieldUpdateOperationsInput | number
    quantiteStock?: FloatFieldUpdateOperationsInput | number
    seuilAlerte?: FloatFieldUpdateOperationsInput | number
    seuilRupture?: FloatFieldUpdateOperationsInput | number
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    fournisseurId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusArticleFieldUpdateOperationsInput | $Enums.StatusArticle
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lignesInventaire?: LigneInventaireUpdateManyWithoutArticleNestedInput
    lignesReception?: LigneReceptionUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutMouvementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    unite?: EnumUniteFieldUpdateOperationsInput | $Enums.Unite
    prixAchat?: FloatFieldUpdateOperationsInput | number
    prixVente?: FloatFieldUpdateOperationsInput | number
    quantiteStock?: FloatFieldUpdateOperationsInput | number
    seuilAlerte?: FloatFieldUpdateOperationsInput | number
    seuilRupture?: FloatFieldUpdateOperationsInput | number
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    fournisseurId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusArticleFieldUpdateOperationsInput | $Enums.StatusArticle
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lignesInventaire?: LigneInventaireUncheckedUpdateManyWithoutArticleNestedInput
    lignesReception?: LigneReceptionUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type LigneInventaireCreateWithoutInventaireInput = {
    id?: string
    quantiteTheorique?: number
    quantiteReelle?: number
    ecart?: number
    valeurEcart?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    article: ArticleCreateNestedOneWithoutLignesInventaireInput
  }

  export type LigneInventaireUncheckedCreateWithoutInventaireInput = {
    id?: string
    articleId: string
    quantiteTheorique?: number
    quantiteReelle?: number
    ecart?: number
    valeurEcart?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LigneInventaireCreateOrConnectWithoutInventaireInput = {
    where: LigneInventaireWhereUniqueInput
    create: XOR<LigneInventaireCreateWithoutInventaireInput, LigneInventaireUncheckedCreateWithoutInventaireInput>
  }

  export type LigneInventaireCreateManyInventaireInputEnvelope = {
    data: LigneInventaireCreateManyInventaireInput | LigneInventaireCreateManyInventaireInput[]
    skipDuplicates?: boolean
  }

  export type LigneInventaireUpsertWithWhereUniqueWithoutInventaireInput = {
    where: LigneInventaireWhereUniqueInput
    update: XOR<LigneInventaireUpdateWithoutInventaireInput, LigneInventaireUncheckedUpdateWithoutInventaireInput>
    create: XOR<LigneInventaireCreateWithoutInventaireInput, LigneInventaireUncheckedCreateWithoutInventaireInput>
  }

  export type LigneInventaireUpdateWithWhereUniqueWithoutInventaireInput = {
    where: LigneInventaireWhereUniqueInput
    data: XOR<LigneInventaireUpdateWithoutInventaireInput, LigneInventaireUncheckedUpdateWithoutInventaireInput>
  }

  export type LigneInventaireUpdateManyWithWhereWithoutInventaireInput = {
    where: LigneInventaireScalarWhereInput
    data: XOR<LigneInventaireUpdateManyMutationInput, LigneInventaireUncheckedUpdateManyWithoutInventaireInput>
  }

  export type InventaireCreateWithoutLignesInput = {
    id?: string
    numeroInventaire: string
    dateDebut: Date | string
    dateFin?: Date | string | null
    status?: $Enums.StatusInventaire
    nbArticles?: number
    nbEcarts?: number
    montantEcart?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventaireUncheckedCreateWithoutLignesInput = {
    id?: string
    numeroInventaire: string
    dateDebut: Date | string
    dateFin?: Date | string | null
    status?: $Enums.StatusInventaire
    nbArticles?: number
    nbEcarts?: number
    montantEcart?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventaireCreateOrConnectWithoutLignesInput = {
    where: InventaireWhereUniqueInput
    create: XOR<InventaireCreateWithoutLignesInput, InventaireUncheckedCreateWithoutLignesInput>
  }

  export type ArticleCreateWithoutLignesInventaireInput = {
    id?: string
    reference: string
    nom: string
    description?: string | null
    categorie: string
    unite?: $Enums.Unite
    prixAchat?: number
    prixVente?: number
    quantiteStock?: number
    seuilAlerte?: number
    seuilRupture?: number
    emplacement?: string | null
    fournisseurId?: string | null
    status?: $Enums.StatusArticle
    createdAt?: Date | string
    updatedAt?: Date | string
    mouvements?: MouvementStockCreateNestedManyWithoutArticleInput
    lignesReception?: LigneReceptionCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutLignesInventaireInput = {
    id?: string
    reference: string
    nom: string
    description?: string | null
    categorie: string
    unite?: $Enums.Unite
    prixAchat?: number
    prixVente?: number
    quantiteStock?: number
    seuilAlerte?: number
    seuilRupture?: number
    emplacement?: string | null
    fournisseurId?: string | null
    status?: $Enums.StatusArticle
    createdAt?: Date | string
    updatedAt?: Date | string
    mouvements?: MouvementStockUncheckedCreateNestedManyWithoutArticleInput
    lignesReception?: LigneReceptionUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutLignesInventaireInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutLignesInventaireInput, ArticleUncheckedCreateWithoutLignesInventaireInput>
  }

  export type InventaireUpsertWithoutLignesInput = {
    update: XOR<InventaireUpdateWithoutLignesInput, InventaireUncheckedUpdateWithoutLignesInput>
    create: XOR<InventaireCreateWithoutLignesInput, InventaireUncheckedCreateWithoutLignesInput>
    where?: InventaireWhereInput
  }

  export type InventaireUpdateToOneWithWhereWithoutLignesInput = {
    where?: InventaireWhereInput
    data: XOR<InventaireUpdateWithoutLignesInput, InventaireUncheckedUpdateWithoutLignesInput>
  }

  export type InventaireUpdateWithoutLignesInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroInventaire?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusInventaireFieldUpdateOperationsInput | $Enums.StatusInventaire
    nbArticles?: IntFieldUpdateOperationsInput | number
    nbEcarts?: IntFieldUpdateOperationsInput | number
    montantEcart?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventaireUncheckedUpdateWithoutLignesInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroInventaire?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusInventaireFieldUpdateOperationsInput | $Enums.StatusInventaire
    nbArticles?: IntFieldUpdateOperationsInput | number
    nbEcarts?: IntFieldUpdateOperationsInput | number
    montantEcart?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleUpsertWithoutLignesInventaireInput = {
    update: XOR<ArticleUpdateWithoutLignesInventaireInput, ArticleUncheckedUpdateWithoutLignesInventaireInput>
    create: XOR<ArticleCreateWithoutLignesInventaireInput, ArticleUncheckedCreateWithoutLignesInventaireInput>
    where?: ArticleWhereInput
  }

  export type ArticleUpdateToOneWithWhereWithoutLignesInventaireInput = {
    where?: ArticleWhereInput
    data: XOR<ArticleUpdateWithoutLignesInventaireInput, ArticleUncheckedUpdateWithoutLignesInventaireInput>
  }

  export type ArticleUpdateWithoutLignesInventaireInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    unite?: EnumUniteFieldUpdateOperationsInput | $Enums.Unite
    prixAchat?: FloatFieldUpdateOperationsInput | number
    prixVente?: FloatFieldUpdateOperationsInput | number
    quantiteStock?: FloatFieldUpdateOperationsInput | number
    seuilAlerte?: FloatFieldUpdateOperationsInput | number
    seuilRupture?: FloatFieldUpdateOperationsInput | number
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    fournisseurId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusArticleFieldUpdateOperationsInput | $Enums.StatusArticle
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mouvements?: MouvementStockUpdateManyWithoutArticleNestedInput
    lignesReception?: LigneReceptionUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutLignesInventaireInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    unite?: EnumUniteFieldUpdateOperationsInput | $Enums.Unite
    prixAchat?: FloatFieldUpdateOperationsInput | number
    prixVente?: FloatFieldUpdateOperationsInput | number
    quantiteStock?: FloatFieldUpdateOperationsInput | number
    seuilAlerte?: FloatFieldUpdateOperationsInput | number
    seuilRupture?: FloatFieldUpdateOperationsInput | number
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    fournisseurId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusArticleFieldUpdateOperationsInput | $Enums.StatusArticle
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mouvements?: MouvementStockUncheckedUpdateManyWithoutArticleNestedInput
    lignesReception?: LigneReceptionUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type MaintenanceEquipementCreateWithoutEquipementInput = {
    id?: string
    type: $Enums.TypeMaintenance
    dateDebut: Date | string
    dateFin?: Date | string | null
    technicienId?: string | null
    description: string
    coutReel?: number
    status?: $Enums.StatusMaintenance
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceEquipementUncheckedCreateWithoutEquipementInput = {
    id?: string
    type: $Enums.TypeMaintenance
    dateDebut: Date | string
    dateFin?: Date | string | null
    technicienId?: string | null
    description: string
    coutReel?: number
    status?: $Enums.StatusMaintenance
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceEquipementCreateOrConnectWithoutEquipementInput = {
    where: MaintenanceEquipementWhereUniqueInput
    create: XOR<MaintenanceEquipementCreateWithoutEquipementInput, MaintenanceEquipementUncheckedCreateWithoutEquipementInput>
  }

  export type MaintenanceEquipementCreateManyEquipementInputEnvelope = {
    data: MaintenanceEquipementCreateManyEquipementInput | MaintenanceEquipementCreateManyEquipementInput[]
    skipDuplicates?: boolean
  }

  export type MaintenanceEquipementUpsertWithWhereUniqueWithoutEquipementInput = {
    where: MaintenanceEquipementWhereUniqueInput
    update: XOR<MaintenanceEquipementUpdateWithoutEquipementInput, MaintenanceEquipementUncheckedUpdateWithoutEquipementInput>
    create: XOR<MaintenanceEquipementCreateWithoutEquipementInput, MaintenanceEquipementUncheckedCreateWithoutEquipementInput>
  }

  export type MaintenanceEquipementUpdateWithWhereUniqueWithoutEquipementInput = {
    where: MaintenanceEquipementWhereUniqueInput
    data: XOR<MaintenanceEquipementUpdateWithoutEquipementInput, MaintenanceEquipementUncheckedUpdateWithoutEquipementInput>
  }

  export type MaintenanceEquipementUpdateManyWithWhereWithoutEquipementInput = {
    where: MaintenanceEquipementScalarWhereInput
    data: XOR<MaintenanceEquipementUpdateManyMutationInput, MaintenanceEquipementUncheckedUpdateManyWithoutEquipementInput>
  }

  export type MaintenanceEquipementScalarWhereInput = {
    AND?: MaintenanceEquipementScalarWhereInput | MaintenanceEquipementScalarWhereInput[]
    OR?: MaintenanceEquipementScalarWhereInput[]
    NOT?: MaintenanceEquipementScalarWhereInput | MaintenanceEquipementScalarWhereInput[]
    id?: StringFilter<"MaintenanceEquipement"> | string
    equipementId?: StringFilter<"MaintenanceEquipement"> | string
    type?: EnumTypeMaintenanceFilter<"MaintenanceEquipement"> | $Enums.TypeMaintenance
    dateDebut?: DateTimeFilter<"MaintenanceEquipement"> | Date | string
    dateFin?: DateTimeNullableFilter<"MaintenanceEquipement"> | Date | string | null
    technicienId?: StringNullableFilter<"MaintenanceEquipement"> | string | null
    description?: StringFilter<"MaintenanceEquipement"> | string
    coutReel?: FloatFilter<"MaintenanceEquipement"> | number
    status?: EnumStatusMaintenanceFilter<"MaintenanceEquipement"> | $Enums.StatusMaintenance
    createdAt?: DateTimeFilter<"MaintenanceEquipement"> | Date | string
    updatedAt?: DateTimeFilter<"MaintenanceEquipement"> | Date | string
  }

  export type EquipementCreateWithoutMaintenancesInput = {
    id?: string
    reference: string
    nom: string
    description?: string | null
    categorie: string
    dateAchat?: Date | string | null
    valeurAchat?: number
    departement?: string | null
    utilisateurId?: string | null
    emplacement?: string | null
    status?: $Enums.StatusEquipement
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipementUncheckedCreateWithoutMaintenancesInput = {
    id?: string
    reference: string
    nom: string
    description?: string | null
    categorie: string
    dateAchat?: Date | string | null
    valeurAchat?: number
    departement?: string | null
    utilisateurId?: string | null
    emplacement?: string | null
    status?: $Enums.StatusEquipement
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipementCreateOrConnectWithoutMaintenancesInput = {
    where: EquipementWhereUniqueInput
    create: XOR<EquipementCreateWithoutMaintenancesInput, EquipementUncheckedCreateWithoutMaintenancesInput>
  }

  export type EquipementUpsertWithoutMaintenancesInput = {
    update: XOR<EquipementUpdateWithoutMaintenancesInput, EquipementUncheckedUpdateWithoutMaintenancesInput>
    create: XOR<EquipementCreateWithoutMaintenancesInput, EquipementUncheckedCreateWithoutMaintenancesInput>
    where?: EquipementWhereInput
  }

  export type EquipementUpdateToOneWithWhereWithoutMaintenancesInput = {
    where?: EquipementWhereInput
    data: XOR<EquipementUpdateWithoutMaintenancesInput, EquipementUncheckedUpdateWithoutMaintenancesInput>
  }

  export type EquipementUpdateWithoutMaintenancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    dateAchat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valeurAchat?: FloatFieldUpdateOperationsInput | number
    departement?: NullableStringFieldUpdateOperationsInput | string | null
    utilisateurId?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusEquipementFieldUpdateOperationsInput | $Enums.StatusEquipement
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipementUncheckedUpdateWithoutMaintenancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    dateAchat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valeurAchat?: FloatFieldUpdateOperationsInput | number
    departement?: NullableStringFieldUpdateOperationsInput | string | null
    utilisateurId?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusEquipementFieldUpdateOperationsInput | $Enums.StatusEquipement
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneReceptionCreateWithoutReceptionInput = {
    id?: string
    designation: string
    quantitePrev?: number
    quantiteRecue?: number
    prixUnitaire?: number
    tva?: number | null
    ecart?: number
    notes?: string | null
    createdAt?: Date | string
    article: ArticleCreateNestedOneWithoutLignesReceptionInput
  }

  export type LigneReceptionUncheckedCreateWithoutReceptionInput = {
    id?: string
    articleId: string
    designation: string
    quantitePrev?: number
    quantiteRecue?: number
    prixUnitaire?: number
    tva?: number | null
    ecart?: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type LigneReceptionCreateOrConnectWithoutReceptionInput = {
    where: LigneReceptionWhereUniqueInput
    create: XOR<LigneReceptionCreateWithoutReceptionInput, LigneReceptionUncheckedCreateWithoutReceptionInput>
  }

  export type LigneReceptionCreateManyReceptionInputEnvelope = {
    data: LigneReceptionCreateManyReceptionInput | LigneReceptionCreateManyReceptionInput[]
    skipDuplicates?: boolean
  }

  export type LigneReceptionUpsertWithWhereUniqueWithoutReceptionInput = {
    where: LigneReceptionWhereUniqueInput
    update: XOR<LigneReceptionUpdateWithoutReceptionInput, LigneReceptionUncheckedUpdateWithoutReceptionInput>
    create: XOR<LigneReceptionCreateWithoutReceptionInput, LigneReceptionUncheckedCreateWithoutReceptionInput>
  }

  export type LigneReceptionUpdateWithWhereUniqueWithoutReceptionInput = {
    where: LigneReceptionWhereUniqueInput
    data: XOR<LigneReceptionUpdateWithoutReceptionInput, LigneReceptionUncheckedUpdateWithoutReceptionInput>
  }

  export type LigneReceptionUpdateManyWithWhereWithoutReceptionInput = {
    where: LigneReceptionScalarWhereInput
    data: XOR<LigneReceptionUpdateManyMutationInput, LigneReceptionUncheckedUpdateManyWithoutReceptionInput>
  }

  export type ReceptionCreateWithoutLignesInput = {
    id?: string
    numero: string
    bonCommandeId: string
    fournisseurId?: string | null
    dateReception?: Date | string
    status?: $Enums.StatusReception
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceptionUncheckedCreateWithoutLignesInput = {
    id?: string
    numero: string
    bonCommandeId: string
    fournisseurId?: string | null
    dateReception?: Date | string
    status?: $Enums.StatusReception
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceptionCreateOrConnectWithoutLignesInput = {
    where: ReceptionWhereUniqueInput
    create: XOR<ReceptionCreateWithoutLignesInput, ReceptionUncheckedCreateWithoutLignesInput>
  }

  export type ArticleCreateWithoutLignesReceptionInput = {
    id?: string
    reference: string
    nom: string
    description?: string | null
    categorie: string
    unite?: $Enums.Unite
    prixAchat?: number
    prixVente?: number
    quantiteStock?: number
    seuilAlerte?: number
    seuilRupture?: number
    emplacement?: string | null
    fournisseurId?: string | null
    status?: $Enums.StatusArticle
    createdAt?: Date | string
    updatedAt?: Date | string
    mouvements?: MouvementStockCreateNestedManyWithoutArticleInput
    lignesInventaire?: LigneInventaireCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutLignesReceptionInput = {
    id?: string
    reference: string
    nom: string
    description?: string | null
    categorie: string
    unite?: $Enums.Unite
    prixAchat?: number
    prixVente?: number
    quantiteStock?: number
    seuilAlerte?: number
    seuilRupture?: number
    emplacement?: string | null
    fournisseurId?: string | null
    status?: $Enums.StatusArticle
    createdAt?: Date | string
    updatedAt?: Date | string
    mouvements?: MouvementStockUncheckedCreateNestedManyWithoutArticleInput
    lignesInventaire?: LigneInventaireUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutLignesReceptionInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutLignesReceptionInput, ArticleUncheckedCreateWithoutLignesReceptionInput>
  }

  export type ReceptionUpsertWithoutLignesInput = {
    update: XOR<ReceptionUpdateWithoutLignesInput, ReceptionUncheckedUpdateWithoutLignesInput>
    create: XOR<ReceptionCreateWithoutLignesInput, ReceptionUncheckedCreateWithoutLignesInput>
    where?: ReceptionWhereInput
  }

  export type ReceptionUpdateToOneWithWhereWithoutLignesInput = {
    where?: ReceptionWhereInput
    data: XOR<ReceptionUpdateWithoutLignesInput, ReceptionUncheckedUpdateWithoutLignesInput>
  }

  export type ReceptionUpdateWithoutLignesInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    bonCommandeId?: StringFieldUpdateOperationsInput | string
    fournisseurId?: NullableStringFieldUpdateOperationsInput | string | null
    dateReception?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusReceptionFieldUpdateOperationsInput | $Enums.StatusReception
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceptionUncheckedUpdateWithoutLignesInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    bonCommandeId?: StringFieldUpdateOperationsInput | string
    fournisseurId?: NullableStringFieldUpdateOperationsInput | string | null
    dateReception?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusReceptionFieldUpdateOperationsInput | $Enums.StatusReception
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleUpsertWithoutLignesReceptionInput = {
    update: XOR<ArticleUpdateWithoutLignesReceptionInput, ArticleUncheckedUpdateWithoutLignesReceptionInput>
    create: XOR<ArticleCreateWithoutLignesReceptionInput, ArticleUncheckedCreateWithoutLignesReceptionInput>
    where?: ArticleWhereInput
  }

  export type ArticleUpdateToOneWithWhereWithoutLignesReceptionInput = {
    where?: ArticleWhereInput
    data: XOR<ArticleUpdateWithoutLignesReceptionInput, ArticleUncheckedUpdateWithoutLignesReceptionInput>
  }

  export type ArticleUpdateWithoutLignesReceptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    unite?: EnumUniteFieldUpdateOperationsInput | $Enums.Unite
    prixAchat?: FloatFieldUpdateOperationsInput | number
    prixVente?: FloatFieldUpdateOperationsInput | number
    quantiteStock?: FloatFieldUpdateOperationsInput | number
    seuilAlerte?: FloatFieldUpdateOperationsInput | number
    seuilRupture?: FloatFieldUpdateOperationsInput | number
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    fournisseurId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusArticleFieldUpdateOperationsInput | $Enums.StatusArticle
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mouvements?: MouvementStockUpdateManyWithoutArticleNestedInput
    lignesInventaire?: LigneInventaireUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutLignesReceptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    unite?: EnumUniteFieldUpdateOperationsInput | $Enums.Unite
    prixAchat?: FloatFieldUpdateOperationsInput | number
    prixVente?: FloatFieldUpdateOperationsInput | number
    quantiteStock?: FloatFieldUpdateOperationsInput | number
    seuilAlerte?: FloatFieldUpdateOperationsInput | number
    seuilRupture?: FloatFieldUpdateOperationsInput | number
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    fournisseurId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusArticleFieldUpdateOperationsInput | $Enums.StatusArticle
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mouvements?: MouvementStockUncheckedUpdateManyWithoutArticleNestedInput
    lignesInventaire?: LigneInventaireUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type MouvementStockCreateManyArticleInput = {
    id?: string
    type: $Enums.TypeMouvement
    quantite: number
    dateOperation?: Date | string
    utilisateurId: string
    numeroDocument?: string | null
    emplacement?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type LigneInventaireCreateManyArticleInput = {
    id?: string
    inventaireId: string
    quantiteTheorique?: number
    quantiteReelle?: number
    ecart?: number
    valeurEcart?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LigneReceptionCreateManyArticleInput = {
    id?: string
    receptionId: string
    designation: string
    quantitePrev?: number
    quantiteRecue?: number
    prixUnitaire?: number
    tva?: number | null
    ecart?: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type MouvementStockUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeMouvementFieldUpdateOperationsInput | $Enums.TypeMouvement
    quantite?: FloatFieldUpdateOperationsInput | number
    dateOperation?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateurId?: StringFieldUpdateOperationsInput | string
    numeroDocument?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementStockUncheckedUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeMouvementFieldUpdateOperationsInput | $Enums.TypeMouvement
    quantite?: FloatFieldUpdateOperationsInput | number
    dateOperation?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateurId?: StringFieldUpdateOperationsInput | string
    numeroDocument?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementStockUncheckedUpdateManyWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeMouvementFieldUpdateOperationsInput | $Enums.TypeMouvement
    quantite?: FloatFieldUpdateOperationsInput | number
    dateOperation?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateurId?: StringFieldUpdateOperationsInput | string
    numeroDocument?: NullableStringFieldUpdateOperationsInput | string | null
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneInventaireUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantiteTheorique?: FloatFieldUpdateOperationsInput | number
    quantiteReelle?: FloatFieldUpdateOperationsInput | number
    ecart?: FloatFieldUpdateOperationsInput | number
    valeurEcart?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventaire?: InventaireUpdateOneRequiredWithoutLignesNestedInput
  }

  export type LigneInventaireUncheckedUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventaireId?: StringFieldUpdateOperationsInput | string
    quantiteTheorique?: FloatFieldUpdateOperationsInput | number
    quantiteReelle?: FloatFieldUpdateOperationsInput | number
    ecart?: FloatFieldUpdateOperationsInput | number
    valeurEcart?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneInventaireUncheckedUpdateManyWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventaireId?: StringFieldUpdateOperationsInput | string
    quantiteTheorique?: FloatFieldUpdateOperationsInput | number
    quantiteReelle?: FloatFieldUpdateOperationsInput | number
    ecart?: FloatFieldUpdateOperationsInput | number
    valeurEcart?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneReceptionUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    quantitePrev?: FloatFieldUpdateOperationsInput | number
    quantiteRecue?: FloatFieldUpdateOperationsInput | number
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    tva?: NullableFloatFieldUpdateOperationsInput | number | null
    ecart?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reception?: ReceptionUpdateOneRequiredWithoutLignesNestedInput
  }

  export type LigneReceptionUncheckedUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    receptionId?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    quantitePrev?: FloatFieldUpdateOperationsInput | number
    quantiteRecue?: FloatFieldUpdateOperationsInput | number
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    tva?: NullableFloatFieldUpdateOperationsInput | number | null
    ecart?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneReceptionUncheckedUpdateManyWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    receptionId?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    quantitePrev?: FloatFieldUpdateOperationsInput | number
    quantiteRecue?: FloatFieldUpdateOperationsInput | number
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    tva?: NullableFloatFieldUpdateOperationsInput | number | null
    ecart?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneInventaireCreateManyInventaireInput = {
    id?: string
    articleId: string
    quantiteTheorique?: number
    quantiteReelle?: number
    ecart?: number
    valeurEcart?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LigneInventaireUpdateWithoutInventaireInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantiteTheorique?: FloatFieldUpdateOperationsInput | number
    quantiteReelle?: FloatFieldUpdateOperationsInput | number
    ecart?: FloatFieldUpdateOperationsInput | number
    valeurEcart?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: ArticleUpdateOneRequiredWithoutLignesInventaireNestedInput
  }

  export type LigneInventaireUncheckedUpdateWithoutInventaireInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    quantiteTheorique?: FloatFieldUpdateOperationsInput | number
    quantiteReelle?: FloatFieldUpdateOperationsInput | number
    ecart?: FloatFieldUpdateOperationsInput | number
    valeurEcart?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneInventaireUncheckedUpdateManyWithoutInventaireInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    quantiteTheorique?: FloatFieldUpdateOperationsInput | number
    quantiteReelle?: FloatFieldUpdateOperationsInput | number
    ecart?: FloatFieldUpdateOperationsInput | number
    valeurEcart?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceEquipementCreateManyEquipementInput = {
    id?: string
    type: $Enums.TypeMaintenance
    dateDebut: Date | string
    dateFin?: Date | string | null
    technicienId?: string | null
    description: string
    coutReel?: number
    status?: $Enums.StatusMaintenance
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceEquipementUpdateWithoutEquipementInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeMaintenanceFieldUpdateOperationsInput | $Enums.TypeMaintenance
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    technicienId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    coutReel?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusMaintenanceFieldUpdateOperationsInput | $Enums.StatusMaintenance
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceEquipementUncheckedUpdateWithoutEquipementInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeMaintenanceFieldUpdateOperationsInput | $Enums.TypeMaintenance
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    technicienId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    coutReel?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusMaintenanceFieldUpdateOperationsInput | $Enums.StatusMaintenance
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceEquipementUncheckedUpdateManyWithoutEquipementInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeMaintenanceFieldUpdateOperationsInput | $Enums.TypeMaintenance
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    technicienId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    coutReel?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusMaintenanceFieldUpdateOperationsInput | $Enums.StatusMaintenance
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneReceptionCreateManyReceptionInput = {
    id?: string
    articleId: string
    designation: string
    quantitePrev?: number
    quantiteRecue?: number
    prixUnitaire?: number
    tva?: number | null
    ecart?: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type LigneReceptionUpdateWithoutReceptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    quantitePrev?: FloatFieldUpdateOperationsInput | number
    quantiteRecue?: FloatFieldUpdateOperationsInput | number
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    tva?: NullableFloatFieldUpdateOperationsInput | number | null
    ecart?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: ArticleUpdateOneRequiredWithoutLignesReceptionNestedInput
  }

  export type LigneReceptionUncheckedUpdateWithoutReceptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    quantitePrev?: FloatFieldUpdateOperationsInput | number
    quantiteRecue?: FloatFieldUpdateOperationsInput | number
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    tva?: NullableFloatFieldUpdateOperationsInput | number | null
    ecart?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneReceptionUncheckedUpdateManyWithoutReceptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    quantitePrev?: FloatFieldUpdateOperationsInput | number
    quantiteRecue?: FloatFieldUpdateOperationsInput | number
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    tva?: NullableFloatFieldUpdateOperationsInput | number | null
    ecart?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use ArticleCountOutputTypeDefaultArgs instead
     */
    export type ArticleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ArticleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventaireCountOutputTypeDefaultArgs instead
     */
    export type InventaireCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventaireCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EquipementCountOutputTypeDefaultArgs instead
     */
    export type EquipementCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EquipementCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReceptionCountOutputTypeDefaultArgs instead
     */
    export type ReceptionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReceptionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ArticleDefaultArgs instead
     */
    export type ArticleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ArticleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MouvementStockDefaultArgs instead
     */
    export type MouvementStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MouvementStockDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventaireDefaultArgs instead
     */
    export type InventaireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventaireDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LigneInventaireDefaultArgs instead
     */
    export type LigneInventaireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LigneInventaireDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EquipementDefaultArgs instead
     */
    export type EquipementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EquipementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaintenanceEquipementDefaultArgs instead
     */
    export type MaintenanceEquipementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaintenanceEquipementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReceptionDefaultArgs instead
     */
    export type ReceptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReceptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LigneReceptionDefaultArgs instead
     */
    export type LigneReceptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LigneReceptionDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}